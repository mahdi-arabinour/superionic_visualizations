<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Conductivity by Structure × Dopant — Hard‑wired Columns (Size Legend + Control)</title>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { color-scheme: light; }
  body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:#fff; color:#111827; }
  header { padding: 16px 20px 0 20px; }
  h1 { font-size: 20px; margin: 0 0 8px; }
  .sub { color:#4b5563; font-size:13px; margin-bottom: 12px; }
  #controls { display:flex; gap:16px; align-items:center; flex-wrap: wrap; padding: 8px 20px 0 20px; color:#374151; font-size: 13px; }
  #chart { width: 100%; height: 78vh; }
  .pill { padding:4px 10px; border:1px solid #e5e7eb; border-radius: 999px; background:#f9fafb; }
  .status { padding: 8px 20px; color:#6b7280; font-size:12px;}
  .range { display:flex; align-items:center; gap:8px; }
  .range input[type="range"]{ accent-color:#2563eb; }
</style>
</head>
<body>
  <header>
    <h1>Conductivity by Structure × Dopant</h1>
    <div class="sub">Bubble color = <b>log<sub>10</sub>(σ)</b> (S/cm). Bubble size ∝ number of records. Columns are hard‑wired.</div>
  </header>

  <div id="controls">
    <label class="pill"><input id="toggleColorScale" type="checkbox"/> Color by <b>linear σ</b> (instead of log<sub>10</sub>(σ))</label>
    <label class="pill"><input id="toggleMean" type="checkbox"/> Use <b>mean</b> instead of median</label>
    <div class="pill range">
      <label for="sizeScale"><b>Bubble size</b></label>
      <input id="sizeScale" type="range" min="8" max="40" step="1" value="18"/>
      <span id="sizeScaleVal">18</span>
    </div>
  </div>

  <div id="chart"></div>
  <div class="status" id="status">Loading sample data…</div>

<script>
const COL_SIGMA   = "Conductivity σ (S·cm⁻¹)";
const COL_STRUCT  = "Structure Group";
const COL_DOPANT  = "Doping / and or GB Strategy";

function parseNumber(x) {
  if (x == null) return NaN;
  const s = String(x).trim().toLowerCase().replace(/,/g, "");
  if (!s) return NaN;
  const v = Number(s);
  if (!Number.isNaN(v)) return v;
  const m = s.match(/([0-9.]+)\\s*(?:x|\\*)\\s*10\\s*(?:\\^)?\\s*([-+]?\\d+)/i);
  if (m) {
    const base = Number(m[1]); const exp = Number(m[2]);
    if (!Number.isNaN(base) && !Number.isNaN(exp)) return base * Math.pow(10, exp);
  }
  return NaN;
}
function splitMulti(value) {
  if (!value) return [];
  return String(value).split(/[+,/&]| and /i).map(s => s.trim()).filter(Boolean);
}
function quantile(arr, q) {
  const a = arr.slice().sort((x,y)=>x-y);
  const pos = (a.length - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  if (a[base+1] !== undefined) return a[base] + rest * (a[base+1] - a[base]);
  return a[base];
}
function median(arr){ return quantile(arr, 0.5); }
function mean(arr){ return arr.reduce((s,x)=>s+x,0)/arr.length; }
function roundSig(x, sig=6){
  if (!isFinite(x) || x===0) return x;
  const e = Math.floor(Math.log10(Math.abs(x)));
  const f = Math.pow(10, sig-1-e);
  return Math.round(x*f)/f;
}

let LAST_ROWS = null;

function buildChart(rows, useMean=false, colorLinear=false, sizeScale=18) {
  LAST_ROWS = rows;
  const headers = Object.keys(rows[0] || {});
  if (!headers.includes(COL_SIGMA) || !headers.includes(COL_STRUCT) || !headers.includes(COL_DOPANT)) {
    document.getElementById("status").textContent = "Required columns not found in CSV (check headers).";
    Plotly.react("chart", [], {template:"plotly_white"});
    return;
  }

  // bucket (Structure, Dopant) -> values[]
  const bucket = new Map();
  for (const r of rows) {
    const dopants = splitMulti(r[COL_DOPANT]);
    const structure = String(r[COL_STRUCT] ?? "").trim();
    const raw = parseNumber(r[COL_SIGMA]);
    if (!structure || !isFinite(raw) || raw <= 0) continue;
    const keyBase = structure + "|||";
    if (dopants.length === 0) dopants.push("(none)");
    for (const d of dopants) {
      const key = keyBase + d;
      if (!bucket.has(key)) bucket.set(key, []);
      bucket.get(key).push(raw);
    }
  }

  const xs = [], ys = [], sizes = [], colors = [], texts = [], hover = [];
  for (const [key, arr] of bucket) {
    const [structure, dopant] = key.split("|||");
    const valArr = arr.filter(v => isFinite(v) && v > 0);
    if (!valArr.length) continue;
    const val = useMean ? mean(valArr) : median(valArr);
    const n = valArr.length;
    const colorVal = colorLinear ? val : Math.log10(val);

    xs.push(dopant);
    ys.push(structure);
    sizes.push(Math.sqrt(n) * sizeScale);
    colors.push(colorVal);

    const valRounded = roundSig(val, 6);
    const logRounded = roundSig(Math.log10(val), 6);
    texts.push(`${structure}<br><b>${dopant}</b>`);
    hover.push(
      `Structure: ${structure}<br>` +
      `Dopant: ${dopant}<br>` +
      `Count: ${n}<br>` +
      `Median σ: ${valRounded} S/cm<br>` +
      `log10(σ): ${logRounded}`
    );
  }

  // Main scatter
  const traceMain = {
    x: xs, y: ys, mode: "markers",
    text: texts,
    hovertemplate: "%{text}<br>%{customdata}<extra></extra>",
    customdata: hover.map(h => h.replace(/<br>/g, "\\n")),
    marker: {
      size: sizes, sizemode: "area",
      color: colors, colorscale: "Viridis",
      colorbar: { title: colorLinear ? "σ (S/cm)" : "log10(σ)", titleside: "right", thickness: 14, len: 0.8 },
      line: { width: 0.5, color: "rgba(0,0,0,0.2)" }
    },
    type: "scatter", xaxis: "x", yaxis: "y"
  };

  // Horizontal size legend (top strip)
  const counts = [1,4,9,16];
  const legendX = [1,2,3,4];
  const traceSizeLegend = {
    x: legendX, y: [1,1,1,1], mode: "markers+text",
    text: counts.map(n => n + (n===1 ? " record" : " records")), textposition: "bottom center",
    textfont: { size: 11, color: "#374151" },
    hoverinfo: "skip",
    marker: { size: counts.map(n => Math.sqrt(n)*sizeScale), sizemode: "area", color: "#9CA3AF", line: { width: 0.5, color: "rgba(0,0,0,0.2)" } },
    xaxis: "x2", yaxis: "y2", showlegend: false, type: "scatter"
  };

  const layout = {
    template: "plotly_white", paper_bgcolor: "#fff", plot_bgcolor: "#fff",
    margin: { l: 90, r: 60, t: 80, b: 60 },  // extra top margin for legend strip
    xaxis: { title: "Dopant / Strategy", automargin: true, tickangle: -30 },
    yaxis: { title: "Structure Group", automargin: true, categoryorder: "array" },
    // Legend strip across top
    xaxis2: { domain: [0.25, 0.95], visible: false },
    yaxis2: { domain: [0.88, 0.98], visible: false },
    annotations: [
      { xref:"x2", yref:"y2", x:0.1, y:1.25, showarrow:false, xanchor:"left",
        text:"Bubble size ∝ √(count)", font:{size:12, color:"#111827"} }
    ],
    showlegend: false
  };

  // Sort Y categories by highest color value
  const yCats = Array.from(new Set(ys));
  const catScore = new Map(yCats.map(c => [c, -Infinity]));
  for (let i=0;i<ys.length;i++){
    const cat = ys[i];
    const c = colors[i];
    catScore.set(cat, Math.max(catScore.get(cat), c));
  }
  if (yCats.length) {
    yCats.sort((a,b)=> (catScore.get(b)-catScore.get(a)));
    layout.yaxis.categoryarray = yCats;
  }

  Plotly.react("chart", [traceMain, traceSizeLegend], layout, {
    responsive: true, displaylogo: false,
    modeBarButtonsToRemove: ["lasso2d", "select2d"],
    toImageButtonOptions: {format: "png", filename: "conductivity_by_structure_dopant"}
  });

  document.getElementById("status").textContent =
    `Rendered ${xs.length} bubbles across ${yCats.length} structure groups (color by ` +
    (colorLinear ? "linear σ" : "log10(σ)") + (useMean ? ", mean" : ", median") + `). Size scale: ${sizeScale}`;
}

// Parse & render
const sampleCSV = `Structure Group,Doping / and or GB Strategy,Conductivity σ (S·cm⁻¹)
NASICON,Al,1.2e-3
NASICON,Al+Nb,7.5e-4
Halide,Cl,2.1e-3
Spinel,(none),4.7e-5
Argyrodite,I,6.0e-3`;

function parseAndBuild(csvText) {
  Papa.parse(csvText, {
    header: true, dynamicTyping: false, skipEmptyLines: true,
    complete: (res) => { 
      const scale = Number(document.getElementById("sizeScale").value) || 18;
      buildChart(res.data, document.getElementById("toggleMean").checked, document.getElementById("toggleColorScale").checked, scale);
    }
  });
}

parseAndBuild(sampleCSV);

fetch("data.csv")
  .then(r => r.ok ? r.text() : Promise.reject("No data.csv found in the same folder."))
  .then(text => { document.getElementById("status").textContent = "CSV loaded ✓"; parseAndBuild(text); })
  .catch(err => { document.getElementById("status").textContent = "Using sample (place your cleaned CSV as data.csv)."; console.warn(err); });

// Controls
document.getElementById("toggleColorScale").addEventListener("change", ()=>{
  fetch("data.csv").then(r => r.ok ? r.text() : sampleCSV).then(parseAndBuild);
});
document.getElementById("toggleMean").addEventListener("change", ()=>{
  fetch("data.csv").then(r => r.ok ? r.text() : sampleCSV).then(parseAndBuild);
});
document.getElementById("sizeScale").addEventListener("input", (e)=>{
  document.getElementById("sizeScaleVal").textContent = e.target.value;
  // Re-render with new size scale using last known data by refetching
  fetch("data.csv").then(r => r.ok ? r.text() : sampleCSV).then(parseAndBuild);
});
</script>
</body>
</html>
