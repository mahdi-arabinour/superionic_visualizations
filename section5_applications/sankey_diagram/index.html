<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Battery Material Flow Sankey</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:16px; background:#f7f7f7; }
  h1 { margin:0 0 10px; font-size:20px; }
  select, input, button { margin-right:10px; }
  svg { width:100%; height: calc(100vh - 80px); background:#fff; border:1px solid #e5e5e5; }
  .link { fill:none; stroke-opacity:.45; }
  .link:hover { stroke-opacity:.8; }
  .node text { font-size:12px; pointer-events:none; }
</style>
</head>
<body>
<h1>Battery Material Flow Sankey</h1>

<label>Data:
  <select id="dataFile">
    <option value="data_thresholded.csv" selected>Thresholded (layered)</option>
    <option value="data_raw.csv">RAW (layered)</option>
  </select>
</label>

<label>Layout:
  <select id="layoutType">
    <option value="4layer" selected>Anode → Structure Type → Ion Type → Cathode</option>
    <option value="3layer">Anode → SSE Structure Type → Cathode</option>
  </select>
</label>

<label>Min count:
  <input type="number" id="minCount" value="1" min="1" style="width:70px" />
</label>

<button id="renderBtn">Render</button>
<button id="downloadBtn">Download SVG</button>

<svg id="sankey"></svg>

<script>
/* ---------- Config ---------- */
const STRUCT = "SSE Structure Type";
const STRUCT_ALIASES = new Set(["SSE Structure Type","Structure Type"]);
const ionColors = {
  "Li+":"#F6C431","Na+":"#53B3CB","K+":"#F17C67","Mg2+":"#6CBF84",
  "Ca2+":"#A890D3","Al3+":"#FFB4E6","Zn2+":"#7FB2F0","Ag+":"#B0B0B0","O2-":"#3C3C3C"
};
const fallback = d3.scaleOrdinal(d3.schemeTableau10);

/* ---------- D3 setup ---------- */
// IMPORTANT: do NOT set nodeId; we use default index-based IDs
const svg = d3.select("#sankey");
const sankey = d3.sankey().nodeWidth(20).nodePadding(16);

/* ---------- UI ---------- */
document.getElementById("renderBtn").addEventListener("click", render);
document.getElementById("downloadBtn").addEventListener("click", () => {
  const serializer = new XMLSerializer();
  const src = serializer.serializeToString(document.querySelector("svg"));
  const blob = new Blob([src], {type:"image/svg+xml"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "sankey.svg"; a.click();
  URL.revokeObjectURL(url);
});

/* ---------- Helpers ---------- */
function sanitize(s){
  return String(s ?? "")
    .replace(/\u200B|\u200C|\u200D|\uFEFF/g,"")   // zero-width chars
    .replace(/\u2013|\u2014/g,"–")                // normalize dash to en-dash
    .trim();
}
function normLayer(s){
  const x = sanitize(s);
  return STRUCT_ALIASES.has(x) ? STRUCT : x;
}
function allowedPair(layout, sLayer, tLayer){
  const a = normLayer(sLayer), b = normLayer(tLayer);
  if (layout === "3layer") {
    return (a==="Anode" && b===STRUCT) || (a===STRUCT && b==="Cathode");
  }
  return (a==="Anode" && b===STRUCT) || (a===STRUCT && b==="Ion Type") || (a==="Ion Type" && b==="Cathode");
}
function colorForLink(l){
  if (normLayer(l.tLayer)==="Ion Type" && ionColors[l.targetName]) return ionColors[l.targetName];
  if (normLayer(l.sLayer)==="Ion Type" && ionColors[l.sourceName]) return ionColors[l.sourceName];
  return fallback(l.sLayer + "|" + l.sourceName);
}

/* ---------- Main render ---------- */
async function render(){
  svg.selectAll("*").remove();
  const dataset = document.getElementById("dataFile").value;
  const layout  = document.getElementById("layoutType").value;
  const minCnt  = +document.getElementById("minCount").value || 1;

  const {width, height} = svg.node().getBoundingClientRect();
  sankey.extent([[1,1],[width-1,height-6]]);

  let rows;
  try{
    rows = await d3.csv(dataset, d => ({
      Source: sanitize(d.Source),
      SourceName: sanitize(d.SourceName),
      TargetLayer: sanitize(d.TargetLayer),
      TargetName: sanitize(d.TargetName),
      Count: +d.Count || 0
    }));
  }catch(err){
    console.error("Failed to load CSV:", err);
    alert("Could not load " + dataset + " (ensure file is beside this HTML).");
    return;
  }
  console.log(`Loaded ${rows.length} rows from ${dataset}`);

  // Keep only valid, adjacent links for the chosen layout
  const dropped = { empty:0, small:0, badPair:0 };
  const linksRaw = [];
  for (const r of rows){
    const sLayer = normLayer(r.Source);
    const tLayer = normLayer(r.TargetLayer);
    const sName  = sanitize(r.SourceName);
    const tName  = sanitize(r.TargetName);
    const val    = +r.Count || 0;

    if (!sName || !tName) { dropped.empty++; continue; }
    if (val < minCnt)     { dropped.small++; continue; }
    if (!allowedPair(layout, sLayer, tLayer)) { dropped.badPair++; continue; }

    linksRaw.push({ sLayer, tLayer, sourceName:sName, targetName:tName, value:val });
  }
  console.log(`Kept ${linksRaw.length} links; dropped:`, dropped);

  if (!linksRaw.length){ console.warn("No links to draw."); return; }

  // Build unique nodes keyed by (name|layer)
  const nodeKeys = new Set();
  linksRaw.forEach(l => { nodeKeys.add(`${l.sourceName}|${l.sLayer}`); nodeKeys.add(`${l.targetName}|${l.tLayer}`); });
  const nodes = Array.from(nodeKeys).map(k => { const [name, layer] = k.split("|"); return { name, layer }; });
  const index = new Map(nodes.map((n,i)=>[`${n.name}|${n.layer}`, i]));

  // Map links to numeric indices (default sankey id mode)
  const links = linksRaw.map(l => ({
    source: index.get(`${l.sourceName}|${l.sLayer}`),
    target: index.get(`${l.targetName}|${l.tLayer}`),
    value:  l.value,
    ...l
  })).filter(d => d.source !== d.target);

  const graph = { nodes: nodes.map(d=>({...d})), links: links.map(d=>({...d})) };

  try { sankey(graph); }
  catch(e){ console.error("Sankey layout error:", e); alert("Sankey couldn't layout (see console)."); return; }

  // Draw links
  svg.append("g")
    .selectAll("path")
    .data(graph.links)
    .join("path")
    .attr("class","link")
    .attr("d", d3.sankeyLinkHorizontal())
    .attr("stroke", d => colorForLink(d))
    .attr("stroke-width", d => Math.max(1, d.width))
    .append("title")
    .text(d => `${graph.nodes[d.source].layer}: ${graph.nodes[d.source].name} → ${graph.nodes[d.target].layer}: ${graph.nodes[d.target].name}\nCount: ${d.value}`);

  // Draw nodes
  const nodeSel = svg.append("g")
    .selectAll(".node")
    .data(graph.nodes)
    .join("g")
    .attr("class","node");

  nodeSel.append("rect")
    .attr("x", d => d.x0)
    .attr("y", d => d.y0)
    .attr("width", sankey.nodeWidth())
    .attr("height", d => Math.max(1, d.y1 - d.y0))
    .attr("fill", d => fallback(d.layer + "|" + d.name))
    .attr("stroke", "#333")
    .append("title")
    .text(d => `${d.layer}: ${d.name}\nΣ = ${d.value ?? 0}`);

  nodeSel.append("text")
    .attr("x", d => d.x0 - 6)
    .attr("y", d => (d.y1 + d.y0)/2)
    .attr("dy",".35em")
    .attr("text-anchor","end")
    .text(d => d.name)
    .filter(d => d.x0 < svg.node().getBoundingClientRect().width / 2)
    .attr("x", d => d.x1 + 6)
    .attr("text-anchor","start");

  console.log(`Rendered ${graph.links.length} links, ${graph.nodes.length} nodes`);
}

// Auto render once on load
render();
</script>
</body>
</html>
