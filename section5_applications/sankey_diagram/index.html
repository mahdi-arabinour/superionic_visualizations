<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Anode → Structure Group → Ion Type → Cathode</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<style>
  :root { --side: 180px; }
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;background:#fafafa;color:#111;margin:24px}
  h2{margin:0 0 10px}
  .toolbar{display:flex;gap:10px;align-items:center;margin:10px 0 14px}
  .wrap{display:grid;grid-template-columns:1fr var(--side);gap:50px;align-items:start}
  svg{width:1100px;height:720px;background:#fff;border:1px solid #e5e5e5;border-radius:10px;overflow:visible}
  .side{position:sticky;top:16px;background:#fff;border:1px solid #e5e5e5;border-radius:10px;padding:12px}
  .legend-title{font-weight:700;font-size:14px;margin:6px 0}
  .legend-controls{display:flex;gap:6px;margin:4px 0 6px}
  .legend-controls button,button.primary{font-size:12px;padding:6px 10px;border:1px solid #ccc;background:#fff;cursor:pointer;border-radius:8px}
  .legend-item{display:flex;align-items:center;gap:8px;margin:6px 0;cursor:pointer;user-select:none}
  .legend-item.disabled{opacity:.35;text-decoration:line-through}
  .legend-swatch{width:16px;height:16px;border-radius:3px;border:1px solid #444}
  .node rect{stroke:#333;stroke-width:1px}
  .node text{font-size:10px;pointer-events:none}
  .link{fill:none;stroke-opacity:.35}
  .link:hover{stroke-opacity:.75}
  .tooltip{position:fixed;pointer-events:none;opacity:0;z-index:10;background:#fff;border:1px solid #e5e5e5;border-radius:8px;padding:8px 10px;font-size:12px;color:#111;box-shadow:0 6px 18px rgba(0,0,0,.08)}
  @media (max-width:1300px){svg{width:100%;height:660px}:root{--side:180px}}
</style>
</head>
<body>
<h2>Anode → Structure Group → Ion Type → Cathode</h2>
<div class="toolbar">
  <button id="downloadBtn" class="primary">Download SVG</button>
</div>

<div class="wrap">
  <svg></svg>
  <div class="side">
    <div class="legend-title">Structure Group (color)</div>
    <div class="legend-controls">
      <button id="showAll">Show all</button>
      <button id="hideAll">Hide all</button>
    </div>
    <div id="legend"></div>
  </div>
</div>

<div class="tooltip" id="tip"></div>

<script>
/* ========================== Tweakables ========================== */
const EXTRA_WIDTH        = 240;
const STRETCH            = 1.20;
const ANODE_LABEL_DX     = -8;
const MIDDLE_LABEL_DX    =  6;
const CATHODE_LABEL_DX   =  8;
const LAYOUT_VALUE_MULT  = 6;     // layout-only amplification so node heights show differences
/* ================================================================ */

const COL = { anode:"Anode", struct:"Structure Group", ion:"Ion Type", cathode:"Cathode" };
const MIN_COUNT = 1;

const svg = d3.select("svg");
const width  = +svg.attr("width")  || 1100;
const height = +svg.attr("height") || 720;
const tip = d3.select("#tip");

const structureColors = d3.scaleOrdinal()
  .domain(["Amorphous","Anti-perovskite","Argyrodite","Halide","NASICON","Spinel","Polymeric","Others"])
  .range (["#f6bf26","#2196f3","#ab47bc","#26a69a","#66bb6a","#ef5350","#ff7043","#9e9e9e"]);

const estTextWidth = s => (s ? s.length : 0) * 6.2;

d3.csv("data.csv").then(raw => {
  const rows = raw.map(d => ({
    anode:   (d[COL.anode]   ?? "").trim() || "No Anode",
    struct:  (d[COL.struct]  ?? "").trim() || "Others",
    ion:     (d[COL.ion]     ?? "").trim() || "Unknown Ion Type",
    cathode: (d[COL.cathode] ?? "").trim() || "No Cathode"
  }));

  const leftMargin  = Math.min(380, Math.max(90,  (d3.max(rows, d => estTextWidth(d.anode))   || 0) + 20));
  const rightMargin = Math.min(380, Math.max(90,  (d3.max(rows, d => estTextWidth(d.cathode)) || 0) + 20));

  svg.selectAll("*").remove();
  const g = svg.append("g").attr("transform",`translate(${leftMargin},10)`);

  // Aggregate full paths to counts
  const pathMap = new Map();
  rows.forEach(r => {
    const k = `${r.anode}|${r.struct}|${r.ion}|${r.cathode}`;
    pathMap.set(k, (pathMap.get(k) || 0) + 1);
  });
  const paths = [...pathMap.entries()].map(([k,v]) => {
    const [a,s,i,c] = k.split("|");
    return { anode:a, struct:s, ion:i, cathode:c, count:v };
  });

  // Aggregate between adjacent levels
  function linksBetween(fromKey,toKey){
    const m = new Map();
    paths.forEach(p => {
      const from = p[fromKey], to = p[toKey], sg = p.struct || "Others";
      const K = `${from}|${to}|${sg}`;
      m.set(K, (m.get(K) || 0) + p.count);
    });
    return [...m.entries()].map(([K,count]) => {
      const [from,to,sg] = K.split("|");
      return { fromKey:`${fromKey}:${from}`, toKey:`${toKey}:${to}`, value:count, struct:sg };
    });
  }

  const L12 = linksBetween("anode","struct");
  const L23 = linksBetween("struct","ion");
  const L34 = linksBetween("ion","cathode");
  const allLinks = [...L12, ...L23, ...L34];

  // Nodes
  const nodes = [];
  const nodeIndex = new Map();
  function addNode(key,label){
    if(!nodeIndex.has(key)){ nodeIndex.set(key,nodes.length); nodes.push({name:key,label}); }
  }
  paths.forEach(p=>{
    addNode(`anode:${p.anode}`,p.anode);
    addNode(`struct:${p.struct}`,p.struct);
    addNode(`ion:${p.ion}`,p.ion);
    addNode(`cathode:${p.cathode}`,p.cathode);
  });

  // Links for Sankey: keep true count and amplified value for layout
  const links = allLinks
    .filter(l => nodeIndex.has(l.fromKey) && nodeIndex.has(l.toKey) && l.value >= MIN_COUNT)
    .map(l => ({
      source: nodeIndex.get(l.fromKey),
      target: nodeIndex.get(l.toKey),
      value:  l.value * LAYOUT_VALUE_MULT, // layout
      count:  l.value,                      // true count
      struct: l.struct
    }));

  // Sankey (IMPORTANT: no nodeId, because we use numeric indices)
  const sankey = d3.sankey()
    .nodeWidth(18)
    .nodePadding(10)
    .nodeAlign(d3.sankeyJustify)
    .extent([[0,0],[width-leftMargin-rightMargin-40+240, height-40]]);

  const graph = sankey({
    nodes: nodes.map(d => ({...d})),
    links: links.map(d => ({...d}))
  });

  if (STRETCH !== 1) graph.nodes.forEach(d => { d.x0 *= STRETCH; d.x1 *= STRETCH; });

  // Links (stroke width from TRUE counts)
  const maxCount = d3.max(links, d => d.count) || 1;
  const minCount = d3.min(links, d => d.count) || 1;
  const widthScale = d3.scaleSqrt().domain([minCount, maxCount]).range([1, 30]);

  const link = g.append("g").selectAll("path").data(graph.links).join("path")
    .attr("class","link")
    .attr("d", d3.sankeyLinkHorizontal())
    .attr("stroke", d => structureColors(d.struct))
    .attr("stroke-width", d => widthScale(d.count))
    .on("mousemove",(ev,d)=>{
      tip.html(`<div><b>${d.source.label}</b> → <b>${d.target.label}</b></div>
                <div>Structure Group: <b>${d.struct}</b></div>
                <div>Count: <b>${d.count}</b></div>`)
         .style("opacity",1)
         .style("left",(ev.pageX+14)+"px")
         .style("top",(ev.pageY+14)+"px");
    })
    .on("mouseleave",()=>tip.style("opacity",0));

  // Node compositions (TRUE counts)
  const outComp = new Map(), inComp = new Map();
  function addTo(map, idx, key, v){
    const m = map.get(idx) || new Map();
    m.set(key, (m.get(key) || 0) + v);
    map.set(idx, m);
  }
  graph.links.forEach(l => { addTo(outComp, l.source.index, l.struct, l.count);
                             addTo(inComp,  l.target.index, l.struct, l.count); });

  const minX0 = d3.min(graph.nodes, n => n.x0);
  const maxX0 = d3.max(graph.nodes, n => n.x0);

  const defs = svg.append("defs");
  function gradientFor(node, entries, idPrefix){
    const id = `${idPrefix}-${node.index}`;
    const total = d3.sum(entries, d => d[1]) || 1;
    const grad = defs.append("linearGradient")
      .attr("id", id)
      .attr("gradientUnits", "userSpaceOnUse")
      .attr("x1", node.x0).attr("x2", node.x0)
      .attr("y1", node.y0).attr("y2", node.y1);
    let acc = 0;
    entries.forEach(([k,v])=>{
      const p0 = acc/total, p1 = (acc+v)/total, col = structureColors(k);
      grad.append("stop").attr("offset", p0).attr("stop-color", col);
      grad.append("stop").attr("offset", p1).attr("stop-color", col);
      acc += v;
    });
    return `url(#${id})`;
  }

  // Nodes (height = layout span)
  const node = g.append("g").selectAll("g").data(graph.nodes).join("g").attr("class","node");

  node.append("rect")
    .attr("x", d => d.x0)
    .attr("y", d => d.y0)
    .attr("width",  d => d.x1 - d.x0)
    .attr("height", d => Math.max(2, d.y1 - d.y0))
    .attr("fill", function(d){
      if (d.x0 === minX0) {
        const ent = Array.from(outComp.get(d.index) || []);
        if (ent.length) return gradientFor(d, ent, "out");
      }
      if (d.x0 === maxX0) {
        const ent = Array.from(inComp.get(d.index) || []);
        if (ent.length) return gradientFor(d, ent, "in");
      }
      if (d.name.startsWith("struct:")) return structureColors(d.label);
      return "#cccccc";
    });

  node.append("text")
    .attr("x", d => d.name.startsWith("anode:") ? d.x0 + ANODE_LABEL_DX
             : d.name.startsWith("cathode:") ? d.x1 + CATHODE_LABEL_DX
             : d.x1 + MIDDLE_LABEL_DX)
    .attr("y", d => (d.y0 + d.y1)/2)
    .attr("dy","0.35em")
    .attr("text-anchor", d => d.name.startsWith("anode:") ? "end"
                           : d.name.startsWith("cathode:") ? "start" : "start")
    .text(d => d.label);

  // Legend + simple filter
  const structValues = Array.from(new Set(paths.map(p => p.struct)));
  const legend = d3.select("#legend");
  let active = new Set(structValues);

  const items = legend.selectAll(".legend-item").data(structValues).enter()
    .append("div").attr("class","legend-item")
    .each(function(s){ const el=d3.select(this);
      el.append("div").attr("class","legend-swatch").style("background",structureColors(s));
      el.append("span").text(s);
    })
    .on("click", function(_, s){
      if (active.size === 1 && active.has(s)) {
        active = new Set(structValues);
        items.classed("disabled", false);
        link.attr("display", null);
      } else {
        active = new Set([s]);
        items.classed("disabled", d => d !== s);
        link.attr("display", d => d.struct === s ? null : "none");
      }
    });

  d3.select("#showAll").on("click", () => {
    active = new Set(structValues); items.classed("disabled", false); link.attr("display", null);
  });
  d3.select("#hideAll").on("click", () => {
    active.clear(); items.classed("disabled", true); link.attr("display", "none");
  });

  // Download
  document.getElementById("downloadBtn").addEventListener("click",()=>{
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"sankey_counts.svg"});
    a.click();
  });
});
</script>
</body>
</html>
