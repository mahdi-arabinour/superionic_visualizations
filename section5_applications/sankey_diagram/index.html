<script>
const COL = {
  anode:   "Anode",
  struct:  "Structure Group",
  ion:     "Ion Type",
  cathode: "Cathode"
};

// No bucketing
const MIN_COUNT = 1;

const svg   = d3.select("svg");
const width = +svg.attr("width")  || 1100;
const height= +svg.attr("height") || 720;
const tip   = d3.select("#tip");

// Color palette for Structure Group (+ Others gray)
const structureColors = d3.scaleOrdinal()
  .domain(["Amorphous","Anti-perovskite","Argyrodite","Halide","NASICON","Spinel","Polymeric","Others"])
  .range (["#f6bf26",   "#2196f3",        "#ab47bc",    "#26a69a","#66bb6a","#ef5350","#ff7043","#9e9e9e"]);

// quick text width estimator for 10px font (rough but reliable enough)
const estTextWidth = s => (s ? s.length : 0) * 6.2; // ~6.2px per char at 10px

d3.csv("data.csv").then(raw => {
  // 1) Normalize rows
  const rows = raw.map(d => ({
    anode:   (d[COL.anode]   ?? "").toString().trim() || "No Anode",
    struct:  (d[COL.struct]  ?? "").toString().trim() || "Others",
    ion:     (d[COL.ion]     ?? "").toString().trim() || "Unknown Ion Type",
    cathode: (d[COL.cathode] ?? "").toString().trim() || "No Cathode"
  }));

  // 2) Dynamic margins based on longest labels (10px font)
  const maxAnode   = d3.max(rows, d => estTextWidth(d.anode))   || 0;
  const maxCathode = d3.max(rows, d => estTextWidth(d.cathode)) || 0;

  const leftMargin  = Math.min(280, Math.max(90,  maxAnode + 20));   // clamp 90–280
  const rightMargin = Math.min(280, Math.max(90,  maxCathode + 20)); // clamp 90–280

  // clear any previous group (in case of hot reload)
  svg.selectAll("g").remove();

  const g = svg.append("g").attr("transform",`translate(${leftMargin},10)`);

  // 3) Count full 4-step paths
  const pathMap = new Map();
  rows.forEach(r => {
    const key = `${r.anode}|${r.struct}|${r.ion}|${r.cathode}`;
    pathMap.set(key, (pathMap.get(key) || 0) + 1);
  });

  const paths = [...pathMap.entries()].map(([k,v]) => {
    const [a,s,i,c] = k.split("|");
    return { anode:a, struct:s, ion:i, cathode:c, value:v };
  });

  // 4) Build adjacent links
  function linksFromPaths(aKey, bKey) {
    const m = new Map();
    paths.forEach(p => {
      const a = p[aKey], b = p[bKey], sg = p.struct || "Others";
      const K = `${a}|${b}|${sg}`;
      m.set(K, (m.get(K) || 0) + p.value);
    });
    return [...m.entries()].map(([K,v]) => {
      const [a,b,sg] = K.split("|");
      return { sourceKey:`${aKey}:${a}`, targetKey:`${bKey}:${b}`, value:v, struct:sg };
    });
  }

  const L12 = linksFromPaths("anode","struct");
  const L23 = linksFromPaths("struct","ion");
  const L34 = linksFromPaths("ion","cathode");
  const allLinks = [...L12, ...L23, ...L34];

  // 5) Build nodes
  const nodes = [];
  const nodeIndex = new Map();
  function addNode(key,label){
    if (!key) return;
    if (!nodeIndex.has(key)) {
      nodeIndex.set(key, nodes.length);
      nodes.push({ name:key, label });
    }
  }
  paths.forEach(p => {
    addNode(`anode:${p.anode}`,     p.anode);
    addNode(`struct:${p.struct}`,   p.struct);
    addNode(`ion:${p.ion}`,         p.ion);
    addNode(`cathode:${p.cathode}`, p.cathode);
  });

  // 6) Index links
  const links = allLinks
    .filter(l => nodeIndex.has(l.sourceKey) && nodeIndex.has(l.targetKey) && l.value >= MIN_COUNT)
    .map(l => ({
      source: nodeIndex.get(l.sourceKey),
      target: nodeIndex.get(l.targetKey),
      value:  l.value,
      struct: l.struct
    }));

  // 7) Sankey layout with dynamic margins
  const sankey = d3.sankey()
    .nodeWidth(18)
    .nodePadding(18)
    .nodeAlign(d3.sankeyJustify)
    .extent([[0,0],[width - leftMargin - rightMargin - 40, height - 40]]);

  const graph = sankey({
    nodes: nodes.map(d => ({...d})),
    links: links.map(d => ({...d}))
  });

  // === Force stroke width to reflect raw counts ===
  const maxValue = d3.max(graph.links, d => d.value) || 1;
  const minValue = d3.min(graph.links, d => d.value) || 1;
  const widthScale = d3.scaleSqrt()
    .domain([minValue, maxValue])
    .range([1, 30]); // increase 30 for stronger contrast

  // 8) Draw links
  const link = g.append("g")
    .selectAll("path")
    .data(graph.links)
    .join("path")
      .attr("class","link")
      .attr("d", d3.sankeyLinkHorizontal())
      .attr("stroke", d => structureColors(d.struct))
      .attr("stroke-width", d => widthScale(d.value))
      .attr("stroke-opacity", 0.35)
      .on("mousemove", (ev,d) => {
        tip.html(
          `<div><b>${d.source.label}</b> → <b>${d.target.label}</b></div>
           <div>Structure Group: <b>${d.struct}</b></div>
           <div>Count: <b>${d.value}</b></div>`
        )
        .style("opacity",1)
        .style("left",(ev.pageX+14)+"px")
        .style("top", (ev.pageY+14)+"px");
      })
      .on("mouseleave", () => tip.style("opacity",0));

  // 9) Draw nodes
  const node = g.append("g")
    .selectAll("g")
    .data(graph.nodes)
    .join("g").attr("class","node");

  node.append("rect")
      .attr("x", d => d.x0)
      .attr("y", d => d.y0)
      .attr("height", d => Math.max(1, d.y1 - d.y0))
      .attr("width",  d => d.x1 - d.x0)
      .attr("fill", d => d.name.startsWith("struct:")
        ? structureColors(d.label)
        : (d.label.startsWith("Other ") || d.label.startsWith("No ")) ? "#cfcfcf" : "#cccccc");

  // 10) Labels: anode left, cathode right, middle right
  node.append("text")
      .attr("x", d => {
        if (d.name.startsWith("anode:"))   return d.x0 - 8;
        if (d.name.startsWith("cathode:")) return d.x1 + 8;
        return d.x1 + 6;
      })
      .attr("y", d => (d.y0 + d.y1)/2)
      .attr("dy", "0.35em")
      .attr("text-anchor", d => {
        if (d.name.startsWith("anode:"))   return "end";
        if (d.name.startsWith("cathode:")) return "start";
        return "start";
      })
      .style("font-size","10px")
      .text(d => d.label);

  // 11) Legend (Structure Group) — click = isolate; click again = restore all
  const structValues = Array.from(new Set(paths.map(p => p.struct)));
  const legend = d3.select("#legend");
  let active = new Set(structValues);

  const items = legend.selectAll(".legend-item")
    .data(structValues)
    .enter().append("div").attr("class","legend-item")
    .each(function(s){
      const item = d3.select(this);
      item.append("div").attr("class","legend-swatch").style("background",structureColors(s));
      item.append("span").text(s);
    })
    .on("click", function(_, s){
      if (active.size === 1 && active.has(s)) {
        active = new Set(structValues);
        items.classed("disabled", false);
        link.attr("display", null);
      } else {
        active = new Set([s]);
        items.classed("disabled", d => d !== s);
        link.attr("display", d => (d.struct === s ? null : "none"));
      }
    });

  d3.select("#showAll").on("click", () => {
    active = new Set(structValues);
    items.classed("disabled", false);
    link.attr("display", null);
  });
  d3.select("#hideAll").on("click", () => {
    active = new Set();
    items.classed("disabled", true);
    link.attr("display", "none");
  });

  // 12) Download SVG
  document.getElementById("downloadBtn").addEventListener("click", () => {
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"sankey_anode_struct_ion_cathode.svg"});
    a.click();
  });
});
</script>
