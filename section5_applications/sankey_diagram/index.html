<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Battery Material Flow Sankey</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; padding: 16px; background:#fafafa; }
  h2 { margin: 0 0 12px; }
  label { margin-right: 6px; }
  select, input, button { margin-right: 10px; }
  svg { width: 100%; height: calc(100vh - 70px); background:#fff; border:1px solid #e5e5e5; }
  .link { fill: none; stroke-opacity: 0.45; }
  .link:hover { stroke-opacity: 0.8; }
  .node rect { rx:8px; ry:8px; }
  .node text { font-size: 12px; pointer-events: none; }
</style>
</head>
<body>

<h2>Battery Material Flow Sankey</h2>

<label>Data:</label>
<select id="dataFile">
  <option value="data_thresholded_layered_full.csv" selected>Thresholded (layered)</option>
  <option value="data_raw_layered_full.csv">RAW (layered)</option>
</select>

<label>Layout:</label>
<select id="layoutType">
  <option value="4layer" selected>Anode → Structure Type → Ion Type → Cathode</option>
  <option value="3layer">Anode → SSE Structure Type → Cathode</option>
</select>

<label>Min count:</label>
<input type="number" id="minCount" value="1" min="1" style="width:70px" />

<button id="renderBtn">Render</button>
<button id="downloadBtn">Download SVG</button>

<svg id="sankey"></svg>

<script>
const STRUCT = "SSE Structure Type";           // unify both spellings to this
const STRUCT_ALIASES = new Set(["SSE Structure Type","Structure Type"]);

const ionColors = {
  "Li+":  "#F6C431",  // gold
  "Na+":  "#53B3CB",  // cyan-blue
  "K+":   "#F17C67",  // salmon
  "Mg2+": "#6CBF84",  // green
  "Ca2+": "#A890D3",  // lavender
  "Al3+": "#FFB4E6",  // pink
  "Zn2+": "#7FB2F0",  // light blue
  "Ag+":  "#B0B0B0",  // silver
  "O2-":  "#3C3C3C"   // dark gray
};
const fallback = d3.scaleOrdinal(d3.schemeTableau10);

const svg = d3.select("#sankey");
const sankey = d3.sankey()
  .nodeWidth(20)
  .nodePadding(16);

document.getElementById("renderBtn").addEventListener("click", render);
document.getElementById("downloadBtn").addEventListener("click", () => {
  const serializer = new XMLSerializer();
  const src = serializer.serializeToString(document.querySelector("svg"));
  const blob = new Blob([src], {type:"image/svg+xml"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "sankey.svg"; a.click();
  URL.revokeObjectURL(url);
});

function normalizeLayerName(layer) {
  if (STRUCT_ALIASES.has(layer)) return STRUCT;
  return layer;
}

function allowedPair(layout, sLayer, tLayer) {
  sLayer = normalizeLayerName(sLayer);
  tLayer = normalizeLayerName(tLayer);
  if (layout === "3layer") {
    return (sLayer === "Anode" && tLayer === STRUCT) ||
           (sLayer === STRUCT && tLayer === "Cathode");
  } else {
    return (sLayer === "Anode" && tLayer === STRUCT) ||
           (sLayer === STRUCT && tLayer === "Ion Type") ||
           (sLayer === "Ion Type" && tLayer === "Cathode");
  }
}

function colorForLink(l) {
  // If the link touches the Ion layer, color by the ion label for consistency.
  if (normalizeLayerName(l.tLayer) === "Ion Type" && ionColors[l.targetName]) return ionColors[l.targetName];
  if (normalizeLayerName(l.sLayer) === "Ion Type" && ionColors[l.sourceName]) return ionColors[l.sourceName];
  // Otherwise, fall back to a stable color by source layer/name
  return fallback(l.sLayer + "|" + l.sourceName);
}

function render() {
  const file    = document.getElementById("dataFile").value;
  const layout  = document.getElementById("layoutType").value; // "3layer" or "4layer"
  const minCnt  = +document.getElementById("minCount").value || 1;

  svg.selectAll("*").remove();
  const {width, height} = svg.node().getBoundingClientRect();
  sankey.extent([[1,1],[width-1,height-6]]);

  d3.csv(file, d3.autoType).then(rows => {
    // Ensure required columns are present
    const needed = ["Source","SourceName","TargetLayer","TargetName","Count"];
    for (const k of needed) {
      if (!(k in rows[0])) {
        console.error("Missing column in CSV:", k);
        return;
      }
    }

    // Normalize and filter by layout & min count
    const linksRaw = rows
      .filter(d => +d.Count >= minCnt)
      .map(d => ({
        sLayer: normalizeLayerName(String(d.Source || "").trim()),
        tLayer: normalizeLayerName(String(d.TargetLayer || "").trim()),
        sourceName: String(d.SourceName || "").trim(),
        targetName: String(d.TargetName || "").trim(),
        value: +d.Count
      }))
      .filter(l => allowedPair(layout, l.sLayer, l.tLayer));

    if (!linksRaw.length) {
      console.warn("No links passed filters. Check layer names or Min count.");
      return;
    }

    // Build node list
    const nodeNames = Array.from(new Set(linksRaw.flatMap(l => [l.sourceName, l.targetName])));
    const nodes = nodeNames.map(name => ({ name }));
    const index = new Map(nodeNames.map((n,i)=>[n,i]));

    const links = linksRaw.map(l => ({
      source: index.get(l.sourceName),
      target: index.get(l.targetName),
      value:  l.value,
      sLayer: l.sLayer,
      tLayer: l.tLayer,
      sourceName: l.sourceName,
      targetName: l.targetName
    }));

    const graph = {nodes: nodes.map(d=>({...d})), links: links.map(d=>({...d}))};
    sankey(graph);

    // Links
    svg.append("g")
      .selectAll("path")
      .data(graph.links)
      .join("path")
      .attr("class","link")
      .attr("d", d3.sankeyLinkHorizontal())
      .attr("stroke", d => colorForLink(d))
      .attr("stroke-width", d => Math.max(1, d.width))
      .append("title")
      .text(d => `${d.sLayer}: ${d.source.name} → ${d.tLayer}: ${d.target.name}\nCount: ${d.value}`);

    // Nodes
    const node = svg.append("g")
      .selectAll(".node")
      .data(graph.nodes)
      .join("g")
      .attr("class","node");

    node.append("rect")
      .attr("x", d => d.x0)
      .attr("y", d => d.y0)
      .attr("width", sankey.nodeWidth())
      .attr("height", d => Math.max(1, d.y1 - d.y0))
      .attr("fill", d => fallback(d.name))
      .attr("stroke", "#333")
      .append("title")
      .text(d => `${d.name}\nΣ = ${d.value ?? 0}`);

    node.append("text")
      .attr("x", d => d.x0 - 6)
      .attr("y", d => (d.y1 + d.y0) / 2)
      .attr("dy",".35em")
      .attr("text-anchor","end")
      .text(d => d.name)
      .filter(d => d.x0 < width / 2)
      .attr("x", d => d.x1 + 6)
      .attr("text-anchor","start");
  });
}

// Initial draw
render();
</script>
</body>
</html>
