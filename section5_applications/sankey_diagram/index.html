<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Sankey — Anode → Structure Group → Ion Type → Cathode</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<style>
  :root { --side: 280px; }
  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    background: #fafafa; color: #111; margin: 24px;
  }
  h2 { margin: 0 0 10px; }
  .toolbar { display: flex; gap: 10px; align-items: center; margin: 10px 0 14px; }
  .note { font-size: 12px; color: #64748b; }

  .wrap { display: grid; grid-template-columns: 1fr var(--side); gap: 16px; align-items: start; }
  svg { width: 1100px; height: 700px; background: #fff; border: 1px solid #e5e5e5; border-radius: 10px; }

  .side { position: sticky; top: 16px; background: #fff; border: 1px solid #e5e5e5; border-radius: 10px; padding: 12px; }
  .legend-title { font-weight: 700; font-size: 14px; margin: 6px 0; }
  .legend-controls { display: flex; gap: 6px; margin: 4px 0 6px; }
  .legend-controls button,
  button.primary { font-size: 12px; padding: 6px 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; border-radius: 8px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin: 6px 0; cursor: pointer; user-select: none; }
  .legend-item.disabled { opacity: .35; text-decoration: line-through; }
  .legend-swatch { width: 16px; height: 16px; border-radius: 3px; border: 1px solid #444; }

  .node rect { stroke: #333; stroke-width: 1px; }
  .node text { font-size: 12px; pointer-events: none; }
  .link { fill: none; stroke-opacity: 0.35; }
  .link:hover { stroke-opacity: 0.7; }

  .tooltip {
    position: fixed; pointer-events: none; opacity: 0; z-index: 10;
    background: #fff; border: 1px solid #e5e5e5; border-radius: 8px;
    padding: 8px 10px; font-size: 12px; color: #111;
    box-shadow: 0 6px 18px rgba(0,0,0,.08);
  }

  @media (max-width: 1300px) {
    svg { width: 100%; height: 640px; }
    :root { --side: 240px; }
  }
</style>
</head>
<body>
  <h2>Sankey — Anode → Structure Group → Ion Type → Cathode</h2>
  <div class="toolbar">
    <button id="downloadBtn" class="primary">Download SVG</button>
    <span class="note">Links colored by Structure Group; size = count.</span>
  </div>

  <div class="wrap">
    <svg></svg>
    <div class="side">
      <div class="legend-title">Structure Group (color)</div>
      <div class="legend-controls">
        <button id="showAll">Show all</button>
        <button id="hideAll">Hide all</button>
      </div>
      <div id="legend"></div>
    </div>
  </div>

  <div class="tooltip" id="tip"></div>

<script>
const COL = {
  anode:   "Anode",
  struct:  "Structure Group",
  ion:     "Ion Type",
  cathode: "Cathode"
};

const svg = d3.select("svg");
const width  = +svg.attr("width")  || 1100;
const height = +svg.attr("height") || 700;
const g   = svg.append("g").attr("transform", "translate(10,10)");
const tip = d3.select("#tip");

// Palette consistent with your other charts
const structureColors = d3.scaleOrdinal()
  .domain(["Amorphous","Anti-perovskite","Argyrodite","Halide","NASICON","Spinel","Polymeric","Others"])
  .range(["#f6bf26","#2196f3","#ab47bc","#26a69a","#66bb6a","#ef5350","#ff7043","#9e9e9e"]);

d3.csv("data.csv").then(raw => {
  // 1) Clean rows
  const rows = raw.map(d => ({
    anode:   (d[COL.anode]   || "Unknown").trim(),
    struct:  (d[COL.struct]  || "Others").trim(),
    ion:     (d[COL.ion]     || "Unknown").trim(),
    cathode: (d[COL.cathode] || "Unknown").trim()
  }));

  const structureGroups = Array.from(new Set(rows.map(d => d.struct)));

  // 2) Build links for adjacent pairs; aggregate by (source, target, struct)
  function linkCount(aKey, bKey) {
    const m = new Map();
    rows.forEach(r => {
      const a = r[aKey]; if (!a) return;
      const b = r[bKey]; if (!b) return;
      const sg = r.struct || "Others";
      const key = `${a}|${b}|${sg}`;
      m.set(key, (m.get(key) || 0) + 1);
    });
    return [...m.entries()].map(([k, v]) => {
      const [a, b, sg] = k.split("|");
      return { sourceKey: `${aKey}:${a}`, targetKey: `${bKey}:${b}`, value: v, struct: sg };
    });
  }

  const links12 = linkCount("anode", "struct");
  const links23 = linkCount("struct", "ion");
  const links34 = linkCount("ion", "cathode");
  const allLinks = [...links12, ...links23, ...links34];

  // 3) Create every node explicitly so nothing is missing
  const nodes = [];
  const nodeIndex = new Map();
  function addNode(key, label) {
    if (!key) return;
    if (!nodeIndex.has(key)) {
      nodeIndex.set(key, nodes.length);
      nodes.push({ name: key, label });
    }
  }

  rows.forEach(r => {
    addNode(`anode:${r.anode}`, r.anode);
    addNode(`struct:${r.struct}`, r.struct);
    addNode(`ion:${r.ion}`, r.ion);
    addNode(`cathode:${r.cathode}`, r.cathode);
  });

  // 4) Keep only links whose endpoints exist
  const links = allLinks
    .filter(l => nodeIndex.has(l.sourceKey) && nodeIndex.has(l.targetKey))
    .map(l => ({
      source: nodeIndex.get(l.sourceKey),
      target: nodeIndex.get(l.targetKey),
      value:  l.value,
      struct: l.struct
    }));

  // 5) Sankey layout
  const sankey = d3.sankey()
    .nodeId(d => d.name)
    .nodeWidth(18)
    .nodePadding(16)
    .nodeAlign(d3.sankeyJustify)
    .extent([[0,0],[width-40,height-40]]);

  const graph = sankey({
    nodes: nodes.map(d => ({...d})),
    links: links.map(d => ({...d}))
  });

  // 6) Draw links
  const link = g.append("g")
    .selectAll("path")
    .data(graph.links)
    .join("path")
      .attr("class", "link")
      .attr("d", d3.sankeyLinkHorizontal())
      .attr("stroke", d => structureColors(d.struct))
      .attr("stroke-width", d => Math.max(1, d.width))
      .on("mousemove", (ev, d) => {
        tip.html(`<b>${d.source.label}</b> → <b>${d.target.label}</b><br>
          Structure Group: <b>${d.struct}</b><br>
          Count: <b>${d.value}</b>`)
          .style("opacity",1)
          .style("left", (ev.pageX + 14) + "px")
          .style("top",  (ev.pageY + 14) + "px");
      })
      .on("mouseleave", () => tip.style("opacity", 0));

  // 7) Draw nodes
  const node = g.append("g")
    .selectAll("g")
    .data(graph.nodes)
    .join("g")
      .attr("class","node");

  node.append("rect")
      .attr("x", d => d.x0)
      .attr("y", d => d.y0)
      .attr("height", d => Math.max(1, d.y1 - d.y0))
      .attr("width",  d => d.x1 - d.x0)
      .attr("fill", d => {
        const type = d.name.split(":")[0];
        if (type === "struct") return structureColors(d.label);
        return "#cccccc";
      });

  node.append("text")
      .attr("x", d => d.x0 < width/2 ? d.x1 + 6 : d.x0 - 6)
      .attr("y", d => (d.y0 + d.y1)/2)
      .attr("dy", "0.35em")
      .attr("text-anchor", d => d.x0 < width/2 ? "start" : "end")
      .text(d => d.label);

  // 8) Filterable legend (by Structure Group)
  const legend = d3.select("#legend");
  let active = new Set(structureGroups);

  const items = legend.selectAll(".legend-item")
    .data(structureGroups)
    .enter().append("div")
      .attr("class","legend-item")
      .each(function(s){
        const item = d3.select(this);
        item.append("div").attr("class","legend-swatch")
            .style("background",structureColors(s));
        item.append("span").text(s);
      })
      .on("click", function(_, s){
        if (active.has(s)) active.delete(s); else active.add(s);
        d3.select(this).classed("disabled", !active.has(s));
        link.attr("display", d => active.has(d.struct) ? null : "none");
      });

  d3.select("#showAll").on("click", () => {
    active = new Set(structureGroups);
    items.classed("disabled", false);
    link.attr("display", null);
  });
  d3.select("#hideAll").on("click", () => {
    active.clear();
    items.classed("disabled", true);
    link.attr("display", "none");
  });

  // 9) Download SVG
  document.getElementById("downloadBtn").addEventListener("click", () => {
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"sankey.svg"});
    a.click();
  });
});
</script>
</body>
</html>
