<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Anode → Structure Group → Ion Type → Cathode (counts + multicolor ends)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<style>
  body{font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:20px;background:#fafafa;color:#111}
  h2{margin:0 0 10px}
  .toolbar{display:flex;gap:10px;align-items:center;margin:8px 0 14px}
  button{padding:6px 10px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer}
  svg{width:1200px;height:650px;background:#fff;border:1px solid #e5e7eb;border-radius:12px}
  .node rect{stroke:#333;opacity:.95}
  .node text{font:12px/1.1 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;dominant-baseline:middle}
  .link{fill:none;stroke-opacity:.35}
  .legend{position:relative;margin-top:10px;display:inline-grid;grid-template-columns:repeat(7,auto);gap:8px 14px;align-items:center}
  .sw{width:12px;height:12px;border:1px solid #111;border-radius:3px;display:inline-block}
</style>
</head>
<body>

<h2>Anode → Structure Group → Ion Type → Cathode</h2>
<div class="toolbar">
  <button id="download">Download SVG</button>
  <span>Bars/links scale with counts; Anode/Cathode show multi-color mix by Structure Group.</span>
</div>

<svg id="s"></svg>
<div class="legend" id="legend"></div>

<script>
const COL = {
  anode: "Anode",
  struct: "Structure Group",
  ion: "Ion Type",
  cath: "Cathode"
};

// Structure Group palette — match your existing colors if needed
const STRUCT_COLORS = new Map([
  ["Others",        "#9CA3AF"],
  ["Polymeric",     "#ef4444"],
  ["Argyrodite",    "#8b5cf6"],
  ["Halide",        "#10b981"],
  ["Amorphous",     "#f59e0b"],
  ["NASICON",       "#0ea5e9"],
  ["Anti-perovskite","#2563eb"]
]);
const structColor = k => STRUCT_COLORS.get(k) || "#9CA3AF";

d3.csv("data.csv").then(rows => {
  // Build node lists per layer
  const A = new Set(), S = new Set(), I = new Set(), C = new Set();
  rows.forEach(r => { A.add(r[COL.anode]); S.add(r[COL.struct]); I.add(r[COL.ion]); C.add(r[COL.cath]); });

  const nodes = [];
  const idOf = new Map();
  function pushLayer(prefix, set){
    for(const name of set){
      const label = String(name ?? "");
      const full = `${prefix}:${label}`;
      idOf.set(full, nodes.length);
      nodes.push({ name: full, label });
    }
  }
  pushLayer("anode",A); pushLayer("struct",S); pushLayer("ion",I); pushLayer("cath",C);

  const nid = (prefix,label)=> idOf.get(`${prefix}:${String(label??"")}`);

  // Accumulate links (each row counts as 1)
  const keyed = new Map(); // "src|dst|struct" -> link
  function acc(source,target,sg){
    const key = `${source}|${target}|${sg}`;
    const o = keyed.get(key) || {source,target,value:0,struct:sg};
    o.value += 1; keyed.set(key,o);
  }
  rows.forEach(r=>{
    const a=nid("anode",r[COL.anode]);
    const s=nid("struct",r[COL.struct]);
    const i=nid("ion",  r[COL.ion]);
    const c=nid("cath", r[COL.cath]);
    const sg=r[COL.struct];
    if(a!=null&&s!=null) acc(a,s,sg);
    if(s!=null&&i!=null) acc(s,i,sg);
    if(i!=null&&c!=null) acc(i,c,sg);
  });
  const links = Array.from(keyed.values());

  // Sankey layout (values drive widths/heights)
  const svg = d3.select("#s");
  const W = +svg.attr("width"), H = +svg.attr("height");
  const sankey = d3.sankey()
    .nodeId(d => d.name)
    .nodeWidth(8)
    .nodePadding(8)
    .nodeSort(null)
    .linkSort(null)
    .extent([[12,12],[W-12,H-12]]);

  const graph = sankey({
    nodes: nodes.map(d => ({...d})),
    links: links.map(d => ({...d}))
  });

  // ---- compositions for multi-color node fills (only ends) ----
  const outComp = new Map(); // node.index -> Map(struct -> sum)
  const inComp  = new Map();
  function addTo(map, idx, key, v){
    const m = map.get(idx) || new Map();
    m.set(key, (m.get(key)||0) + v);
    map.set(idx, m);
  }
  graph.links.forEach(l => { addTo(outComp,l.source.index,l.struct,l.value);
                             addTo(inComp, l.target.index,l.struct,l.value); });

  const minX0 = d3.min(graph.nodes, n => n.x0);
  const maxX0 = d3.max(graph.nodes, n => n.x0);

  const defs = svg.append("defs");
  function applyNodeGradient(node, entries, idPrefix){
    const id = `${idPrefix}-${node.index}`;
    const total = d3.sum(entries, d => d[1]) || 1;
    const grad = defs.append("linearGradient")
      .attr("id", id)
      .attr("gradientUnits", "userSpaceOnUse")
      .attr("x1", node.x0).attr("x2", node.x0)
      .attr("y1", node.y0).attr("y2", node.y1);
    let acc = 0;
    entries.forEach(([k,v])=>{
      const p0 = acc/total, p1 = (acc+v)/total, col = structColor(k);
      grad.append("stop").attr("offset", p0).attr("stop-color", col);
      grad.append("stop").attr("offset", p1).attr("stop-color", col);
      acc += v;
    });
    return `url(#${id})`;
  }

  // ---- links (thickness from layout -> counts) ----
  svg.append("g")
    .attr("fill","none")
    .selectAll("path")
    .data(graph.links)
    .join("path")
      .attr("class","link")
      .attr("d", d3.sankeyLinkHorizontal())
      .attr("stroke", d => structColor(d.struct))
      .attr("stroke-width", d => Math.max(1, d.width))
      .append("title")
        .text(d => `${graph.nodes[d.source.index].label} → ${graph.nodes[d.target.index].label}\n${d.struct}: ${d.value}`);

  // ---- nodes (multicolor only on left/right columns) ----
  const node = svg.append("g")
    .selectAll("g")
    .data(graph.nodes)
    .join("g")
      .attr("class","node");

  node.append("rect")
    .attr("x", d => d.x0)
    .attr("y", d => d.y0)
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => Math.max(2, d.y1 - d.y0))
    .attr("fill", function(d){
      if (d.x0 === minX0) { // Anode: outgoing mix
        const ent = Array.from(outComp.get(d.index) || []);
        if (ent.length) return applyNodeGradient(d, ent, "out");
      }
      if (d.x0 === maxX0) { // Cathode: incoming mix
        const ent = Array.from(inComp.get(d.index) || []);
        if (ent.length) return applyNodeGradient(d, ent, "in");
      }
      // Middle columns: solid color (Structure Group column gets its palette)
      if (d.name.startsWith("struct:")) return structColor(d.label);
      return "#cccccc";
    })
    .attr("stroke", "#333");

  node.append("text")
    .attr("x", d => d.x0 < W/2 ? d.x1 + 6 : d.x0 - 6)
    .attr("y", d => (d.y0 + d.y1)/2)
    .attr("text-anchor", d => d.x0 < W/2 ? "start" : "end")
    .text(d => d.label)
    .append("title")
      .text(d => d.label);

  // legend (Structure Group colors)
  const entries = Array.from(STRUCT_COLORS.entries());
  const L = d3.select("#legend");
  L.selectAll("div.item").data(entries).join("div")
    .attr("class","item")
    .html(d => `<span class="sw" style="background:${d[1]}"></span> ${d[0]}`);

  // download
  document.getElementById("download").addEventListener("click", ()=>{
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"sankey_counts_multicolor.svg"});
    a.click();
  });
});
</script>
</body>
</html>
