<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Heatmap — SSE × Cathode (Mean Cycle Life)</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; background:#fff; color:#111; margin:28px; }
  h2 { margin:0 0 8px; }
  p  { margin:0 0 14px; color:#444; }
  svg { background:#fff; border:1px solid #ccc; border-radius:6px; }
  .axis text { font-size:5px; fill:#111; }
  .axis .domain, .axis line { stroke:#ccc; }
  .cell { stroke:#fff; stroke-width:0.3; }
  .tooltip {
    position:absolute; background:#fff; border:1px solid #ccc; border-radius:5px;
    padding:6px 8px; font-size:11px; box-shadow:0 2px 6px rgba(0,0,0,.15); pointer-events:none;
  }
  .legendTitle { font-size:11px; fill:#111; }
  .status { font-size:12px; color:#333; margin-top:8px; }
</style>
</head>
<body>

<h2>Heatmap — SSE × Cathode (Color = Mean Cycle Life)</h2>
<p>y = <b>SSE Group</b>, x = <b>Cathode Group</b>, color = <b>Mean Cycle Life (cycles)</b></p>

<svg id="chart" width="940" height="650"></svg>
<div class="status" id="status">Loading…</div>
<div class="tooltip" id="tt" style="visibility:hidden"></div>

<script>
const CSV_FILE = "data.csv";

const margin = { top: 70, right: 20, bottom: 140, left: 200 },
      outerW = 940, outerH = 650,
      width  = outerW - margin.left - margin.right,
      height = outerH - margin.top - margin.bottom;

const svg = d3.select("#chart")
  .attr("width", outerW).attr("height", outerH)
  .append("g").attr("transform", `translate(${margin.left},${margin.top})`);

const tooltip = d3.select("#tt");

// helper: safe text & truncation for ticks
function safe(s){ return (s ?? "").replace(/\u00A0/g," ").trim(); }
function trunc(s, n){ s = safe(s); return s.length > n ? s.slice(0, n-1) + "…" : s; }

d3.csv(CSV_FILE).then(raw => {
  const need = ["SSE Group","Cathode Group","Mean Cycle Life (cycles)"];
  const cols = Object.keys(raw[0] || {});
  const missing = need.filter(c => !cols.includes(c));
  if (missing.length){
    d3.select("#status").text("Missing columns: " + missing.join(", "));
    return;
  }

  const data = raw.map(d => ({
    sse: safe(d["SSE Group"]),
    cath: safe(d["Cathode Group"]),
    meanCycle: +d["Mean Cycle Life (cycles)"],
    ion: safe(d["Ion Type"]),
    struct: safe(d["Structure Type"]),
    count: +d["Count"],
    example: safe(d["Example Formula (Chemical)"]),
    tC: safe(d["Mean Temperature (°C)"])
  })).filter(d => d.sse && d.cath && Number.isFinite(d.meanCycle) && d.meanCycle > 0);

  if (!data.length){
    d3.select("#status").text("No usable rows after parsing.");
    return;
  }
  d3.select("#status").text(`Rows: ${raw.length} | Plotted: ${data.length}`);

  const sseDomain  = Array.from(new Set(data.map(d => d.sse))).sort(d3.ascending);
  const cathDomain = Array.from(new Set(data.map(d => d.cath))).sort(d3.ascending);

  const x = d3.scaleBand().domain(cathDomain).range([0, width]).padding(0.03);
  const y = d3.scaleBand().domain(sseDomain).range([0, height]).padding(0.03);

  const maxCycle = d3.max(data, d => d.meanCycle) || 1;
  const color = d3.scaleSequential(d3.interpolateInferno).domain([0, maxCycle]);

  // X axis — tiny + rotated to avoid overlap
  svg.append("g")
    .attr("transform", `translate(0,${height})`)
    .attr("class","axis")
    .call(d3.axisBottom(x))
    .selectAll("text")
      .attr("transform","rotate(-50)")
      .attr("text-anchor","end")
      .attr("dx","-0.3em")
      .attr("dy","0.2em")
      .style("font-size","5px")
      .text(d => trunc(d, 12)); // shorten long labels

  // Y axis — tiny
  svg.append("g")
    .attr("class","axis")
    .call(d3.axisLeft(y))
    .selectAll("text")
      .style("font-size","5px")
      .text(d => trunc(d, 16));

  // Cells
  svg.selectAll(".cell")
    .data(data)
    .enter().append("rect")
      .attr("class","cell")
      .attr("x", d => x(d.cath))
      .attr("y", d => y(d.sse))
      .attr("width", x.bandwidth())
      .attr("height", y.bandwidth())
      .attr("fill", d => color(d.meanCycle))
      .on("mouseover", (ev, d) => {
        const tempPart = d.tC ? `<br><b>Mean Temp:</b> ${d.tC} °C` : "";
        tooltip.style("visibility","visible").html(
          `<b>SSE:</b> ${d.sse}<br><b>Cathode:</b> ${d.cath}` +
          `<br><b>Mean cycles:</b> ${d.meanCycle}` +
          `<br><b>Count:</b> ${d.count}` +
          `<br><b>Ion:</b> ${d.ion}` +
          `<br><b>Structure:</b> ${d.struct}` +
          `<br><b>Example:</b> ${d.example}` +
          tempPart
        );
      })
      .on("mousemove", (ev) => {
        tooltip.style("left",(ev.pageX+12)+"px").style("top",(ev.pageY-20)+"px");
      })
      .on("mouseout", () => tooltip.style("visibility","hidden"));

  // Legend (continuous)
  const legendW = 220, legendH = 10;
  const legend = svg.append("g").attr("transform", `translate(${(width-legendW)/2},${-38})`);
  const gradId = "gradInferno";
  const defs = svg.append("defs");
  const grad = defs.append("linearGradient").attr("id", gradId).attr("x1","0%").attr("x2","100%");
  for (let i=0;i<=12;i++){
    const t = i/12;
    grad.append("stop").attr("offset", `${t*100}%`).attr("stop-color", color(t*maxCycle));
  }
  legend.append("rect").attr("width", legendW).attr("height", legendH)
    .style("fill", `url(#${gradId})`).attr("stroke","#aaa");
  const legendScale = d3.scaleLinear().domain([0, maxCycle]).range([0, legendW]);
  legend.append("g").attr("transform", `translate(0,${legendH})`)
    .call(d3.axisBottom(legendScale).ticks(5).tickSize(3).tickFormat(d3.format(".1f")));
  legend.append("text").attr("class","legendTitle")
    .attr("x", legendW/2).attr("y",-7).attr("text-anchor","middle")
    .text("Mean Cycle Life (cycles)");
}).catch(err => {
  document.getElementById("status").textContent = "Error loading CSV (see console).";
  console.error(err);
});
</script>
</body>
</html>
