<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Heatmap — SSE × Cathode (Interactive Granularity)</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; background:#fff; color:#111; margin:28px; }
  h2 { margin:0 0 6px; }
  .controls { margin: 8px 0 12px; display:flex; gap:12px; align-items:center; }
  label { font-size:13px; color:#333; }
  select { font-size:13px; padding:4px 6px; }
  svg { background:#fff; border:1px solid #ccc; border-radius:6px; }
  .axis text { font-size:5px; fill:#111; }
  .axis .domain, .axis line { stroke:#ccc; }
  .cell { stroke:#fff; stroke-width:0.3; }
  .tooltip {
    position:absolute; background:#fff; border:1px solid #ccc; border-radius:5px;
    padding:6px 8px; font-size:11px; box-shadow:0 2px 6px rgba(0,0,0,.15); pointer-events:none;
  }
  .legendTitle { font-size:11px; fill:#111; }
  .status { font-size:12px; color:#333; margin-top:8px; }
</style>
</head>
<body>

<h2>Heatmap — SSE × Cathode (Color = Mean Cycle Life)</h2>
<div class="controls">
  <label>Granularity:</label>
  <select id="granSSE">
    <option value="family" selected>SSE: Family</option>
    <option value="detailed">SSE: Detailed (Structure Type)</option>
  </select>
  <select id="granCath">
    <option value="family" selected>Cathode: Family</option>
    <option value="detailed">Cathode: Detailed (tokens)</option>
  </select>
</div>
<p style="margin-top:-4px;color:#444;">Data: <code>data_cycles_converted.csv</code> (RT-only/unspecified). Cells show mean cycle life by chosen granularity.</p>

<svg id="chart" width="1080" height="760"></svg>
<div class="status" id="status">Loading…</div>
<div class="tooltip" id="tt" style="visibility:hidden"></div>

<script>
const CSV_FILE = "data_cycles_converted.csv";

const margin = { top: 80, right: 20, bottom: 170, left: 230 },
      outerW = 1080, outerH = 760,
      width  = outerW - margin.left - margin.right,
      height = outerH - margin.top - margin.bottom;

const svgRoot = d3.select("#chart").attr("width", outerW).attr("height", outerH);
const svg = svgRoot.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
const tooltip = d3.select("#tt");

function safe(s){ return (s ?? "").replace(/\u00A0/g," ").trim(); }
function trunc(s, n){ s = safe(s); return s.length > n ? s.slice(0, n-1) + "…" : s; }

// --- family mappers (regex-based, like our Python step) ---
function normToken(s){
  return safe(s).toLowerCase().replace(/[^\w.+\- ]+/g," ").replace(/\s+/g," ").trim();
}
function mapSSEFamily(structure, formula){
  const t = normToken((structure||"") + " | " + (formula||""));
  const checks = [
    [/argyrodite|li6ps5|lpsc|lpscl|li6ps5cl|li6ps5br/, "Argyrodite"],
    [/lgps|li10gep2s12|li9\.54si1\.74p1\.44s11\.7|li9\.6p3s12|li10p3s12/, "LGPS"],
    [/garnet|llzo|li7la3zr2o12/, "Garnet"],
    [/halide|li2zrcl6|li3ycl6|li3incl6|oxyhalide/, "Halide"],
    [/nasicon|latp|lagp|na3zr2si2po12|li1\.3al0\.3ti1\.65zr0\.05|li1\.3al0\.3ti1\.7/, "NASICON"],
    [/polymer|peo|pan|pvdf|gel|spe|cse|composite/, "Polymer"],
    [/glass|amorphous/, "Amorphous / Glass"],
    [/sulfide|thiophosphate|thio[- ]?lisicon|li3ps4|li5ps4cl|li5\.5ps4\.5cl1\.5|lsps|lps/, "Sulfide"],
    [/li3n|nitride/, "Nitride"],
    [/anti[- ]?perovskite|li2ohcl/, "Anti-perovskite"],
  ];
  for (const [re, label] of checks){ if (re.test(t)) return label; }
  return "Other";
}
function mapCathFamily(cath){
  const t = normToken(cath);
  const checks = [
    [/\bncm\b|ncm\d+|l?ini[0-9.]*co[0-9.]*mn[0-9.]*o?2?/, "NCM"],
    [/\blco\b|lithium cobalt|li?coo2/, "LCO"],
    [/\blfp\b|lifepo4/, "LFP"],
    [/\bnca\b|l?ini[0-9.]*co[0-9.]*al[0-9.]*o?2?/, "NCA"],
    [/\blmo\b|limn2o4|manganese oxide/, "LMO"],
    [/\blnmo\b|lini0\.5mn1\.5o4|ni\-mn spinel/, "LNMO"],
    [/\bnasicon\b|na3v2|ntp|nat|nvp|na3v2po4/, "NASICON"],
    [/sulfur|\b s\b|li\-s/, "S (Sulfur)"],
    [/polymer|composite/, "Polymer / Composite"],
  ];
  for (const [re, label] of checks){ if (re.test(t)) return label; }
  return "Other";
}

// --- split helpers for "detailed" mode ---
const SPLIT = /[+\/,&;]+/;
function splitTokens(s){
  if (!s) return [];
  return s.split(SPLIT).map(x => safe(x)).filter(Boolean);
}
function cathDetailedTokens(cath){
  // Produce specific tokens: keep recognizable families like NCM811 as-is
  const toks = splitTokens(cath);
  return toks.length ? toks : ["Other"];
}
function sseDetailedTokens(structure){
  const toks = splitTokens(structure);
  return toks.length ? toks : ["Other"];
}

// ---- aggregation (compute mean by chosen keys) ----
function aggregate(raw, modeSSE, modeCath){
  // expand rows into all combinations of SSE×Cath
  const expanded = [];
  raw.forEach(r => {
    const cycles = +r.cycles;
    if (!Number.isFinite(cycles) || cycles<=0) return;

    const sseTokens = (modeSSE === "family")
      ? [mapSSEFamily(r.structure, r.formula)]
      : sseDetailedTokens(r.structure);

    const cathTokens = (modeCath === "family")
      ? cathDetailedTokens(r.cathode).map(mapCathFamily) // still map to family names
      : cathDetailedTokens(r.cathode);                   // keep specific tokens

    sseTokens.forEach(sse => {
      cathTokens.forEach(ca => {
        expanded.push({
          sse, cath: ca,
          cycles
        });
      });
    });
  });

  // group to mean
  const byKey = d3.rollup(
    expanded,
    v => d3.mean(v, d => d.cycles),
    d => d.sse, d => d.cath
  );

  // flatten
  const rows = [];
  for (const [sse, inner] of byKey.entries()){
    for (const [cath, mean] of inner.entries()){
      rows.push({sse, cath, mean});
    }
  }
  return rows;
}

// ---- draw function ----
function draw(dataRows){
  svg.selectAll("*").remove();

  const sseDomain = Array.from(new Set(dataRows.map(d => d.sse))).sort(d3.ascending);
  const cathDomain = Array.from(new Set(dataRows.map(d => d.cath))).sort(d3.ascending);

  const x = d3.scaleBand().domain(cathDomain).range([0, width]).padding(0.03);
  const y = d3.scaleBand().domain(sseDomain).range([0, height]).padding(0.03);
  const maxCycle = d3.max(dataRows, d => d.mean) || 1;
  const color = d3.scaleSequential(d3.interpolateInferno).domain([0, maxCycle]);

  // axes
  svg.append("g")
    .attr("transform", `translate(0,${height})`).attr("class","axis")
    .call(d3.axisBottom(x))
    .selectAll("text")
      .attr("transform","rotate(-50)")
      .attr("text-anchor","end")
      .attr("dx","-0.3em").attr("dy","0.2em")
      .style("font-size","5px")
      .text(d => trunc(d, 12));

  svg.append("g").attr("class","axis")
    .call(d3.axisLeft(y))
    .selectAll("text").style("font-size","5px").text(d => trunc(d, 16));

  // cells
  svg.selectAll(".cell")
    .data(dataRows)
    .enter().append("rect")
      .attr("class","cell")
      .attr("x", d => x(d.cath)).attr("y", d => y(d.sse))
      .attr("width", x.bandwidth()).attr("height", y.bandwidth())
      .attr("fill", d => color(d.mean))
      .on("mouseover", (ev,d) => {
        tooltip.style("visibility","visible").html(
          `<b>SSE:</b> ${d.sse}<br><b>Cathode:</b> ${d.cath}<br><b>Mean cycles:</b> ${d.mean.toFixed(1)}`
        );
      })
      .on("mousemove", ev => tooltip.style("left",(ev.pageX+12)+"px").style("top",(ev.pageY-20)+"px"))
      .on("mouseout", () => tooltip.style("visibility","hidden"));

  // legend
  const legendW = 260, legendH = 10;
  const legend = svg.append("g").attr("transform", `translate(${(width-legendW)/2},${-40})`);
  const gradId = "gradInferno";
  const defs = svgRoot.append("defs");
  const grad = defs.append("linearGradient").attr("id", gradId).attr("x1","0%").attr("x2","100%");
  for (let i=0;i<=12;i++){ const t=i/12; grad.append("stop").attr("offset", `${t*100}%`).attr("stop-color", color(t*maxCycle)); }
  legend.append("rect").attr("width", legendW).attr("height", legendH).style("fill", `url(#${gradId})`).attr("stroke","#aaa");
  const legendScale = d3.scaleLinear().domain([0, maxCycle]).range([0, legendW]);
  legend.append("g").attr("transform", `translate(0,${legendH})`)
    .call(d3.axisBottom(legendScale).ticks(5).tickSize(3).tickFormat(d3.format(".1f")));
  legend.append("text").attr("class","legendTitle").attr("x", legendW/2).attr("y",-7).attr("text-anchor","middle")
    .text("Mean Cycle Life (cycles)");

  d3.select("#status").text(`Cells: ${dataRows.length} | SSEs: ${sseDomain.length} | Cathodes: ${cathDomain.length} | Max mean: ${maxCycle.toFixed(1)}`);
}

// ---- load raw, then wire up controls ----
d3.csv(CSV_FILE).then(raw => {
  // Expect these columns from your converted file
  const rows = raw.map(d => ({
    formula  : safe(d["Formula (Chemical)"]),
    ion      : safe(d["Ion Type"]),
    structure: safe(d["Structure Type"]),
    cathode  : safe(d["Cathode"]),
    cycles   : +d["Cycle Life (cycles)"],
    tempC    : safe(d["Temperature (°C)"])
  })).filter(r => Number.isFinite(r.cycles) && r.cycles>0);

  const gSSE = document.getElementById("granSSE");
  const gCath= document.getElementById("granCath");

  function recompute(){
    const modeSSE  = gSSE.value;     // "family" | "detailed"
    const modeCath = gCath.value;    // "family" | "detailed"
    const agg = aggregate(rows, modeSSE, modeCath);
    draw(agg);
  }
  gSSE.addEventListener("change", recompute);
  gCath.addEventListener("change", recompute);

  recompute(); // initial draw
}).catch(err => {
  document.getElementById("status").textContent = "Error loading data_cycles_converted.csv";
  console.error(err);
});
</script>
</body>
</html>
