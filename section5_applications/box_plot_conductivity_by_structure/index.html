<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Box plot — log10(σ) by Structure Group</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body{font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:24px;background:#fafafa;color:#111}
  h2{margin:0 0 10px}
  .toolbar{display:flex;gap:10px;align-items:center;margin:8px 0 14px}
  .note{font-size:12px;color:#64748b}
  svg{width:1080px;height:680px;background:#fff;border:1px solid #e5e7eb;border-radius:12px}
  .grid line{stroke:#eef2f7}
  .axis-label{font-size:14px;font-weight:600;fill:#111}

  .box{fill:#9aa3b2;fill-opacity:.35;stroke:#1f2937;stroke-width:1}
  .whisker{stroke:#1f2937;stroke-width:1.2}
  .median-line{stroke:#e43;stroke-width:2}

  .dot{stroke:#111827;stroke-width:.35px;opacity:.85}
  .legend{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:8px 0 0}
  .legend-item{display:flex;align-items:center;gap:6px;padding:2px 6px;border:1px solid #e5e7eb;border-radius:6px;cursor:pointer;user-select:none}
  .legend-item.disabled{opacity:.35;text-decoration:line-through}
  .swatch{width:12px;height:12px;border-radius:3px;border:1px solid #111}
  button{padding:6px 10px;border-radius:8px;border:1px solid #d1d5db;background:#fff;cursor:pointer}

  /* Mean marker */
  .mean-dot{ fill:#2563eb; stroke:#fff; stroke-width:1.5px; }
  .mean-label{ font: 11px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; fill:#111; text-anchor:middle; }
</style>
</head>
<body>

<h2>Box plot — log<sub>10</sub>(σ) by Structure Group</h2>
<div class="toolbar">
  <button id="download">Download SVG</button>
  <span class="note">Same data/axis as violin; deterministic per-point jitter; blue dots show the mean σ per group.</span>
</div>
<svg id="chart"></svg>
<div class="legend" id="legend"></div>

<script>
// ====== YOUR COLUMNS ======
const COL = {
  struct: "Structure Group",
  ion:    "Ion Type",
  sigma:  "Conductivity σ (S·cm⁻¹) / Temp (°C) normalized"
};

// ====== Deterministic jitter (stable per point) ======
function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=(h<<13)|(h>>>19);}return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return (h^=h>>>16)>>>0;};}
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967295;};}
function stableJitter(key,half){const seed=xmur3(key)();const rand=mulberry32(seed);return (rand()*2-1)*half;}

const svg = d3.select("#chart");
const W = +svg.attr("width"), H = +svg.attr("height");
const margin = {top: 40, right: 24, bottom: 86, left: 84};
const innerW = W - margin.left - margin.right;
const innerH = H - margin.top - margin.bottom;
const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

const fmtSci = d3.format(".2e"); // for σ labels
const fmtPow  = x => `10^${d3.format(".2f")(x)}`;

d3.csv("data.csv").then(rows => {
  // Build data from normalized σ; compute log10(σ)
  const data = rows.map(d => {
    const group = (d[COL.struct] ?? "Others").trim() || "Others";
    const ion   = (d[COL.ion]   ?? "Unknown").trim() || "Unknown";
    const s     = +d[COL.sigma];
    const logv  = (Number.isFinite(s) && s > 0) ? Math.log10(s) : null;
    return {group, ion, logv, raw: s};
  }).filter(d => d.logv !== null);

  if (!data.length){
    console.error("No data — check the column names and positive σ values.");
    return;
  }

  const groups = Array.from(new Set(data.map(d => d.group)));
  const ions   = Array.from(new Set(data.map(d => d.ion)));

  // Scales
  const x = d3.scaleBand().domain(groups).range([0, innerW]).padding(0.18);
  const y = d3.scaleLinear().domain(d3.extent(data, d => d.logv)).nice().range([innerH, 0]);

  // Axes + grid
  g.append("g").attr("transform", `translate(0,${innerH})`)
    .call(d3.axisBottom(x))
    .selectAll("text").attr("transform","rotate(-28)").style("text-anchor","end");

  g.append("g").call(d3.axisLeft(y).ticks(10).tickFormat(v => `10^${v}`));
  g.append("g").attr("class","grid")
    .call(d3.axisLeft(y).ticks(10).tickSize(-innerW).tickFormat(""));

  g.append("text").attr("class","axis-label")
    .attr("x", innerW/2).attr("y", innerH+64).attr("text-anchor","middle")
    .text("Structure Group");
  g.append("text").attr("class","axis-label")
    .attr("x", -innerH/2).attr("y", -64).attr("transform","rotate(-90)")
    .attr("text-anchor","middle").text("log10(σ) (S·cm⁻¹)");

  // Box stats (Tukey)
  function boxStats(values){
    const v = values.slice().sort(d3.ascending);
    const q1 = d3.quantileSorted(v, 0.25);
    const q2 = d3.quantileSorted(v, 0.50);
    const q3 = d3.quantileSorted(v, 0.75);
    const iqr = q3 - q1;
    const low  = Math.max(d3.min(v), q1 - 1.5 * iqr);
    const high = Math.min(d3.max(v), q3 + 1.5 * iqr);
    return { q1, q2, q3, low, high };
  }

  // Group values and compute stats + means
  const grouped = d3.group(data, d => d.group);
  const stats = groups.map(gp => {
    const valsLog = (grouped.get(gp) || []).map(d => d.logv);
    const valsLin = valsLog.map(v => Math.pow(10, v));          // linear σ for mean
    const s = valsLog.length ? boxStats(valsLog) : null;
    const meanLinear = d3.mean(valsLin);
    const meanLog = meanLinear > 0 ? Math.log10(meanLinear) : null;
    return { group: gp, n: valsLog.length, ...s, meanLinear, meanLog };
  }).filter(d => d.n > 0);

  // Draw boxes
  const boxWidth = x.bandwidth()*0.5;
  const boxLayer = g.append("g");
  const whiskerLayer = g.append("g");

  boxLayer.selectAll("rect.box")
    .data(stats)
    .join("rect")
      .attr("class","box")
      .attr("x", d => x(d.group) + (x.bandwidth()-boxWidth)/2)
      .attr("width", boxWidth)
      .attr("y", d => y(d.q3))
      .attr("height", d => Math.max(1, y(d.q1) - y(d.q3)));

  // Whiskers + median
  whiskerLayer.selectAll("g.whisk")
    .data(stats)
    .join("g")
      .attr("class","whisk")
      .each(function(d){
        const cx = x(d.group) + x.bandwidth()/2;
        const bw = boxWidth;
        d3.select(this).append("line") // upper whisker
          .attr("class","whisker")
          .attr("x1",cx).attr("x2",cx).attr("y1",y(d.high)).attr("y2",y(d.q3));
        d3.select(this).append("line") // lower whisker
          .attr("class","whisker")
          .attr("x1",cx).attr("x2",cx).attr("y1",y(d.low)).attr("y2",y(d.q1));
        d3.select(this).append("line") // cap high
          .attr("class","whisker")
          .attr("x1",cx-bw/2).attr("x2",cx+bw/2).attr("y1",y(d.high)).attr("y2",y(d.high));
        d3.select(this).append("line") // cap low
          .attr("class","whisker")
          .attr("x1",cx-bw/2).attr("x2",cx+bw/2).attr("y1",y(d.low)).attr("y2",y(d.low));
        d3.select(this).append("line") // median
          .attr("class","median-line")
          .attr("x1",cx-bw/2).attr("x2",cx+bw/2).attr("y1",y(d.q2)).attr("y2",y(d.q2));
      });

  // Mean marker (blue dot) — mean computed in linear σ, positioned at log10(mean σ)
  const meanLayer = g.append("g");
  meanLayer.selectAll("circle.mean-dot")
    .data(stats)
    .join("circle")
      .attr("class","mean-dot")
      .attr("r", 4)
      .attr("cx", d => x(d.group) + x.bandwidth()/2)
      .attr("cy", d => y(d.meanLog))
      .append("title")
        .text(d => `Mean σ: ${fmtSci(d.meanLinear)} S·cm⁻¹ (log10=${d3.format(".2f")(d.meanLog)})`);

  // Optional text label above the dot — comment out if you don’t want it
  meanLayer.selectAll("text.mean-label")
    .data(stats)
    .join("text")
      .attr("class","mean-label")
      .attr("x", d => x(d.group) + x.bandwidth()/2)
      .attr("y", d => y(d.meanLog) - 6)
      .text(d => fmtSci(d.meanLinear));

  // Dots with deterministic jitter (same as violin)
  const color = d3.scaleOrdinal().domain(ions).range(d3.schemeTableau10);
  const dotHalfWidth = x.bandwidth()*0.45;

  const pts = g.append("g").selectAll("circle.dot")
    .data(data, d => `${d.group}|${d.ion}|${d.logv}|${d.raw}`)
    .join("circle")
      .attr("class","dot")
      .attr("r", 3)
      .attr("cy", d => y(d.logv))
      .attr("cx", d => {
        const c = x(d.group) + x.bandwidth()/2;
        const key = `${d.group}|${d.ion}|${d.raw}|${d.logv}`;
        return c + stableJitter(key, dotHalfWidth);
      })
      .attr("fill", d => color(d.ion));

  // Legend filter (positions remain the same)
  const legend = d3.select("#legend");
  let active = new Set(ions);
  const items = legend.selectAll(".legend-item").data(ions).join("div")
    .attr("class","legend-item")
    .on("click", function(_, ion){
      if (active.has(ion)) active.delete(ion); else active.add(ion);
      d3.select(this).classed("disabled", !active.has(ion));
      pts.attr("display", d => active.has(d.ion) ? null : "none");
    });
  items.append("div").attr("class","swatch").style("background", d => color(d));
  items.append("span").text(d => d);

  // Download SVG
  document.getElementById("download").addEventListener("click", () => {
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"boxplot_log10sigma_mean.svg"});
    a.click();
  });
});
</script>
</body>
</html>
