<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Conductivity by Structure Group — Box Plot</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body{font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:24px;background:#fafafa;color:#111}
  h2{margin:0 0 10px}
  .toolbar{display:flex;gap:10px;align-items:center;margin:8px 0 14px}
  .note{font-size:12px;color:#64748b}
  svg{width:980px;height:640px;background:#fff;border:1px solid #e5e7eb;border-radius:12px}
  .grid line{stroke:#eef2f7}
  .axis-label{font-size:14px;font-weight:600;fill:#111}

  .box{fill:#cbd5e1;fill-opacity:.55;stroke:#1f2937;stroke-width:1}
  .whisker{stroke:#1f2937;stroke-width:1.2}
  .median-line{stroke:#e11d48;stroke-width:2}

  .dot{stroke:#111827;stroke-width:.35px;opacity:.9}
  .legend{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:8px 0 0}
  .legend-item{display:flex;align-items:center;gap:6px;padding:2px 6px;border:1px solid #e5e7eb;border-radius:6px;cursor:pointer;user-select:none}
  .legend-item.disabled{opacity:.35;text-decoration:line-through}
  .swatch{width:12px;height:12px;border-radius:3px;border:1px solid #111}
  button{padding:6px 10px;border-radius:8px;border:1px solid #d1d5db;background:#fff;cursor:pointer}

  /* Mean marker (blue dot) */
  .mean-dot{ fill:#2563eb; stroke:#fff; stroke-width:1.5px; }

  /* Median label with halo (like your violin) */
  .label-halo{fill:#111;font-weight:700;font-size:12px;paint-order:stroke;stroke:#fff;stroke-width:4px;stroke-linejoin:round}
  .label-top{fill:#111;font-weight:700;font-size:12px}
</style>
</head>
<body>

<h2>Conductivity by Structure Group — Box Plot</h2>
<div class="toolbar">
  <button id="download">Download SVG</button>
  <span class="note">Red line = median (label shows median σ); blue dot = mean σ. Points are filterable and don’t move.</span>
</div>
<svg id="chart"></svg>
<div class="legend" id="legend"></div>

<script>
// ====== Columns (match your CSV) ======
const COL = {
  struct: "Structure Group",
  ion:    "Ion Type",
  sigma:  "Conductivity σ (S·cm⁻¹) / Temp (°C) normalized"
};

// ====== Deterministic jitter (stable per point) ======
function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=(h<<13)|(h>>>19);}return function(){h=Math.imul(h^(h>>>16),2246822507);h=Math.imul(h^(h>>>13),3266489909);return (h^=h>>>16)>>>0;};}
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967295;};}
function stableJitter(key,half){const seed=xmur3(key)();const rand=mulberry32(seed);return (rand()*2-1)*half;}

const svg = d3.select("#chart");
svg.attr("width", 980).attr("height", 640); // ensure attributes exist
const W = +svg.attr("width"), H = +svg.attr("height");
const margin = {top: 40, right: 24, bottom: 86, left: 84};
const innerW = W - margin.left - margin.right;
const innerH = H - margin.top - margin.bottom;
const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

const fmtSci  = d3.format(".3~e");
const fmtFix4 = d3.format(".4f");

d3.csv("data.csv").then(rows => {
  // Build data -> log10(σ)
  const data = rows.map(d => {
    const group = (d[COL.struct] ?? "Others").trim() || "Others";
    const ion   = (d[COL.ion]   ?? "Unknown").trim() || "Unknown";
    const s     = +d[COL.sigma];
    const logv  = (Number.isFinite(s) && s > 0) ? Math.log10(s) : null;
    return {group, ion, logv, raw: s};
  }).filter(d => d.logv !== null);

  if (!data.length){ console.error("No data — check columns and σ values > 0."); return; }

  const groups = Array.from(new Set(data.map(d => d.group)));
  const ions   = Array.from(new Set(data.map(d => d.ion)));

  // Scales
  const x = d3.scaleBand().domain(groups).range([0, innerW]).padding(0.18);
  const y = d3.scaleLinear().domain(d3.extent(data, d => d.logv)).nice().range([innerH, 0]);

  // Axes + grid
  g.append("g").attr("transform", `translate(0,${innerH})`)
    .call(d3.axisBottom(x))
    .selectAll("text").attr("transform","rotate(-28)").style("text-anchor","end");
  g.append("g").call(d3.axisLeft(y).ticks(10).tickFormat(v => `10^${v}`));
  g.append("g").attr("class","grid").call(d3.axisLeft(y).ticks(10).tickSize(-innerW).tickFormat(""));
  g.append("text").attr("class","axis-label").attr("x", innerW/2).attr("y", innerH+64).attr("text-anchor","middle").text("Structure Group");
  g.append("text").attr("class","axis-label").attr("x", -innerH/2).attr("y", -64).attr("transform","rotate(-90)").attr("text-anchor","middle").text("log10(σ) (S·cm⁻¹)");

  // Box stats (Tukey)
  function boxStats(values){
    const v = values.slice().sort(d3.ascending);
    const q1 = d3.quantileSorted(v, 0.25);
    const q2 = d3.quantileSorted(v, 0.50); // median (log10)
    const q3 = d3.quantileSorted(v, 0.75);
    const iqr = q3 - q1;
    const low  = Math.max(d3.min(v), q1 - 1.5 * iqr);
    const high = Math.min(d3.max(v), q3 + 1.5 * iqr);
    return { q1, q2, q3, low, high };
  }

  // Group & compute stats + mean (linear)
  const grouped = d3.group(data, d => d.group);
  const stats = groups.map(gp => {
    const valsLog = (grouped.get(gp) || []).map(d => d.logv);
    if (!valsLog.length) return null;
    const s = boxStats(valsLog);
    const meanLinear = d3.mean(valsLog.map(v => Math.pow(10, v)));
    const meanLog = meanLinear > 0 ? Math.log10(meanLinear) : null;
    return { group: gp, n: valsLog.length, ...s, meanLinear, meanLog };
  }).filter(Boolean);

  // Draw boxes/whiskers
  const boxWidth = x.bandwidth()*0.5;
  const boxLayer = g.append("g"), whiskerLayer = g.append("g"), medLayer = g.append("g");

  boxLayer.selectAll("rect.box").data(stats).join("rect")
    .attr("class","box")
    .attr("x", d => x(d.group) + (x.bandwidth()-boxWidth)/2)
    .attr("width", boxWidth)
    .attr("y", d => y(d.q3))
    .attr("height", d => Math.max(1, y(d.q1) - y(d.q3)));

  whiskerLayer.selectAll("g.whisk").data(stats).join("g")
    .attr("class","whisk")
    .each(function(d){
      const cx = x(d.group) + x.bandwidth()/2;
      const bw = boxWidth;
      d3.select(this).append("line").attr("class","whisker")
        .attr("x1",cx).attr("x2",cx).attr("y1",y(d.high)).attr("y2",y(d.q3));
      d3.select(this).append("line").attr("class","whisker")
        .attr("x1",cx).attr("x2",cx).attr("y1",y(d.low)).attr("y2",y(d.q1));
      d3.select(this).append("line").attr("class","whisker")
        .attr("x1",cx-bw/2).attr("x2",cx+bw/2).attr("y1",y(d.high)).attr("y2",y(d.high));
      d3.select(this).append("line").attr("class","whisker")
        .attr("x1",cx-bw/2).attr("x2",cx+bw/2).attr("y1",y(d.low)).attr("y2",y(d.low));

      // median line
      d3.select(this).append("line").attr("class","median-line")
        .attr("x1",cx-bw/2).attr("x2",cx+bw/2).attr("y1",y(d.q2)).attr("y2",y(d.q2));

      // ---- Median label to the RIGHT of the red line (linear σ), like violin ----
      const medianLinear = Math.pow(10, d.q2);
      const label = medianLinear < 0.001 ? fmtSci(medianLinear) : fmtFix4(medianLinear);
      medLayer.append("text").attr("class","label-halo")
        .attr("x", cx + bw/2 + 6).attr("y", y(d.q2) + 3).attr("text-anchor","start").text(label);
      medLayer.append("text").attr("class","label-top")
        .attr("x", cx + bw/2 + 6).attr("y", y(d.q2) + 3).attr("text-anchor","start").text(label);
    });

  // Mean marker (blue dot)
  g.append("g").selectAll("circle.mean-dot").data(stats).join("circle")
    .attr("class","mean-dot").attr("r",4)
    .attr("cx", d => x(d.group) + x.bandwidth()/2)
    .attr("cy", d => y(d.meanLog))
    .append("title").text(d => `Mean σ: ${fmtSci(d.meanLinear)} S·cm⁻¹`);

  // Points (deterministic jitter)
  const color = d3.scaleOrdinal().domain(ions).range(d3.schemeTableau10);
  const dotHalfWidth = x.bandwidth()*0.45;
  const pts = g.append("g").selectAll("circle.dot")
    .data(data, d => `${d.group}|${d.ion}|${d.logv}|${d.raw}`)
    .join("circle")
      .attr("class","dot").attr("r",3)
      .attr("cy", d => y(d.logv))
      .attr("cx", d => {
        const c = x(d.group) + x.bandwidth()/2;
        const key = `${d.group}|${d.ion}|${d.raw}|${d.logv}`;
        return c + stableJitter(key, dotHalfWidth);
      })
      .attr("fill", d => color(d.ion));

  // Legend filtering (points only; boxes stay as context)
  const legend = d3.select("#legend");
  let active = new Set(ions);
  const items = legend.selectAll(".legend-item").data(ions).join("div")
    .attr("class","legend-item")
    .on("click", function(_, ion){
      if (active.has(ion)) active.delete(ion); else active.add(ion);
      d3.select(this).classed("disabled", !active.has(ion));
      pts.attr("display", d => active.has(d.ion) ? null : "none");
    });
  items.append("div").attr("class","swatch").style("background", d => color(d));
  items.append("span").text(d => d);

  // Download SVG
  document.getElementById("download").addEventListener("click", () => {
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"boxplot_log10sigma_median_right_label.svg"});
    a.click();
  });
});
</script>
</body>
</html>
