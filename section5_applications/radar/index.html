<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Radar</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root{
    --bg:#f7f7fb;
    --panel:#fff;
    --grid:#e7e9ef;
    --axis:#b4bac8;
    --text:#101828;
    --muted:#6b7280;
  }
  body{
    margin:0;background:var(--bg);color:var(--text);
    font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
  }
  .wrap{max-width:1100px;margin:28px auto;padding:0 18px;}
  h1{margin:0 0 14px;font-size:20px;font-weight:600;}
  .card{
    background:var(--panel);border-radius:16px;padding:18px;
    box-shadow:0 10px 30px rgba(12,17,29,0.08);
    display:flex;flex-direction:column;align-items:center;
  }
  .gridCircle{fill:none;stroke:var(--grid)}
  .axis line{stroke:var(--axis);stroke-width:1}
  .axisLabel{fill:#374151;font-size:12px;font-weight:500}
  .levelLabel{
    font-size:12px;font-weight:700;fill:#0f172a;
    paint-order:stroke;stroke:#fff;stroke-width:3px;stroke-linejoin:round;
    text-shadow:0 1px 2px rgba(255,255,255,0.9);
  }
  .value-label{
    font-size:11px;fill:#111827;
    paint-order:stroke;stroke:#fff;stroke-width:3px;stroke-linejoin:round;
  }
  /* Horizontal legend */
  #legend{
    display:flex;flex-wrap:wrap;justify-content:center;align-items:center;
    gap:16px;margin-top:18px;
  }
  #legend .item{display:flex;align-items:center;gap:6px;font-size:13px}
  .swatch{width:14px;height:14px;border-radius:3px;display:inline-block}
</style>
</head>
<body>
<div class="wrap">
  <h1>Radar Chart</h1>
  <div class="card">
    <svg id="radar" width="900" height="640" role="img" aria-label="Radar chart"></svg>
    <div id="legend"></div>
  </div>
</div>

<script>
const CSV_PATH = "data.csv";
const svg = d3.select("#radar");
const legend = d3.select("#legend");

const W = +svg.attr("width"), H = +svg.attr("height");
const margin = {top:60,right:70,bottom:60,left:70};
const cx = W/2, cy = H/2;
const radius = Math.min(W, H)/2 - Math.max(margin.left, margin.top);

// ===== Chart labeling config =====
const levelTicks = [0.2, 0.4, 0.6, 0.8, 1.0]; // ring values to draw
const levelLabelAngleDeg = -120;               // place tick numbers along this direction (top-left)
const axisLabelOffset = 20;                    // column names closer to the ring

// ===== Overlap control (labels stay on the ring; we slide them along the ring) =====
const LABEL_JITTER_DEG = 2;       // base per-series spread (try 1–3°)
const NEAR_EPS_FRAC   = 0.01;     // values within 1% of max are “near duplicates”
const CLUSTER_STEP_DEG = 0.6;     // extra per-item spread within a near-duplicate cluster

d3.csv(CSV_PATH).then(raw => {
  const cols = raw.columns ?? Object.keys(raw[0]);
  const groupKey = cols[0];

  // === MINIMAL CHANGE ONLY: explicit categories list with the new "Cycle Life" axis ===
  const categories = ["log₁₀(σ)", "1/Ea", "log₁₀(N)", "Retention %", "Synthesis Simplicity", "Cycle Life"];

  // numeric coercion
  raw.forEach(r => categories.forEach(c => r[c] = +r[c]));

  const dataMax = d3.max(raw, r => d3.max(categories, c => r[c]));
  const ticksMax = d3.max(levelTicks);
  const maxVal = Math.max(dataMax || 0, ticksMax || 0);

  const rScale = d3.scaleLinear().domain([0, maxVal]).range([0, radius]);
  const angleSlice = (Math.PI*2)/categories.length;
  const color = d3.scaleOrdinal(d3.schemeTableau10);
  const fmtValue = d3.format(",.2~f");

  // ---------- GRID ----------
  const gGrid = svg.append("g");
  levelTicks.forEach(t => {
    gGrid.append("circle")
      .attr("class","gridCircle")
      .attr("cx",cx).attr("cy",cy).attr("r",rScale(t));
  });

  // level labels at marked angle
  const a = levelLabelAngleDeg * Math.PI / 180;
  levelTicks.forEach(t => {
    const r = rScale(t);
    const lx = cx + Math.cos(a) * r;
    const ly = cy + Math.sin(a) * r;
    gGrid.append("text")
      .attr("class","levelLabel")
      .attr("x", lx).attr("y", ly)
      .attr("text-anchor",
        Math.cos(a) > 0.35 ? "start" : (Math.cos(a) < -0.35 ? "end" : "middle"))
      .attr("dominant-baseline","middle")
      .text(d3.format(",")(t));
  });

  // ---------- AXES ----------
  const gAxis = svg.append("g").attr("class","axis");
  categories.forEach((cat, i) => {
    const ang = angleSlice*i - Math.PI/2;
    const x = cx + Math.cos(ang)*radius;
    const y = cy + Math.sin(ang)*radius;
    gAxis.append("line").attr("x1",cx).attr("y1",cy).attr("x2",x).attr("y2",y);

    const lx = cx + Math.cos(ang)*(radius + axisLabelOffset);
    const ly = cy + Math.sin(ang)*(radius + axisLabelOffset);
    gAxis.append("text")
      .attr("class","axisLabel")
      .attr("x", lx).attr("y", ly)
      .attr("text-anchor",
        Math.abs(Math.cos(ang)) < 0.35 ? "middle" : (Math.cos(ang) > 0 ? "start" : "end"))
      .attr("dy",
        Math.abs(Math.sin(ang)) < 0.35 ? "0.35em" : (Math.sin(ang) > 0 ? "0.9em" : "-0.4em"))
      .text(cat);
  });

  // ---------- PRECOMPUTE extra jitter for near-duplicate values per axis ----------
  const NEAR_EPS = (maxVal || 1) * NEAR_EPS_FRAC;
  const extraDeg = Array.from({length: categories.length}, () => ({})); // extraDeg[j][si] = degrees
  categories.forEach((c, j) => {
    const items = raw.map((row, si) => ({ si, value: row[c] })).sort((a,b) => a.value - b.value);
    let cluster = [items[0]];
    for (let k = 1; k < items.length; k++) {
      if (Math.abs(items[k].value - items[k-1].value) <= NEAR_EPS) {
        cluster.push(items[k]);
      } else {
        assignClusterOffsets(cluster, extraDeg[j]);
        cluster = [items[k]];
      }
    }
    assignClusterOffsets(cluster, extraDeg[j]);
  });
  function assignClusterOffsets(cluster, outMap){
    const n = cluster.length;
    if (!n) return;
    const base = (n % 2 === 0) ? (-(n-1)/2 + 0.5) : (-(n-1)/2);
    for (let idx = 0; idx < n; idx++) {
      const off = (base + idx) * CLUSTER_STEP_DEG;
      outMap[cluster[idx].si] = (outMap[cluster[idx].si] || 0) + off;
    }
  }

  // ---------- RADAR SHAPES ----------
  const line = d3.lineRadial()
    .radius(d => rScale(d.value))
    .angle((d,i) => i*angleSlice)
    .curve(d3.curveLinearClosed); // sharp edges

  raw.forEach((row, si) => {
    const series = categories.map((c, j) => ({ axis:c, value:+row[c], j, angle:j*angleSlice }));

    // area + outline
    svg.append("path")
      .datum(series)
      .attr("transform", `translate(${cx},${cy})`)
      .attr("fill", color(si)).attr("fill-opacity", 0.15)
      .attr("stroke", color(si)).attr("stroke-width", 2)
      .attr("d", line);

    const g = svg.append("g").attr("transform", `translate(${cx},${cy})`);

    const half = (raw.length - 1) / 2;
    const baseSeriesDeg = (si - half) * LABEL_JITTER_DEG;

    const jitteredAngle = (d) => {
      const deg = baseSeriesDeg + (extraDeg[d.j][si] || 0);   // total degrees of jitter
      return (d.angle - Math.PI/2) + (deg * Math.PI / 180);
    };

    // points with the SAME jitter as labels (so they align)
    g.selectAll("circle.point")
      .data(series).enter().append("circle")
      .attr("r",3.2)
      .attr("cx", d => Math.cos(jitteredAngle(d)) * rScale(d.value))
      .attr("cy", d => Math.sin(jitteredAngle(d)) * rScale(d.value))
      .attr("fill", color(si));

    // value labels exactly on the ring, slid along ring by jitter
    g.selectAll("text.value-label")
      .data(series).enter().append("text")
      .attr("class","value-label")
      .attr("x", d => Math.cos(jitteredAngle(d)) * rScale(d.value))
      .attr("y", d => Math.sin(jitteredAngle(d)) * rScale(d.value))
      .attr("text-anchor", d => {
        const ux = Math.cos(jitteredAngle(d));
        if (Math.abs(ux) < 0.35) return "middle";
        return ux > 0 ? "start" : "end";
      })
      .attr("dy", "0.35em")
      .text(d => fmtValue(d.value));
  });

  // ---------- LEGEND (horizontal bottom) ----------
  raw.forEach((row,i)=>{
    const it = legend.append("div").attr("class","item");
    it.append("span").attr("class","swatch").style("background", color(i));
    it.append("span").text(row[groupKey]);
  });
});
</script>
</body>
</html>
