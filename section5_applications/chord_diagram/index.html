
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Chord Diagram — Battery Flows (Layered CSV)</title>
<style>
  :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  body { margin: 0; background: #0b0c10; color: #eaf0f6; }
  header { padding: 14px 18px; border-bottom: 1px solid #1f2430; background: #0f1116; }
  h1 { font-size: 18px; margin: 0 0 6px; }
  .wrap { max-width: 1200px; margin: 0 auto; padding: 16px 18px 36px; }
  .panel { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit,minmax(260px,1fr)); }
  .card { background: #121520; border: 1px solid #232a3a; border-radius: 14px; padding: 12px; }
  .card h3 { margin: 0 0 8px; font-size: 14px; font-weight: 600; color: #cfd7e3; }
  label { font-size: 12px; opacity: .9; display:block; margin-bottom: 6px; }
  select, input[type="number"] { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #2c3447; background: #0f1320; color:#eaf0f6; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .canvas { margin-top: 14px; height: 700px; background: #0d1120; border: 1px solid #1f2536; border-radius: 14px; overflow: hidden; }
  .hint { font-size: 12px; opacity: .75; }
  .legend { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; font-size:12px; }
  .lg { display:flex; align-items:center; gap:6px; }
  .sw { width:12px; height:12px; border-radius:3px; border:1px solid #0003; }
  .footer { margin-top:8px; font-size:12px; opacity:.7 }
  button { appearance:none; border:1px solid #2f3a52; background:#1a2240; color:#eaf0f6; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
</style>
</head>
<body>
<header>
  <h1>Chord Diagram — Battery Flows</h1>
  <div class="hint">Pick a layered CSV and which adjacent layers to visualize as a chord. Thickness = Count.</div>
</header>

<div class="wrap">
  <div class="panel">
    <div class="card">
      <h3>Data</h3>
      <label for="fileSel">Layered CSV (same folder):</label>
      <select id="fileSel">
        <option value="data_thresholded.csv" selected>Thresholded (layered, cleaned)</option>
        <option value="data_raw.csv">RAW (layered, cleaned)</option>
      </select>
      <div class="hint" style="margin-top:6px">Headers: <code>Source,SourceName,TargetLayer,TargetName,Count</code></div>
    </div>
    <div class="card">
      <h3>Layer Pair</h3>
      <label for="pairSel">Choose adjacent layers</label>
      <select id="pairSel">
        <option value="Anode|Structure Type" selected>Anode → Structure Type</option>
        <option value="Structure Type|Ion Type">Structure Type → Ion Type</option>
        <option value="Ion Type|Cathode">Ion Type → Cathode</option>
      </select>
      <label for="minCount" style="margin-top:8px">Minimum link count (hide links &lt; min)</label>
      <input id="minCount" type="number" min="1" step="1" value="1">
    </div>
    <div class="card">
      <h3>Export</h3>
      <div class="row">
        <button id="downloadSVG">Download SVG</button>
      </div>
      <div class="footer">Tip: run a local server if your browser blocks file access (<code>python -m http.server</code>).</div>
    </div>
  </div>

  <div id="stage" class="canvas">
    <svg id="svg" width="100%" height="100%"></svg>
  </div>
  <div id="legend" class="legend"></div>
</div>

<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-chord@3"></script>

<script>
const svg = d3.select("#svg");
const stage = document.getElementById("stage");
const legend = d3.select("#legend");
const colors = d3.schemeTableau10.concat(d3.schemeSet3 ?? []);
const color = d3.scaleOrdinal(colors);

async function loadLayered(file) {
  const rows = await d3.csv(file, d3.autoType);
  return rows.map(r => ({
    Source: (r.Source ?? "").trim(),
    SourceName: (r.SourceName ?? "").trim(),
    TargetLayer: (r.TargetLayer ?? "").trim(),
    TargetName: (r.TargetName ?? "").trim(),
    Count: +r.Count || 0
  }));
}

function buildChordData(rows, srcLayer, tgtLayer, minCount=1) {
  const filtered = rows.filter(r => r.Source === srcLayer && r.TargetLayer === tgtLayer && r.Count >= minCount);
  const names = Array.from(new Set(filtered.flatMap(r => [r.SourceName, r.TargetName]))).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:"base"}));
  const index = new Map(names.map((n,i)=>[n,i]));
  const n = names.length;
  const matrix = Array.from({length:n}, ()=>Array(n).fill(0));
  for (const r of filtered) {
    const i = index.get(r.SourceName);
    const j = index.get(r.TargetName);
    if (i!=null && j!=null) matrix[i][j] += r.Count;
  }
  return { names, matrix };
}

function renderChord(names, matrix) {
  const { width, height } = stage.getBoundingClientRect();
  svg.attr("viewBox", `0 0 ${width} ${height}`);
  svg.selectAll("*").remove();

  const outerRadius = Math.min(width, height) * 0.45;
  const innerRadius = outerRadius - 20;

  const chord = d3.chordDirected()
    .padAngle(0.015)
    .sortSubgroups(d3.descending);

  const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
  const ribbon = d3.ribbonArrow().radius(innerRadius);

  const chords = chord(matrix);
  const g = svg.append("g").attr("transform", `translate(${width/2},${height/2})`);

  const group = g.append("g").selectAll("g").data(chords.groups).join("g");

  group.append("path")
    .attr("fill", d => color(d.index))
    .attr("stroke", d => d3.color(color(d.index)).darker(0.5))
    .attr("d", arc);

  group.append("title")
    .text(d => `${names[d.index]} — total: ${d3.sum(matrix[d.index]) + d3.sum(matrix.map(row => row[d.index]))}`);

  group.append("text")
    .each(d => d.angle = (d.startAngle + d.endAngle) / 2)
    .attr("dy", "0.35em")
    .attr("transform", d => `rotate(${(d.angle*180/Math.PI-90)}) translate(${outerRadius+8}) ${d.angle>Math.PI ? "rotate(180)":""}`)
    .attr("text-anchor", d => d.angle>Math.PI ? "end":"start")
    .style("font-size","10px")
    .text(d => names[d.index]);

  g.append("g")
    .attr("fill-opacity", 0.75)
    .selectAll("path")
    .data(chords)
    .join("path")
    .attr("fill", d => color(d.source.index))
    .attr("stroke", d => d3.color(color(d.source.index)).darker(0.5))
    .attr("d", ribbon)
    .append("title")
    .text(d => `${names[d.source.index]} → ${names[d.target.index]}: ${d.source.value}`);

  // Legend (first 24 to avoid bloat)
  legend.selectAll("*").remove();
  const lg = legend.selectAll(".lg").data(names.slice(0,24)).join("div").attr("class","lg");
  lg.append("div").attr("class","sw").style("background", (d,i)=>color(i));
  lg.append("div").text(d => d);
  if (names.length>24) legend.append("div").attr("class","hint").text(`… +${names.length-24} more`);
}

async function refresh() {
  const file = document.getElementById("fileSel").value;
  const [srcLayer, tgtLayer] = document.getElementById("pairSel").value.split("|");
  const minCount = Math.max(1, parseInt(document.getElementById("minCount").value || "1", 10));

  const rows = await loadLayered(file);
  const { names, matrix } = buildChordData(rows, srcLayer, tgtLayer, minCount);
  renderChord(names, matrix);
}

document.getElementById("fileSel").addEventListener("change", refresh);
document.getElementById("pairSel").addEventListener("change", refresh);
document.getElementById("minCount").addEventListener("change", refresh);
window.addEventListener("resize", refresh);
document.getElementById("downloadSVG").addEventListener("click", () => {
  const serializer = new XMLSerializer();
  const svgNode = document.getElementById("svg");
  const src = serializer.serializeToString(svgNode);
  const blob = new Blob([src], { type: "image/svg+xml;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "chord.svg";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

refresh();
</script>
</body>
</html>
