<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cycle Life vs Retention % — Fixed 20k (data.csv)</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root { color-scheme: light; }
  body { margin: 16px; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; background:#f7f7f7; color:#0f172a; }
  h2 { margin: 8px 0 12px; font-size: 24px; }
  .status { display:inline-block; margin: 0 0 12px; padding: 6px 10px; background:#fff; border:1px solid #e5e7eb; border-radius: 999px; font-size: 12px; color:#374151; }
  .wrap { display: flex; align-items: flex-start; gap: 16px; }
  #chartPane { flex: 1 1 auto; min-width: 0; }
  svg { width: 100%; height: auto; background:#fff; border:1px solid #e5e7eb; border-radius: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
  .axis path, .axis line { stroke:#9ca3af; }
  .axis text { fill:#374151; font-size:12px; }
  .tooltip { position: fixed; pointer-events: none; background:#fff; border:1px solid #e5e7eb; box-shadow:0 8px 16px rgba(0,0,0,.08); border-radius:8px; padding:8px 10px; font-size:12px; color:#111827; }
  .legends { flex: 0 0 260px; position: sticky; top: 8px; display:flex; flex-direction: column; gap: 12px; }
  .card { background:#fff; border:1px solid #e5e7eb; border-radius: 12px; padding: 10px 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
  .card h3 { margin: 0 0 8px; font-size: 13px; color:#111827; }
  .legend-item { display:flex; align-items:center; gap:8px; font-size:12px; margin:6px 0; color:#334155; }
  .legend-swatch { width:16px; height:16px; border-radius:4px; border:1px solid rgba(0,0,0,0.35); }
  .legend-symbol { width:18px; height:18px; flex:0 0 18px; }
  .caption { margin-top: 8px; color:#6b7280; font-size: 12px; }
  @media (max-width: 980px) {
    .wrap { flex-direction: column; }
    .legends { position: static; width: 100%; flex-basis: auto; }
  }
</style>
</head>
<body>

<h2>Cycle Life vs Retention %</h2>
<div class="status" id="status">loading…</div>

<div class="wrap">
  <div id="chartPane">
    <svg id="chart" viewBox="0 0 1000 640" preserveAspectRatio="xMidYMid meet"></svg>
    <div class="caption">X-axis fixed to 20k (log scale). Retention clamped to 0–100%.</div>
  </div>
  <aside class="legends">
    <div class="card">
      <h3>Structure Type (Color)</h3>
      <div id="colorItems"></div>
    </div>
    <div class="card">
      <h3>Ion Type (Shape)</h3>
      <div id="shapeItems"></div>
    </div>
  </aside>
</div>

<script>
const CSV_FILE = "data.csv";

const margin = {top: 24, right: 20, bottom: 60, left: 70};
const innerW = 1000 - margin.left - margin.right;
const innerH = 640 - margin.top - margin.bottom;

const svg = d3.select("#chart");
const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
const xAxisG = g.append("g").attr("class", "axis").attr("transform", `translate(0,${innerH})`);
const yAxisG = g.append("g").attr("class", "axis");

g.append("text")
  .attr("x", innerW/2).attr("y", innerH + 46).attr("text-anchor","middle")
  .attr("fill", "#111827").attr("font-size", 13)
  .text("Cycle Life");

g.append("text")
  .attr("transform","rotate(-90)").attr("x", -innerH/2).attr("y", -50)
  .attr("text-anchor","middle").attr("fill", "#111827").attr("font-size", 13)
  .text("Retention (%)");

const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

const fmtInt = d3.format(",");

// Robust cycle-life parser (handles '1e4', '10^3', '20k', ranges '1k-2k', '~', '>' etc.)
function parseCycleLife(s) {
  if (s == null) return NaN;
  let str = String(s).trim().toLowerCase().replace(/,/g, "");
  if (!str) return NaN;
  // ranges: take the max
  const range = str.split(/[-–—to]+/i).map(x => x.trim());
  if (range.length > 1) {
    return d3.max(range.map(parseCycleLife));
  }
  // scientific like 1e4
  if (/^[~>]*\s*\d*\.?\d+\s*e[-+]?\d+/.test(str)) {
    const m = str.match(/(\d*\.?\d+)\s*e\s*([-+]?\d+)/);
    if (m) return Number(m[1]) * Math.pow(10, Number(m[2]));
  }
  // 10^n
  if (/10\^[-+]?\d+/.test(str)) {
    const m = str.match(/10\^([-+]?\d+)/);
    if (m) return Math.pow(10, Number(m[1]));
  }
  // suffix k / m
  if (/^\s*[~>]*\s*\d*\.?\d+\s*[km]\b/.test(str)) {
    const m = str.match(/(\d*\.?\d+)\s*([km])/);
    if (m) {
      const v = Number(m[1]);
      return m[2] === "k" ? v * 1e3 : v * 1e6;
    }
  }
  // plain number
  const plain = str.match(/-?\d*\.?\d+/);
  if (plain) return Number(plain[0]);
  return NaN;
}

// pick column helper
function pick(cols, candidates) { for (const c of candidates) if (cols.includes(c)) return c; return null; }

d3.csv(CSV_FILE).then(raw => {
  const cols = Object.keys(raw[0] || {});

  const C_FORMULA = pick(cols, ["Formula (Chemical)", "Formula"]);
  const C_STRUCT  = pick(cols, ["Structure Group","StructureType","Structure_Type"]);
  const C_ION     = pick(cols, ["Ion Type","IonType","Ion_Type"]);
  const C_CYCLE   = pick(cols, ["Cycle Life normalized (cycles)","Cycle Life","Cycle Life (N cycles or hours)"]);
  const C_RET     = pick(cols, ["Retention % normalized","Retention","Retention %"]);

  const missing = [C_FORMULA,C_STRUCT,C_ION,C_CYCLE,C_RET].filter(v => !v);
  if (missing.length) {
    d3.select("#status").text("Missing required columns in CSV.");
    g.append("text").attr("x", innerW/2).attr("y", innerH/2).attr("text-anchor","middle").attr("fill","#6b7280")
      .text("No data to plot — column mapping failed.");
    return;
  }

  const data = raw.map(d => {
    const cycle = parseCycleLife(d[C_CYCLE]);
    const ret   = Number(String(d[C_RET]).replace(/%/g,""));
    return {
      Formula: (d[C_FORMULA] || "").trim(),
      StructureType: (d[C_STRUCT] || "").trim(),
      IonType: (d[C_ION] || "").trim(),
      CycleLife: cycle,
      Retention: Math.max(0, Math.min(100, isFinite(ret) ? ret : NaN))
    };
  }).filter(d =>
    Number.isFinite(d.CycleLife) && d.CycleLife > 0 &&
    Number.isFinite(d.Retention)
  );

  d3.select("#status").text(`rows loaded: ${raw.length} | plotted: ${data.length}`);
  if (!data.length) {
    g.append("text").attr("x", innerW/2).attr("y", innerH/2).attr("text-anchor","middle").attr("fill","#6b7280")
      .text("No data to plot after filtering.");
    return;
  }

  // Encodings
  const structureTypes = [...new Set(data.map(d => d.StructureType).filter(Boolean))];
  const ionTypes = [...new Set(data.map(d => d.IonType).filter(Boolean))];
  const color = d3.scaleOrdinal(d3.schemeTableau10).domain(structureTypes);
  const shapes = [d3.symbolCircle, d3.symbolSquare, d3.symbolTriangle, d3.symbolDiamond, d3.symbolCross, d3.symbolStar, d3.symbolWye];
  const getShape = t => shapes[(ionTypes.indexOf(t) >= 0 ? ionTypes.indexOf(t) : 0) % shapes.length];

  // Fixed log X from 10 to 20,000
  const x = d3.scaleLinear().domain([0, 20000]).range([0, innerW]);
  const y = d3.scaleLinear().domain([0, 100]).range([innerH, 0]);

  const xTicks = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
  xAxisG.call(d3.axisBottom(x)
    .tickValues(xTicks)
    .tickFormat(d => d >= 1000 ? (d/1000) + "k" : d));

  yAxisG.call(d3.axisLeft(y).ticks(10).tickFormat(d => d + "%"));

  // Points
  const S = 110;
  g.selectAll(".pt").data(data).join("path")
    .attr("class","pt")
    .attr("transform", d => `translate(${x(Math.max(10, Math.min(20000, d.CycleLife)))},${y(d.Retention)})`)
    .attr("d", d => d3.symbol().type(getShape(d.IonType)).size(S)())
    .attr("fill", d => color(d.StructureType))
    .attr("stroke", "#111827").attr("stroke-width", 0.6).attr("opacity", 0.95)
    .on("mouseover", (event, d) => {
      tooltip.style("opacity", 1).html(`
        <div><b>${d.Formula || "(unknown)"}<\/b></div>
        <div>Structure: ${d.StructureType || "—"}<\/div>
        <div>Ion: ${d.IonType || "—"}<\/div>
        <div>Cycle Life: ${d3.format(",")(Math.round(d.CycleLife))}<\/div>
        <div>Retention: ${d.Retention}%<\/div>
      `);
    })
    .on("mousemove", (event) => {
      tooltip.style("left", (event.clientX + 14) + "px")
             .style("top",  (event.clientY + 14) + "px");
    })
    .on("mouseout", () => tooltip.style("opacity", 0));

  // Legends
  const colorItems = d3.select("#colorItems");
  structureTypes.forEach(s => {
    const item = colorItems.append("div").attr("class","legend-item");
    item.append("div").attr("class","legend-swatch").style("background", color(s));
    item.append("span").text(s || "—");
  });

  const shapeItems = d3.select("#shapeItems");
  ionTypes.forEach(t => {
    const item = shapeItems.append("div").attr("class","legend-item");
    const symSvg = item.append("svg").attr("class","legend-symbol").attr("viewBox","-10 -10 20 20");
    symSvg.append("path")
      .attr("d", d3.symbol().type(getShape(t)).size(140)())
      .attr("fill", "#6b7280").attr("stroke", "#111827").attr("stroke-width", 0.6);
    item.append("span").text(t || "—");
  });
});
</script>
</body>
</html>
