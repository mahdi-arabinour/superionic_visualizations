<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cycle Life vs Retention % — Interactive Legends (Solo on Click)</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root { color-scheme: light; }
  body { margin: 16px; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; background:#f7f7f7; color:#0f172a; }
  h2 { margin: 8px 0 12px; font-size: 24px; }
  .status { display:inline-block; margin: 0 0 12px; padding: 6px 10px; background:#fff; border:1px solid #e5e7eb; border-radius: 999px; font-size: 12px; color:#374151; }
  .wrap { display: flex; align-items: flex-start; gap: 16px; }
  #chartPane { flex: 1 1 auto; min-width: 0; }
  svg { width: 100%; height: auto; background:#fff; border:1px solid #e5e7eb; border-radius: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
  .axis path, .axis line { stroke:#9ca3af; }
  .axis text { fill:#374151; font-size:12px; }
  .tooltip { position: fixed; pointer-events: none; background:#fff; border:1px solid #e5e7eb; box-shadow:0 8px 16px rgba(0,0,0,.08); border-radius:8px; padding:8px 10px; font-size:12px; color:#111827; }
  .legends { flex: 0 0 280px; position: sticky; top: 8px; display:flex; flex-direction: column; gap: 12px; }
  .card { background:#fff; border:1px solid #e5e7eb; border-radius: 12px; padding: 10px 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
  .card h3 { margin: 0 0 8px; font-size: 13px; color:#111827; display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .legend-list { display:flex; flex-direction: column; gap:4px; }
  .legend-item { display:flex; align-items:center; gap:8px; font-size:12px; padding:6px 8px; border-radius:8px; cursor:pointer; user-select:none; }
  .legend-item:hover { background:#f3f4f6; }
  .legend-item.inactive { opacity:0.45; }
  .legend-swatch { width:16px; height:16px; border-radius:4px; border:1px solid rgba(0,0,0,0.35); }
  .legend-symbol { width:18px; height:18px; flex:0 0 18px; }
  .caption { margin-top: 8px; color:#6b7280; font-size: 12px; }
  .reset { border:1px solid #e5e7eb; background:#fff; border-radius:999px; padding:4px 8px; cursor:pointer; font-size:12px; color:#374151; }
  .reset:hover { background:#f3f4f6; }
  @media (max-width: 980px) {
    .wrap { flex-direction: column; }
    .legends { position: static; width: 100%; flex-basis: auto; }
  }
</style>
</head>
<body>

<h2>Cycle Life vs Retention %</h2>
<div class="status" id="status">loading…</div>

<div class="wrap">
  <div id="chartPane">
    <svg id="chart" viewBox="0 0 1000 640" preserveAspectRatio="xMidYMid meet"></svg>
    <div class="caption">Both axes linear. X fixed to 0–20k cycles. Retention clamped to 0–100%.</div>
  </div>
  <aside class="legends">
    <div class="card" id="card-structure">
      <h3>Structure Type (Color) <button class="reset" id="resetStructure">Reset</button></h3>
      <div id="colorItems" class="legend-list"></div>
    </div>
    <div class="card" id="card-ion">
      <h3>Ion Type (Shape) <button class="reset" id="resetIon">Reset</button></h3>
      <div id="shapeItems" class="legend-list"></div>
    </div>
  </aside>
</div>

<script>
const CSV_FILE = "data.csv";

const margin = {top: 24, right: 20, bottom: 60, left: 70};
const innerW = 1000 - margin.left - margin.right;
const innerH = 640 - margin.top - margin.bottom;

const svg = d3.select("#chart");
const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
const xAxisG = g.append("g").attr("class", "axis").attr("transform", `translate(0,${innerH})`);
const yAxisG = g.append("g").attr("class", "axis");

g.append("text").attr("x", innerW/2).attr("y", innerH + 46).attr("text-anchor","middle").attr("fill", "#111827").attr("font-size", 13).text("Cycle Life");
g.append("text").attr("transform","rotate(-90)").attr("x", -innerH/2).attr("y", -50).attr("text-anchor","middle").attr("fill", "#111827").attr("font-size", 13).text("Retention (%)");

const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);
const fmtInt = d3.format(",");

function parseCycleLife(s) {
  if (s == null) return NaN;
  let str = String(s).trim().toLowerCase().replace(/,/g, "");
  if (!str) return NaN;
  const range = str.split(/[-–—to]+/i).map(x => x.trim());
  if (range.length > 1) return d3.max(range.map(parseCycleLife));
  if (/^[~>]*\s*\d*\.?\d+\s*e[-+]?\d+/.test(str)) {
    const m = str.match(/(\d*\.?\d+)\s*e\s*([-+]?\d+)/);
    if (m) return Number(m[1]) * Math.pow(10, Number(m[2]));
  }
  if (/10\^[-+]?\d+/.test(str)) {
    const m = str.match(/10\^([-+]?\d+)/);
    if (m) return Math.pow(10, Number(m[1]));
  }
  if (/^\s*[~>]*\s*\d*\.?\d+\s*[km]\b/.test(str)) {
    const m = str.match(/(\d*\.?\d+)\s*([km])/);
    if (m) { const v = Number(m[1]); return m[2] === "k" ? v * 1e3 : v * 1e6; }
  }
  const plain = str.match(/-?\d*\.?\d+/);
  if (plain) return Number(plain[0]);
  return NaN;
}
function pick(cols, cands){ for(const c of cands) if(cols.includes(c)) return c; return null; }

d3.csv(CSV_FILE).then(raw => {
  const cols = Object.keys(raw[0] || {});
  const C_FORMULA = pick(cols, ["Formula (Chemical)", "Formula"]);
  const C_STRUCT  = pick(cols, ["Structure Group","StructureType","Structure_Type"]);
  const C_ION     = pick(cols, ["Ion Type","IonType","Ion_Type"]);
  const C_CYCLE   = pick(cols, ["Cycle Life normalized (cycles)","Cycle Life","Cycle Life (N cycles or hours)"]);
  const C_RET     = pick(cols, ["Retention % normalized","Retention","Retention %"]);

  const data = raw.map(d => {
    const cycle = parseCycleLife(d[C_CYCLE]);
    const ret   = Number(String(d[C_RET]).replace(/%/g,""));
    return {
      Formula: (d[C_FORMULA] || "").trim(),
      StructureType: (d[C_STRUCT] || "").trim(),
      IonType: (d[C_ION] || "").trim(),
      CycleLife: cycle,
      Retention: Math.max(0, Math.min(100, isFinite(ret) ? ret : NaN))
    };
  }).filter(d => Number.isFinite(d.CycleLife) && d.CycleLife >= 0 && Number.isFinite(d.Retention));

  d3.select("#status").text(`rows loaded: ${raw.length} | plotted: ${data.length}`);
  if (!data.length) {
    g.append("text").attr("x", innerW/2).attr("y", innerH/2).attr("text-anchor","middle").attr("fill","#6b7280").text("No data to plot after filtering.");
    return;
  }

  const structureTypes = [...new Set(data.map(d => d.StructureType).filter(Boolean))];
  const ionTypes = [...new Set(data.map(d => d.IonType).filter(Boolean))];
  const color = d3.scaleOrdinal(d3.schemeTableau10).domain(structureTypes);
  const shapes = [d3.symbolCircle, d3.symbolSquare, d3.symbolTriangle, d3.symbolDiamond, d3.symbolCross, d3.symbolStar, d3.symbolWye];
  const getShape = t => shapes[(ionTypes.indexOf(t) >= 0 ? ionTypes.indexOf(t) : 0) % shapes.length];

  const x = d3.scaleLinear().domain([0,20000]).range([0,innerW]);
  const y = d3.scaleLinear().domain([0,100]).range([innerH,0]);
  const xTicks = [0,100,200,500,1000,2000,5000,10000,20000];
  xAxisG.call(d3.axisBottom(x).tickValues(xTicks).tickFormat(d => d>=1000 ? (d/1000)+"k" : d));
  yAxisG.call(d3.axisLeft(y).ticks(10).tickFormat(d => d+"%"));

  const points = g.selectAll(".pt").data(data).join("path")
    .attr("class","pt")
    .attr("transform", d => `translate(${x(Math.max(0, Math.min(20000, d.CycleLife)))},${y(d.Retention)})`)
    .attr("d", d => d3.symbol().type(getShape(d.IonType)).size(110)())
    .attr("fill", d => color(d.StructureType))
    .attr("stroke","#111827").attr("stroke-width",0.6).attr("opacity",0.95)
    .on("mouseover",(event,d)=>{
      tooltip.style("opacity",1).html(`
        <div><b>${d.Formula || "(unknown)"}<\/b></div>
        <div>Structure: ${d.StructureType || "—"}<\/div>
        <div>Ion: ${d.IonType || "—"}<\/div>
        <div>Cycle Life: ${d3.format(",")(Math.round(d.CycleLife))}<\/div>
        <div>Retention: ${d.Retention}%<\/div>`);
    })
    .on("mousemove",(event)=>{tooltip.style("left",(event.clientX+14)+"px").style("top",(event.clientY+14)+"px");})
    .on("mouseout",()=>tooltip.style("opacity",0));

  // Filters
  let activeStructures = new Set(structureTypes);
  let activeIons = new Set(ionTypes);

  function refreshLegendStates(){
    d3.selectAll("#colorItems .legend-item").classed("inactive", function(){
      const txt = d3.select(this).select("span").text();
      return !activeStructures.has(txt);
    });
    d3.selectAll("#shapeItems .legend-item").classed("inactive", function(){
      const txt = d3.select(this).select("span").text();
      return !activeIons.has(txt);
    });
  }

  function updateVisibility(){
    points.transition().duration(250)
      .style("opacity", d => (activeStructures.has(d.StructureType) && activeIons.has(d.IonType)) ? 0.95 : 0.08)
      .style("display", d => (activeStructures.has(d.StructureType) && activeIons.has(d.IonType)) ? null : "none");
  }

  // Structure legend (solo on click; Ctrl/Cmd=toggle; Shift=add)
  const colorItems = d3.select("#colorItems");
  structureTypes.forEach(s => {
    const item = colorItems.append("div").attr("class","legend-item");
    item.on("click", (event) => {
      const soloActive = activeStructures.size === 1 && activeStructures.has(s);
      if (event.metaKey || event.ctrlKey) {
        if (activeStructures.has(s)) activeStructures.delete(s); else activeStructures.add(s);
      } else if (event.shiftKey) {
        activeStructures.add(s);
      } else {
        activeStructures = soloActive ? new Set(structureTypes) : new Set([s]);
      }
      refreshLegendStates();
      updateVisibility();
    });
    item.append("div").attr("class","legend-swatch").style("background", color(s));
    item.append("span").text(s || "—");
  });

  // Ion legend (same behavior)
  const shapeItems = d3.select("#shapeItems");
  ionTypes.forEach(t => {
    const item = shapeItems.append("div").attr("class","legend-item");
    item.on("click", (event) => {
      const soloActive = activeIons.size === 1 && activeIons.has(t);
      if (event.metaKey || event.ctrlKey) {
        if (activeIons.has(t)) activeIons.delete(t); else activeIons.add(t);
      } else if (event.shiftKey) {
        activeIons.add(t);
      } else {
        activeIons = soloActive ? new Set(ionTypes) : new Set([t]);
      }
      refreshLegendStates();
      updateVisibility();
    });
    const symSvg = item.append("svg").attr("class","legend-symbol").attr("viewBox","-10 -10 20 20");
    symSvg.append("path").attr("d", d3.symbol().type(getShape(t)).size(140)()).attr("fill","#6b7280").attr("stroke","#111827").attr("stroke-width",0.6);
    item.append("span").text(t || "—");
  });

  document.getElementById("resetStructure").addEventListener("click",()=>{
    activeStructures = new Set(structureTypes); refreshLegendStates(); updateVisibility();
  });
  document.getElementById("resetIon").addEventListener("click",()=>{
    activeIons = new Set(ionTypes); refreshLegendStates(); updateVisibility();
  });

  refreshLegendStates();
  updateVisibility();
});
</script>
</body>
</html>
