<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Violin plot (log10σ) + Deterministic Jitter</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body{font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:24px;background:#fafafa;color:#111}
  h2{margin:0 0 10px}
  .toolbar{display:flex;gap:10px;align-items:center;margin:8px 0 14px}
  .note{font-size:12px;color:#64748b}
  svg{width:1080px;height:680px;background:#fff;border:1px solid #e5e7eb;border-radius:12px}
  .grid line{stroke:#eef2f7}
  .axis-label{font-size:14px;font-weight:600;fill:#111}
  .violin{fill:#9aa3b2;fill-opacity:.25;stroke:#1f2937;stroke-width:1}
  .dot{stroke:#111827;stroke-width:.35px}
  .legend{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:8px 0 0}
  .legend-item{display:flex;align-items:center;gap:6px;padding:2px 6px;border:1px solid #e5e7eb;border-radius:6px;cursor:pointer;user-select:none}
  .legend-item.disabled{opacity:.35;text-decoration:line-through}
  .swatch{width:12px;height:12px;border-radius:3px;border:1px solid #111}
  button{padding:6px 10px;border-radius:8px;border:1px solid #d1d5db;background:#fff;cursor:pointer}
</style>
</head>
<body>

<h2>Violin — log<sub>10</sub>(σ) by Structure Group (dots don’t move)</h2>
<div class="toolbar">
  <button id="download">Download SVG</button>
  <span class="note">Points use per-point deterministic jitter; violins unchanged.</span>
</div>
<svg id="chart"></svg>
<div class="legend" id="legend"></div>

<script>
// ======== CONFIG: columns in your CSV ========
const COL = {
  group: "Structure Group",
  ion:   "Ion Type",
  // one of these must exist:
  rawSigma: "Conductivity σ (S·cm⁻¹) / Temp (°C)",
  logCol:   "log10_sigma"  // optional: precomputed
};

// ======== Deterministic jitter helpers (stable per point) ========
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i=0; i<str.length; i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967295;
  };
}
function stableJitter(key, half){
  const seed = xmur3(key)();
  const rand = mulberry32(seed);
  return (rand()*2 - 1) * half; // [-half, +half]
}

// ======== KDE helpers (Epanechnikov) on log10 values ========
function epanechnikov(bw){
  return x => Math.abs(x /= bw) <= 1 ? .75 * (1 - x*x) / bw : 0;
}
function kde(kernel, xs, sample){
  // returns array of [x, density] for x in xs domain, using sample[] values
  return xs.map(x => [x, d3.mean(sample, v => kernel(x - v))]);
}

const svg = d3.select("#chart");
const W = +svg.attr("width"), H = +svg.attr("height");
const margin = {top: 40, right: 24, bottom: 86, left: 84};
const innerW = W - margin.left - margin.right;
const innerH = H - margin.top - margin.bottom;
const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

// Load data.csv
d3.csv("data.csv").then(rows => {
  // Coerce and compute log10(σ)
  const data = rows.map(d => {
    const group = (d[COL.group] ?? "Others").trim() || "Others";
    const ion   = (d[COL.ion]   ?? "Unknown").trim() || "Unknown";
    let logv = null;

    if (COL.logCol in d && d[COL.logCol] !== undefined && d[COL.logCol] !== ""){
      const v = +d[COL.logCol];
      logv = Number.isFinite(v) ? v : null;
    } else if (COL.rawSigma in d){
      const raw = +d[COL.rawSigma];
      logv = (Number.isFinite(raw) && raw > 0) ? Math.log10(raw) : null;
    }
    return {group, ion, logv, raw: d[COL.rawSigma]};
  }).filter(d => d.logv !== null);

  const groups = Array.from(new Set(data.map(d => d.group)));
  const ions = Array.from(new Set(data.map(d => d.ion)));

  // Scales
  const x = d3.scaleBand().domain(groups).range([0, innerW]).padding(0.18);
  const y = d3.scaleLinear()
      .domain(d3.extent(data, d => d.logv)).nice()
      .range([innerH, 0]);

  // Axes + grid
  g.append("g").attr("transform", `translate(0,${innerH})`)
    .call(d3.axisBottom(x))
    .selectAll("text")
    .attr("transform","rotate(-28)")
    .style("text-anchor","end");

  g.append("g").call(
    d3.axisLeft(y).ticks(10).tickFormat(v => `10^${v}`)
  );
  g.append("g").attr("class","grid")
    .call(d3.axisLeft(y).ticks(10).tickSize(-innerW).tickFormat(""));

  g.append("text").attr("class","axis-label")
    .attr("x", innerW/2).attr("y", innerH+64).attr("text-anchor","middle")
    .text("Structure Group");
  g.append("text").attr("class","axis-label")
    .attr("x", -innerH/2).attr("y", -64).attr("text-anchor","middle")
    .attr("transform","rotate(-90)")
    .text("log10(σ) (S·cm⁻¹)");

  // KDE for violins (on log10 values)
  const bandwidth = 0.25; // tweak if you want smoother/rougher violins
  const kernel = epanechnikov(bandwidth);
  const yGrid = d3.range(y.domain()[0], y.domain()[1] + 1e-6, (y.domain()[1] - y.domain()[0]) / 80);

  const violinLayer = g.append("g");
  const maxDensity = d3.max(groups, grp => {
    const sample = data.filter(d => d.group === grp).map(d => d.logv);
    if (!sample.length) return 0;
    const dens = kde(kernel, yGrid, sample);
    return d3.max(dens, d => d[1]) || 0;
  });

  const widthScale = d3.scaleLinear().domain([0, maxDensity || 1]).range([0, x.bandwidth()*0.47]);

  for (const grp of groups){
    const sample = data.filter(d => d.group === grp).map(d => d.logv);
    if (!sample.length) continue;

    const density = kde(kernel, yGrid, sample);
    const center = x(grp) + x.bandwidth()/2;

    const area = d3.area()
      .curve(d3.curveBasis)
      .x0(d => center - widthScale(d[1]))
      .x1(d => center + widthScale(d[1]))
      .y (d => y(d[0]));

    violinLayer.append("path")
      .datum(density)
      .attr("class","violin")
      .attr("d", area);
  }

  // Deterministic jittered dots (within violin width)
  const color = d3.scaleOrdinal().domain(ions).range(d3.schemeTableau10);
  const dotsGroup = g.append("g");

  // cache violin half-width per group for consistent jitter range
  const halfWidthByGroup = Object.fromEntries(groups.map(grp => {
    const sample = data.filter(d => d.group === grp).map(d => d.logv);
    if (!sample.length) return [grp, x.bandwidth()*0.45];
    const density = kde(kernel, yGrid, sample);
    const hw = d3.max(density, d => widthScale(d[1])) || x.bandwidth()*0.45;
    return [grp, Math.max(6, hw)]; // at least a small half width
  }));

  const points = dotsGroup.selectAll("circle.dot")
    .data(data, d => `${d.group}|${d.ion}|${d.logv}|${d.raw}`)
    .join("circle")
      .attr("class","dot")
      .attr("r", 3)
      .attr("cy", d => y(d.logv))
      .attr("cx", d => {
        const c = x(d.group) + x.bandwidth()/2;
        const h = halfWidthByGroup[d.group];
        const key = `${d.group}|${d.ion}|${d.raw}|${d.logv}`;
        return c + stableJitter(key, h);
      })
      .attr("fill", d => color(d.ion));

  // Legend with filter (deterministic positions remain the same)
  const legend = d3.select("#legend");
  let active = new Set(ions);
  const items = legend.selectAll(".legend-item")
    .data(ions)
    .join("div").attr("class","legend-item")
    .on("click", function(_, ion){
      if (active.has(ion)) active.delete(ion); else active.add(ion);
      d3.select(this).classed("disabled", !active.has(ion));
      points.attr("display", d => active.has(d.ion) ? null : "none");
    });

  items.append("div").attr("class","swatch").style("background", d => color(d));
  items.append("span").text(d => d);

  // Download SVG
  document.getElementById("download").addEventListener("click", () => {
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"violin_log10sigma.svg"});
    a.click();
  });
});
</script>
</body>
</html>
