<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Violin — log10(σ) by Structure Group (points colored by Ion Type)</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root { --side: 260px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#fafafa; color:#111; margin:24px; }
  h2 { margin:0 0 10px; }
  .toolbar { display:flex; gap:10px; align-items:center; margin:10px 0 14px; }
  .wrap { display:grid; grid-template-columns: 1fr var(--side); gap:16px; align-items:start; }
  svg { width: 980px; height: 640px; background:#fff; border:1px solid #e5e5e5; border-radius:10px; }
  .axis-label { font-size:14px; font-weight:600; fill:#222; }
  .grid line { stroke:#eee; }
  .violin { fill:#9aa3b2; fill-opacity:.55; stroke:#222; stroke-width:.9px; }
  .median { stroke:#e43; stroke-width:2px; }
  .label-halo { fill:none; stroke:#fff; stroke-width:4px; paint-order:stroke; }
  .median-text { fill:#111; font-size:11px; font-weight:700; text-anchor:middle; }
  .point { opacity:.8; stroke:#333; stroke-width:.4px; }
  .side { position:sticky; top:16px; background:#fff; border:1px solid #e5e5e5; border-radius:10px; padding:12px; }
  .legend-title { font-weight:700; font-size:14px; margin:6px 0; }
  .legend-controls { display:flex; gap:6px; margin: 4px 0 8px; }
  .legend-controls button { font-size:12px; padding:2px 6px; border:1px solid #ccc; background:#fff; cursor:pointer; border-radius:4px; }
  .legend-item { display:flex; align-items:center; gap:8px; margin:6px 0; cursor:pointer; user-select:none; }
  .legend-item.disabled { opacity:.35; text-decoration:line-through; }
  .legend-swatch { width:14px; height:14px; border-radius:3px; border:1px solid #444; }
  button.primary { padding:6px 10px; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
  .note { font-size:12px; color:#64748b; margin-top:6px; }
</style>
</head>
<body>

<h2>Violin Plot + Points — log10(σ) by Structure Group</h2>
<div class="toolbar">
  <button id="downloadBtn" class="primary">Download SVG</button>
  <span class="note">Points colored by Ion Type; violin width comparable across groups (global density, √n width).</span>
</div>

<div class="wrap">
  <svg></svg>

  <div class="side">
    <div class="legend-title">Ion Type (filter points)</div>
    <div class="legend-controls">
      <button id="showAll">Show all</button>
      <button id="hideAll">Hide all</button>
    </div>
    <div id="legend"></div>
  </div>
</div>

<script>
const COL = {
  struct: "Structure Group",
  ion:    "Ion Type",
  sigma:  "Conductivity σ (S·cm⁻¹) / Temp (°C) normalized"
};

const svg = d3.select("svg");
const width = 980, height = 640;
const margin = {top: 40, right: 30, bottom: 80, left: 90};
const innerW = width - margin.left - margin.right;
const innerH = height - margin.top - margin.bottom;
const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

// KDE helpers (Epanechnikov)
const kde = (kernel, X) => V => X.map(x => [x, d3.mean(V, v => kernel(x - v))]);
const epan = k => v => { v/=k; return Math.abs(v)<=1 ? 0.75*(1 - v*v)/k : 0; };

// format helper for labels
const fmt = d3.format(".4f");

d3.csv("data.csv").then(raw => {
  // Parse rows and compute log10(sigma) for KDE and axis
  const rows = raw.map(d => {
    const s = +d[COL.sigma];
    return {
      structure: (d[COL.struct] || "Others").trim() || "Others",
      ion: (d[COL.ion] || "Unknown").trim() || "Unknown",
      sigma: s,
      logSig: Number.isFinite(s) && s > 0 ? Math.log10(s) : null
    };
  }).filter(d => d.logSig !== null);

  const structures = Array.from(new Set(rows.map(d => d.structure)));
  const ions = Array.from(new Set(rows.map(d => d.ion)));

  // Scales
  const x = d3.scaleBand().domain(structures).range([0, innerW]).padding(0.12);
  // Use linear scale on log10(σ) so ticks read nicely as 10^… values
  const y = d3.scaleLinear()
    .domain(d3.extent(rows, d => d.logSig)).nice()
    .range([innerH, 0]);

  // Axes & grid
  g.append("g").attr("transform", `translate(0,${innerH})`)
    .call(d3.axisBottom(x))
    .selectAll("text").attr("transform","rotate(-28)").style("text-anchor","end");

  const yAxis = d3.axisLeft(y)
    .ticks(8)
    .tickFormat(v => `10${v === 0 ? "" : ""}${v === 0 ? "" : ""}${v}`); // show tick at log10 space
  g.append("g").call(yAxis);
  g.append("g").attr("class","grid")
    .call(d3.axisLeft(y).ticks(8).tickSize(-innerW).tickFormat(""));

  g.append("text").attr("class","axis-label")
    .attr("x", innerW/2).attr("y", innerH+62).attr("text-anchor","middle")
    .text("Structure Group");
  g.append("text").attr("class","axis-label")
    .attr("x", -innerH/2).attr("y", -64).attr("transform","rotate(-90)")
    .attr("text-anchor","middle").text("log10(σ) (S/cm)");

  // Colors for points (Ion Type)
  const color = d3.scaleOrdinal().domain(ions).range(d3.schemeTableau10.slice(0, ions.length));

  // Build KDE in log space per structure
  const ticks = d3.ticks(...y.domain(), 80);     // support fine KDE
  const estimator = kde(epan(0.25), ticks);      // bandwidth in log space
  const grouped = d3.group(rows, d => d.structure);

  // Compute densities & medians
  const violins = structures.map(sg => {
    const vals = (grouped.get(sg) || []).map(d => d.logSig);
    if (!vals.length) return { structure: sg, density: [], median: null, n: 0 };
    const dens = estimator(vals);
    const median = d3.quantileSorted(vals.slice().sort(d3.ascending), 0.5);
    return { structure: sg, density: dens, median, n: vals.length };
  });

  // Global density max for comparable widths
  const globalMax = d3.max(violins.flatMap(v => v.density.map(d => d[1]))) || 1;

  // Optional width scale by sqrt(n) (so sparse groups appear thinner)
  const maxN = d3.max(violins, v => v.n) || 1;
  const widthFactor = d3.scaleSqrt().domain([1, maxN]).range([0.55, 1.0]); // tune as desired

  // Draw violins
  g.append("g")
    .selectAll(".violin")
    .data(violins)
    .join("path")
    .attr("class","violin")
    .attr("d", v => {
      const bw = x.bandwidth() * widthFactor(v.n);
      const xCenter = x(v.structure) + x.bandwidth()/2;
      const xSpan = d3.scaleLinear().domain([-globalMax, globalMax]).range([xCenter - bw/2, xCenter + bw/2]);

      const area = d3.area()
        .x0(d => xSpan(-d[1]))
        .x1(d => xSpan(d[1]))
        .y(d => y(d[0]))
        .curve(d3.curveCatmullRom);

      return area(v.density);
    });

  // Median line + label
  g.append("g")
    .selectAll(".median")
    .data(violins.filter(v => v.median !== null))
    .join("g")
    .each(function(v){
      const xCenter = x(v.structure) + x.bandwidth()/2;
      const bw = x.bandwidth() * widthFactor(v.n);
      d3.select(this).append("line")
        .attr("class","median")
        .attr("x1", xCenter - bw*0.25)
        .attr("x2", xCenter + bw*0.25)
        .attr("y1", y(v.median))
        .attr("y2", y(v.median));
      d3.select(this).append("text")
        .attr("class","label-halo")
        .attr("x", xCenter).attr("y", y(v.median) - 6).text(fmt(Math.pow(10, v.median)));
      d3.select(this).append("text")
        .attr("class","median-text")
        .attr("x", xCenter).attr("y", y(v.median) - 6).text(fmt(Math.pow(10, v.median)));
    });

  // Jittered points, colored by Ion Type
  // Build per-structure center and available half-width
  const structCenter = Object.fromEntries(structures.map(sg => [sg, x(sg) + x.bandwidth()/2]));
  const structHalf = Object.fromEntries(violins.map(v => [v.structure, (x.bandwidth() * widthFactor(v.n))/2 * 0.92]));

  // Legend filter state
  let activeIons = new Set(ions);

  const pts = g.append("g")
    .selectAll(".point")
    .data(rows)
    .join("circle")
      .attr("class","point")
      .attr("r", 3)
      .attr("cx", d => {
        const c = structCenter[d.structure], h = structHalf[d.structure] || x.bandwidth()/2;
        return c + (Math.random()*2 - 1) * h; // jitter within violin width
      })
      .attr("cy", d => y(d.logSig))
      .attr("fill", d => color(d.ion))
      .attr("display", d => activeIons.has(d.ion) ? null : "none");

  // Legend – filter points by Ion Type
  const legend = d3.select("#legend");
  const items = legend.selectAll(".legend-item").data(ions).enter()
    .append("div").attr("class","legend-item");
  items.append("div").attr("class","legend-swatch")
    .style("background", d => color(d));
  items.append("span").text(d => d);

  function updatePoints(){
    pts.attr("display", d => activeIons.has(d.ion) ? null : "none");
  }

  items.on("click", function(_, ion){
    if (activeIons.has(ion)) activeIons.delete(ion); else activeIons.add(ion);
    d3.select(this).classed("disabled", !activeIons.has(ion));
    updatePoints();
  });

  d3.select("#showAll").on("click", () => {
    activeIons = new Set(ions);
    items.classed("disabled", false);
    updatePoints();
  });
  d3.select("#hideAll").on("click", () => {
    activeIons.clear();
    items.classed("disabled", true);
    updatePoints();
  });

  // Download SVG
  document.getElementById("downloadBtn").addEventListener("click", () => {
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"violin_log10_sigma_by_structure.svg"});
    a.click();
  });
});
</script>
</body>
</html>
