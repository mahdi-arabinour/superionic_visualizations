<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Box / Violin — log10(σ) by Structure (color = Ion)</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; background:#fff; color:#111; margin:28px; }
  h2 { margin:0 0 8px; }
  .controls { margin: 8px 0 14px; display:flex; gap:12px; align-items:center; }
  label, select { font-size:13px; }
  svg { background:#fff; border:1px solid #ccc; border-radius:8px; }
  .axis text { font-size:8px; fill:#111; }
  .axis .domain, .axis line { stroke:#ccc; }
  .box { fill-opacity:0.12; stroke-width:1; }
  .median { stroke:#111; stroke-width:1.2; }
  .violin { fill-opacity:0.2; stroke-width:0.8; }
  .dot { opacity:0.35; }
  .legend { display:flex; flex-wrap:wrap; gap:8px 12px; margin:10px 0 0; }
  .legend-item { display:flex; align-items:center; gap:6px; font-size:12px; }
  .legend-swatch { width:12px; height:12px; border:1px solid #222; border-radius:3px; }
  .status { font-size:12px; color:#333; margin-top:8px; }
  .tooltip {
    position:absolute; background:#fff; border:1px solid #ccc; border-radius:5px;
    padding:6px 8px; font-size:11px; box-shadow:0 2px 6px rgba(0,0,0,.15); pointer-events:none;
  }
</style>
</head>
<body>

<h2>log₁₀(σ) by Structure Type — color = Ion Type</h2>
<div class="controls">
  <label>Plot:</label>
  <select id="mode">
    <option value="box" selected>Box</option>
    <option value="violin">Violin</option>
  </select>
  <label>Bandwidth (violin):</label>
  <select id="bw">
    <option value="0.4">0.4</option>
    <option value="0.6" selected>0.6</option>
    <option value="0.8">0.8</option>
    <option value="1.0">1.0</option>
  </select>
  <span style="color:#666">x = Structure Type, y = log₁₀(σ), color = Ion Type</span>
</div>

<div id="legend" class="legend"></div>
<svg id="chart" width="1300" height="720"></svg>
<div id="status" class="status">Loading…</div>
<div id="tt" class="tooltip" style="visibility:hidden"></div>

<script>
// ============ CONFIG ============
const CSV_FILE = "data.csv"; // or "data_conductivity_normalized.csv"
const margin = { top: 60, right: 20, bottom: 170, left: 80 },
      outerW = 1300, outerH = 720,
      width  = outerW - margin.left - margin.right,
      height = outerH - margin.top - margin.bottom;

const svg = d3.select("#chart")
  .attr("width", outerW).attr("height", outerH)
  .append("g").attr("transform", `translate(${margin.left},${margin.top})`);

const statusEl = d3.select("#status");
const tooltip  = d3.select("#tt");
const color    = d3.scaleOrdinal(d3.schemeTableau10);

// helpers
function safe(s){ return (s ?? "").toString().replace(/\u00A0/g," ").trim(); }
function jitter(amount){ return (Math.random()-0.5) * amount; }

// violin helpers
function kernelEpanechnikov(k){ return v => Math.abs(v) <= 1 ? 0.75*(1 - v*v)/k : 0; }
function kde(kernel, thresholds, values){
  return thresholds.map(t => [t, d3.mean(values, v => kernel((t - v) / 1))]);
}

d3.csv(CSV_FILE).then(raw => {
  // Coerce/prepare fields (file already contains numeric columns)
  const rows = raw.map(d => {
    // prefer provided log10(σ); fallback compute from σ if needed
    const log10s = +d["log10(σ)"];
    const sigma  = +d["σ (S/cm)"];
    const log10sigma = Number.isFinite(log10s) ? log10s :
                       (Number.isFinite(sigma) && sigma>0 ? Math.log10(sigma) : NaN);
    return {
      structure: safe(d["Structure Type"]),
      ion      : safe(d["Ion Type"]),
      formula  : safe(d["Formula (Chemical)"]),
      sigma    : Number.isFinite(sigma) ? sigma : NaN,
      log10sigma,
      tempC    : +d["Temp (°C)"]
    };
  }).filter(r => Number.isFinite(r.log10sigma));

  if (!rows.length){
    statusEl.text("No usable rows — check CSV path and numeric columns.");
    return;
  }

  // Domains
  const structures = Array.from(new Set(rows.map(r => r.structure))).sort(d3.ascending);
  const ions       = Array.from(new Set(rows.map(r => r.ion))).sort(d3.ascending);

  color.domain(ions);

  // Bands: fewer paddings for wider violins/boxes
  const x0 = d3.scaleBand().domain(structures).range([0, width]).paddingInner(0.08);
  const x1 = d3.scaleBand().domain(ions).range([0, x0.bandwidth()]).padding(0.15);

  const y = d3.scaleLinear()
    .domain(d3.extent(rows, d => d.log10sigma)).nice()
    .range([height, 0]);

  // Axes
  svg.append("g").attr("transform", `translate(0,${height})`)
    .attr("class","axis")
    .call(d3.axisBottom(x0))
    .selectAll("text")
      .attr("transform","rotate(-40)")
      .attr("text-anchor","end")
      .attr("dx","-0.3em").attr("dy","0.2em")
      .style("font-size","8px");

  svg.append("g").attr("class","axis").call(d3.axisLeft(y).ticks(8))
    .append("text")
      .attr("x", -height/2).attr("y", -55)
      .attr("fill", "#111").attr("text-anchor","middle")
      .attr("transform","rotate(-90)")
      .text("log₁₀(σ) [S·cm⁻¹]");

  // Legend
  const legend = d3.select("#legend").html("");
  ions.forEach(i => {
    const item = legend.append("div").attr("class","legend-item");
    item.append("span").attr("class","legend-swatch").style("background", color(i));
    item.append("span").text(i);
  });

  // Grouped data cache for quick draw
  const byStruct = d3.group(rows, d => d.structure);

  const modeSel = document.getElementById("mode");
  const bwSel   = document.getElementById("bw");

  function draw(){
    svg.selectAll(".layer").remove();
    const mode = modeSel.value;
    const bw   = +bwSel.value; // violin bandwidth (in log10 space units)
    const layer = svg.append("g").attr("class","layer");

    byStruct.forEach((arr, struct) => {
      const g = layer.append("g").attr("transform", `translate(${x0(struct)},0)`);

      ions.forEach(ion => {
        const sub = arr.filter(d => d.ion === ion);
        if (!sub.length) return;

        const xC   = x1(ion);
        const vals = sub.map(d => d.log10sigma).sort(d3.ascending);

        if (mode === "box") {
          // ----- BOX -----
          const q1 = d3.quantile(vals, 0.25),
                q2 = d3.quantile(vals, 0.50),
                q3 = d3.quantile(vals, 0.75);
          const iqr = q3 - q1;
          const lo  = Math.max(d3.min(vals), q1 - 1.5 * iqr);
          const hi  = Math.min(d3.max(vals), q3 + 1.5 * iqr);

          // fat boxes
          g.append("rect")
            .attr("class","box")
            .attr("x", xC)
            .attr("width", x1.bandwidth())
            .attr("y", y(q3))
            .attr("height", Math.max(1, y(q1) - y(q3)))
            .attr("fill", color(ion))
            .attr("stroke", d3.color(color(ion)).darker(0.9));

          // median
          g.append("line")
            .attr("class","median")
            .attr("x1", xC).attr("x2", xC + x1.bandwidth())
            .attr("y1", y(q2)).attr("y2", y(q2));

          // whiskers
          g.append("line").attr("x1", xC + x1.bandwidth()/2).attr("x2", xC + x1.bandwidth()/2)
            .attr("y1", y(lo)).attr("y2", y(q1)).attr("stroke","#333");
          g.append("line").attr("x1", xC + x1.bandwidth()/2).attr("x2", xC + x1.bandwidth()/2)
            .attr("y1", y(q3)).attr("y2", y(hi)).attr("stroke","#333");

          // caps
          g.append("line").attr("x1", xC+2).attr("x2", xC + x1.bandwidth()-2)
            .attr("y1", y(lo)).attr("y2", y(lo)).attr("stroke","#333");
          g.append("line").attr("x1", xC+2).attr("x2", xC + x1.bandwidth()-2)
            .attr("y1", y(hi)).attr("y2", y(hi)).attr("stroke","#333");

        } else {
          // ----- VIOLIN -----
          const ymin = y.domain()[0], ymax = y.domain()[1];
          const thresholds = d3.range(ymin, ymax, (ymax - ymin)/60);
          const ker = v => kernelEpanechnikov(bw)(v);
          const density = kde(ker, thresholds, vals);
          const maxD = d3.max(density, d => d[1]) || 1;
          // Make them wide (wider than default)
          const widthScale = d3.scaleLinear().domain([0, maxD]).range([0, x1.bandwidth()/1.0]);

          const area = d3.area()
            .x0(d => xC + x1.bandwidth()/2 - widthScale(d[1]))
            .x1(d => xC + x1.bandwidth()/2 + widthScale(d[1]))
            .y (d => y(d[0]))
            .curve(d3.curveCatmullRom);

          g.append("path")
            .datum(density)
            .attr("class","violin")
            .attr("d", area)
            .attr("fill", color(ion))
            .attr("stroke", d3.color(color(ion)).darker(0.9));
        }

        // raw points (both modes)
        g.selectAll(`.dot-${ion.replace(/\W+/g,"")}`)
          .data(sub)
          .enter().append("circle")
            .attr("class","dot")
            .attr("cx", xC + x1.bandwidth()/2 + jitter(x1.bandwidth()*0.6))
            .attr("cy", d => y(d.log10sigma))
            .attr("r", 2.2)
            .attr("fill", d3.color(color(ion)).darker(0.3))
            .on("mouseover", (ev, d) => {
              tooltip.style("visibility","visible").html(
                `<b>${d.formula || "—"}</b><br>` +
                `Structure: ${d.structure || "—"}<br>` +
                `Ion: ${d.ion || "—"}<br>` +
                `σ: ${Number.isFinite(d.sigma) ? d.sigma.toExponential(3) : "—"} S·cm⁻¹<br>` +
                `log₁₀(σ): ${d.log10sigma.toFixed(3)}<br>` +
                (Number.isFinite(d.tempC) ? `Temp: ${d.tempC} °C` : ``)
              );
            })
            .on("mousemove", ev => tooltip.style("left",(ev.pageX+12)+"px").style("top",(ev.pageY-20)+"px"))
            .on("mouseout", () => tooltip.style("visibility","hidden"));
      });
    });

    statusEl.text(`Rows: ${rows.length} | Structures: ${structures.length} | Ions: ${ions.length} | Mode: ${mode.toUpperCase()} | BW: ${bw}`);
  }

  draw();
  modeSel.addEventListener("change", draw);
  bwSel.addEventListener("change", draw);
}).catch(err => {
  statusEl.text("Failed to load CSV. Serve over http(s) and check console.");
  console.error(err);
});
</script>
</body>
</html>
