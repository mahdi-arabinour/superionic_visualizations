<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Violin</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root { --side: 260px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#fafafa; color:#111; margin:24px; }
  h2 { margin:0 0 10px; }
  .toolbar { display:flex; gap:10px; align-items:center; margin:10px 0 14px; }
  .wrap { display:grid; grid-template-columns: 1fr var(--side); gap:16px; align-items:start; }
  svg { width: 980px; height: 640px; background:#fff; border:1px solid #e5e5e5; border-radius:10px; }
  .axis-label { font-size:14px; font-weight:600; fill:#222; }
  .grid line { stroke:#eee; }
  .violin { fill:#9aa3b2; fill-opacity:.25; stroke:#222; stroke-width:1px; }
  .point { stroke:#333; stroke-width:.4px; }
  .side { position:sticky; top:16px; background:#fff; border:1px solid #e5e5e5; border-radius:10px; padding:12px; }
  .legend-title { font-weight:700; font-size:14px; margin:6px 0; }
  .legend-controls { display:flex; gap:6px; margin: 4px 0 8px; }
  .legend-controls button { font-size:12px; padding:2px 6px; border:1px solid #ccc; background:#fff; cursor:pointer; border-radius:4px; }
  .legend-item { display:flex; align-items:center; gap:8px; margin:6px 0; cursor:pointer; user-select:none; }
  .legend-item.disabled { opacity:.35; text-decoration:line-through; }
  .legend-swatch { width:14px; height:14px; border-radius:3px; border:1px solid #444; }
  button.primary { padding:6px 10px; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
  .note { font-size:12px; color:#64748b; margin-top:6px; }
</style>
</head>
<body>

<h2>Violin + Deterministic Beeswarm — log10(σ) by Structure Group</h2>
<div class="toolbar">
  <button id="downloadBtn" class="primary">Download SVG</button>
  <span class="note">Points colored by Ion Type; stable beeswarm (no jumping on refresh).</span>
</div>

<div class="wrap">
  <svg></svg>

  <div class="side">
    <div class="legend-title">Ion Type (filter points)</div>
    <div class="legend-controls">
      <button id="showAll">Show all</button>
      <button id="hideAll">Hide all</button>
    </div>
    <div id="legend"></div>
  </div>
</div>

<script>
// ====== Column mapping (match your CSV headers) ======
const COL = {
  struct: "Structure Group",
  ion:    "Ion Type",
  sigma:  "Conductivity σ (S·cm⁻¹) / Temp (°C) normalized" // numeric; we plot log10 of actual σ if you have it
};

const svg = d3.select("svg");
const width = 980, height = 640;
const margin = {top: 40, right: 30, bottom: 80, left: 90};
const innerW = width - margin.left - margin.right;
const innerH = height - margin.top - margin.bottom;
const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
const fmt = d3.format(".4f");

// ====== Utilities: hashing & deterministic RNG ======
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967295;
  };
}
function stableRand01(key){
  const seed = xmur3(key)();
  const rand = mulberry32(seed);
  return rand();
}

// ====== Deterministic 1D beeswarm (dodge) along X within a band's half width ======
/*
  For each point, given its vertical position y (already mapped), we choose an x-offset so circles (radius r)
  do not overlap: (dx^2 + dy^2) >= (2r)^2. We place points near center, scanning left/right deterministically.
*/
function beeswarmXForGroup(points, centerX, halfWidth, r){
  // points: [{y, key, ...}] (y already in pixels). We’ll set .xOffset
  // Sort deterministically by y (then hashed key)
  points.sort((a,b) => (a.y - b.y) || d3.ascending(a.key, b.key));

  const placed = [];
  const diameter = 2*r;
  const diameter2 = diameter*diameter;

  function canPlace(x, y){
    for (const p of placed){
      const dx = x - p.x;
      const dy = y - p.y;
      if ((dx*dx + dy*dy) < diameter2) return false;
    }
    return true;
  }

  for (const pt of points){
    // prefer side based on hash to break symmetry consistently
    const sidePref = stableRand01(pt.key) < 0.5 ? -1 : 1;

    // scan offsets from center outwards
    let found = false;
    // start at 0 (center), then ±step, ±2*step, ...; step in pixels ≤ r
    const step = Math.max(1, Math.floor(r)); // conservative
    for (let k = 0; k <= halfWidth; k += step){
      const candidates = sidePref < 0 ? [-k, +k] : [+k, -k];
      for (const off of candidates){
        const x = centerX + off;
        // Keep inside band
        if (x < centerX - halfWidth || x > centerX + halfWidth) continue;
        if (canPlace(x, pt.y)){
          pt.x = x;
          placed.push({x, y: pt.y});
          found = true;
          break;
        }
      }
      if (found) break;
    }
    if (!found){
      // fallback: clamp to edge
      pt.x = Math.max(centerX - halfWidth, Math.min(centerX + halfWidth, centerX));
      placed.push({x: pt.x, y: pt.y});
    }
  }
  return points;
}

// ====== Load data ======
d3.csv("data.csv").then(raw => {
  // Parse rows
  const rows = raw.map(d => {
    const s = +d[COL.sigma]; // already normalized or numeric field; if you have raw σ, compute log10 upstream and use it here
    const val = Number.isFinite(s) && s > 0 ? s : null;
    return {
      structure: (d[COL.struct] || "Others").trim() || "Others",
      ion: (d[COL.ion] || "Unknown").trim() || "Unknown",
      sigma: val,
      // If you prefer log10(σ), change to Math.log10(raw_sigma) and map y accordingly
      logSig: Number.isFinite(val) ? Math.log10(val) : null
    };
  }).filter(d => d.logSig !== null);

  const structures = Array.from(new Set(rows.map(d => d.structure)));
  const ions = Array.from(new Set(rows.map(d => d.ion)));

  // Scales
  const x = d3.scaleBand().domain(structures).range([0, innerW]).padding(0.18);

  // y in log space (plotting log10 σ). If your COL.sigma is already log10, just use it directly.
  const y = d3.scaleLinear()
    .domain(d3.extent(rows, d => d.logSig)).nice()
    .range([innerH, 0]);

  // Axes & grid
  g.append("g").attr("transform", `translate(0,${innerH})`)
    .call(d3.axisBottom(x))
    .selectAll("text").attr("transform","rotate(-28)").style("text-anchor","end");

  const yAxis = d3.axisLeft(y)
    .ticks(8)
    .tickFormat(v => `10^${v}`);
  g.append("g").call(yAxis);
  g.append("g").attr("class","grid")
    .call(d3.axisLeft(y).ticks(8).tickSize(-innerW).tickFormat(""));

  g.append("text").attr("class","axis-label")
    .attr("x", innerW/2).attr("y", innerH+62).attr("text-anchor","middle")
    .text("Structure Group");
  g.append("text").attr("class","axis-label")
    .attr("x", -innerH/2).attr("y", -64).attr("transform","rotate(-90)")
    .attr("text-anchor","middle").text("log10(σ) (S/cm)");

  // Colors for points (Ion Type)
  const color = d3.scaleOrdinal().domain(ions).range(d3.schemeTableau10.slice(0, ions.length));

  // ====== (Optional) draw violins here if you already have KDE; omitted for brevity ======
  // ... your violin path code stays unchanged ...

  // ====== Deterministic beeswarm points ======
  const r = 3; // circle radius (px)
  const structCenter = Object.fromEntries(structures.map(sg => [sg, x(sg) + x.bandwidth()/2]));
  const halfWidth = x.bandwidth() * 0.45; // keep points within the interior of each violin

  // group rows by structure
  const grouped = d3.group(rows, d => d.structure);

  // Precompute beeswarm positions per group
  const positioned = [];
  for (const [sg, arr] of grouped){
    const center = structCenter[sg];
    // map to y pixels
    const pts = arr.map(d => ({
      ...d,
      y: y(d.logSig),
      key: `${d.structure}|${d.ion}|${d.sigma}` // stable key per point
    }));
    beeswarmXForGroup(pts, center, halfWidth, r + 1.2); // small buffer to avoid visual touching
    positioned.push(...pts);
  }

  // Build legend
  const legend = d3.select("#legend");
  let activeIons = new Set(ions);
  const items = legend.selectAll(".legend-item").data(ions).enter()
    .append("div").attr("class","legend-item");
  items.append("div").attr("class","legend-swatch").style("background", d => color(d));
  items.append("span").text(d => d);

  // Points layer
  const ptsSel = g.append("g").selectAll("circle.point")
    .data(positioned)
    .join("circle")
      .attr("class","point")
      .attr("r", r)
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .attr("fill", d => color(d.ion))
      .attr("display", d => activeIons.has(d.ion) ? null : "none");

  function updatePoints(){
    ptsSel.attr("display", d => activeIons.has(d.ion) ? null : "none");
  }

  items.on("click", function(_, ion){
    if (activeIons.has(ion)) activeIons.delete(ion); else activeIons.add(ion);
    d3.select(this).classed("disabled", !activeIons.has(ion));
    updatePoints();
  });
  d3.select("#showAll").on("click", () => {
    activeIons = new Set(ions);
    items.classed("disabled", false);
    updatePoints();
  });
  d3.select("#hideAll").on("click", () => {
    activeIons.clear();
    items.classed("disabled", true);
    updatePoints();
  });

  // Download SVG
  document.getElementById("downloadBtn").addEventListener("click", () => {
    const s = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([s], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement("a"), {href:url, download:"violin_beeswarm_log10_sigma.svg"});
    a.click();
  });
});
</script>
</body>
</html>
