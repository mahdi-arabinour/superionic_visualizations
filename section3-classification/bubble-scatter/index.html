<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Superionic Conductors — Ea ≤ 0.6 · Ea vs σ (log Y)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { --bg:#ffffff; --panel:#f8f9fa; --grid:#dcdcdc; --text:#111; --panel-border:#cccccc; --note:#555; --accent:#007aff; }
  * { box-sizing:border-box; }
  body { margin:0; font-family:system-ui, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--text); }

  header {
    display:flex; flex-wrap:wrap; gap:12px; align-items:center;
    padding:8px 12px; background:var(--panel); border-bottom:1px solid var(--panel-border);
    position:sticky; top:0; z-index:10;
  }
  label { display:flex; align-items:center; gap:6px; font-size:12px; }
  .slider-container { display:flex; align-items:center; gap:6px; font-size:12px; }
  input[type="range"] { width:160px; }
  .badge { font-size:11px; color:var(--note); margin-left:auto; }

  .wrap { display:grid; grid-template-columns: 1fr 280px; gap:10px; padding:10px; }
  #chart { width:100%; height:90vh; border:1px solid var(--grid); border-radius:8px; background:#fff; }

  aside {
    background:var(--panel); border:1px solid var(--panel-border);
    border-radius:8px; padding:10px; font-size:12px;
  }
  aside h3 { margin:0 0 8px 0; font-size:13px; color:#000; }

  /* Right legend (Structure Groups) */
  #structureLegend .row{
    display:flex; align-items:center; gap:8px;
    padding:6px 8px; margin:5px 0; border-radius:8px;
    background:#fff; border:1px solid #ddd; cursor:pointer; user-select:none;
  }
  #structureLegend .row.active{ outline:2px solid var(--accent); }
  #structureLegend .swatch{ width:12px; height:12px; border-radius:3px; border:1px solid #0002; }
  #structureLegend .name{ color:#000; font-size:12px; }
  #structureLegend .count{ margin-left:auto; color:#555; font-size:11px; }

  /* Error banner */
  #error { display:none; margin:8px 12px; padding:8px 12px; background:#fff3f3; color:#7f1d1d; border:1px solid #f5c2c2; border-radius:8px; white-space:pre-wrap; }
</style>
</head>
<body>
  <header>
    <div class="slider-container" title="Global marker size (fixed for all points)">
      <label for="sizeScale">Marker size:</label>
      <input type="range" id="sizeScale" min="6" max="36" value="16" step="1">
      <span id="scaleVal">16 px</span>
    </div>

    <label>
      Color by:
      <select id="colorBy">
        <option value="ion" selected>Ion</option>
        <option value="struct">Structure</option>
      </select>
    </label>

    <span class="badge" id="status">Loading data.csv…</span>
  </header>

  <div id="error"></div>

  <div class="wrap">
    <div id="chart"></div>
    <aside>
      <h3>Structure Group (filter)</h3>
      <div id="structureLegend"></div>
    </aside>
  </div>

<script>
/* ---------- Status & error ---------- */
const statusEl = document.getElementById("status");
const errorEl  = document.getElementById("error");
function say(msg){ statusEl.textContent = msg; }
function err(msg){ errorEl.style.display='block'; errorEl.textContent = msg; console.error(msg); }

/* ---------- Palettes (YOUR colors) ---------- */
const ION_COLORS = {
  "Li+":  "#ff5252","Na+":  "#81d4fa","K+":   "#004d40","Ag+":  "#f48fb1",
  "O2-":  "#6d4c41","Zn2+": "#c2185b","H+":   "#ffd54f","Rb+":  "#43a047",
  "F-":   "#ff8a65","Cu+":  "#5c6bc0","Mg2+": "#26c6da","In3+": "#c0ca33",
  "I-":   "#ec407a","Sn4+": "#7e57c2"
};
const STRUCT_COLORS = {
  "Others":"#9e9e9e","Polymeric":"#ff7043","Argyrodite":"#ab47bc","Halide":"#26a69a",
  "Amorphous":"#f6bf26","NASICON":"#66bb6a","Anti-perovskite":"#0d47a1","Spinel":"#8d6e63"
};
const FallbackIonPalette = Plotly.d3.schemeTableau10 || [
  "#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f","#edc949","#af7aa1","#ff9da7","#9c755f","#bab0ac"
];
const norm = s => (s ?? "").toString().trim();
function getIonColor(ion){
  const k = norm(ion);
  if (ION_COLORS[k]) return ION_COLORS[k];
  const h = Math.abs([...k].reduce((a,c)=>a*31+c.charCodeAt(0),7));
  return FallbackIonPalette[h % FallbackIonPalette.length];
}
function getStructColor(g){ return STRUCT_COLORS[norm(g)] || "#999"; }

/* Marker symbol palette for auto-assigning unique shapes per ion */
const SHAPE_PALETTE = [
  "circle","square","diamond","triangle-up","triangle-down","triangle-left","triangle-right",
  "cross","x","star","hexagon","hexagon2","bowtie","hourglass","circle-open","square-open",
  "diamond-open","triangle-up-open","triangle-down-open","cross-thin","x-thin","asterisk"
];

/* ---------- Fixed column names ---------- */
const COLS = {
  ion: "Ion Type",
  structGrouped: "Structure Group",
  ea: "Activation Energy Ea (eV)",
  sigma: "Conductivity σ (S/cm)",
  formula: "Superionic Conductor Formula (Chemical)"
};

/* ---------- State ---------- */
let rowsGlobal = [];
let traceMeta = [];               // per DATA trace: {ion, fam}
let activeStructGroup = null;     // sidebar filter (mutually exclusive with activeIon)
let activeIon = null;             // legend filter (mutually exclusive with activeStructGroup)
let markerSizePx = 16;
let ionSymbolMap = {};            // ion -> marker symbol
let colorBy = 'ion';              // 'ion' | 'struct'

// Legend mapping: name -> stub trace index
let legendStubIndexMap = {};    

/* ---------- Utils ---------- */
function toNum(v){
  if (typeof v === "number") return v;
  if (v == null) return NaN;
  const s = String(v).trim();
  if (!s || s.toLowerCase()==="na" || s.toLowerCase()==="n/a" || s==="—" || s==="–") return NaN;
  const n = Number(s.replace(/,/g,""));
  return Number.isFinite(n) ? n : NaN;
}

/* ---------- Build traces ---------- */
/* DATA traces: one per row, colored by colorBy (ion/struct), showlegend:false */
function buildDataTraces(filteredRows){
  const traces=[]; traceMeta=[];
  filteredRows.forEach(r=>{
    const ion = norm(r[COLS.ion] || "Other") || "Other";
    const fam = norm(r[COLS.structGrouped] || "Others") || "Others";
    const ea  = toNum(r[COLS.ea]);
    const sig = toNum(r[COLS.sigma]);

    const color = (colorBy === 'ion') ? getIonColor(ion) : getStructColor(fam);
    const symbol = ionSymbolMap[ion] || "circle-open";

    traces.push({
      x:[ea], y:[sig], mode:"markers",
      name: (colorBy === 'ion') ? ion : fam,
      legendgroup: (colorBy === 'ion') ? ion : fam,
      showlegend: false, // legend is generated by stub traces
      marker:{
        size:[markerSizePx],
        color,
        symbol,                 // shape by Ion, even when colored by Structure
        line:{ width:1.0, color:"#000" },
        opacity: 0.9
      },
      text:[`${r[COLS.formula]||"(formula)"}<br>Ion: ${ion}<br>Structure: ${fam}`],
      hovertemplate:"<b>%{text}</b><br> Ea: %{x:.3f} eV<br> σ: %{y:.3e} S/cm<extra></extra>",
      visible: true
    });
    traceMeta.push({ ion, fam });
  });
  return traces;
}

/* LEGEND stubs: Ion or Structure depending on colorBy */
function buildLegendStubs(names){
  return names.map(name=>{
    const color = (colorBy === 'ion') ? getIonColor(name) : getStructColor(name);
    const symbol = (colorBy === 'ion')
      ? (ionSymbolMap[name] || "circle-open")
      : "circle"; // neutral symbol for structure legend
    return {
      x:[NaN], y:[NaN], mode:"markers",
      name, legendgroup:name, showlegend:true,
      marker:{
        size:[markerSizePx],
        color,
        symbol,
        line:{ width:1.0, color:"#000" },
        opacity: 1
      },
      hoverinfo:"skip",
      visible:true
    };
  });
}

/* ---------- Structure (right) legend ---------- */
function renderStructureLegend(filteredRows){
  const el = document.getElementById("structureLegend");
  if(!el) return;
  el.innerHTML = "";

  const counts = {};
  filteredRows.forEach(r=>{
    const g = norm(r[COLS.structGrouped] || "Others") || "Others";
    counts[g] = (counts[g] || 0) + 1;
  });

  const KNOWN = ["Amorphous","Anti-perovskite","Argyrodite","Halide","NASICON","Spinel","Polymeric","Others"];
  const present = Object.keys(counts);
  const order = [...KNOWN.filter(x=>present.includes(x)), ...present.filter(x=>!KNOWN.includes(x)).sort()];

  order.forEach(g=>{
    const row = document.createElement("div");
    row.className = "row";
    row.dataset.group = g;

    const sw = document.createElement("div");
    sw.className = "swatch";
    sw.style.background = getStructColor(g);

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = g;

    const count = document.createElement("div");
    count.className = "count";
    count.textContent = counts[g] || 0;

    row.append(sw, name, count);
    row.onclick = ()=>{
      // Toggle: click selects; click again resets to "show all"
      activeStructGroup = (activeStructGroup === g) ? null : g;

      // Mutual exclusivity: clear ion filter
      activeIon = null;

      // Highlight active group
      Array.from(el.children).forEach(ch=>ch.classList.toggle("active", ch.dataset.group === (activeStructGroup||"")));

      applyFilters();
    };
    el.appendChild(row);
  });
}

/* ---------- Apply filters ---------- */
function applyFilters(){
  if(!traceMeta.length) return;

  const nData = traceMeta.length;
  const showAll = !activeStructGroup && !activeIon;

  // Visibility for DATA traces
  const visData = traceMeta.map(meta=>{
    if (showAll) return true;
    if (activeIon) return meta.ion === activeIon;
    if (activeStructGroup) return meta.fam === activeStructGroup;
    return true;
  });

  const dataIdx = Array.from({length:nData}, (_,i)=>i);
  Plotly.restyle("chart", { visible: visData.map(v=>v?true:"legendonly") }, dataIdx);

  // Legend stubs visibility must reflect the currently visible data
  const visibleNames = new Set();
  traceMeta.forEach((m, i)=>{
    if (visData[i] === true){
      visibleNames.add( (colorBy==='ion') ? m.ion : m.fam );
    }
  });

  const stubUpdates = { visible: [] };
  const stubIdx = [];
  Object.entries(legendStubIndexMap).forEach(([name, idx])=>{
    stubIdx.push(idx);
    stubUpdates.visible.push( visibleNames.has(name) ? true : false );
  });
  if (stubIdx.length){
    Plotly.restyle("chart", stubUpdates, stubIdx);
  }

  // Update legend title to match mode
  Plotly.relayout('chart', {
    'legend.title.text': (colorBy === 'ion') ? 'Ion Type (color & shape)' : 'Structure Group (color)'
  });
}

/* ---------- Draw ---------- */
function draw(){
  // Base filter: valid numeric values and Ea ≤ 0.6 (and σ>0)
  const filtered = rowsGlobal.filter(r=>{
    const ea = toNum(r[COLS.ea]);
    const s  = toNum(r[COLS.sigma]);
    return Number.isFinite(ea) && ea <= 0.6 && Number.isFinite(s) && s > 0;
  });

  say(`Rows: ${rowsGlobal.length} · Ions: ${Object.keys(ionSymbolMap).length} · Plotted: ${filtered.length} (Ea ≤ 0.6, σ>0) · Color by ${colorBy}`);

  // Build data traces
  const dataTraces = buildDataTraces(filtered);
  renderStructureLegend(filtered);

  // Build legend stubs for PRESENT categories under current mode
  let legendNames;
  if (colorBy === 'ion'){
    legendNames = Array.from(new Set(filtered.map(r => norm(r[COLS.ion] || "Other") || "Other")));
  } else {
    legendNames = Array.from(new Set(filtered.map(r => norm(r[COLS.structGrouped] || "Others") || "Others")));
  }
  const legendStubs = buildLegendStubs(legendNames);

  const traces = [...dataTraces, ...legendStubs];

  Plotly.newPlot("chart", traces, {
    paper_bgcolor:"#fff", plot_bgcolor:"#fff",
    xaxis:{
      title:"Activation Energy Ea (eV)",
      range:[0.05, 0.6],
      tickformat:".2f",
      tickmode:"linear",
      tick0:0.10,
      dtick:0.05,
      gridcolor:"#e9e9e9",
      zerolinecolor:"#e9e9e9",
      titlefont:{size:12},
      tickfont:{size:10}
    },
    yaxis:{
      title:"Conductivity σ (S/cm)",
      type:"log",
      gridcolor:"#e9e9e9",
      zerolinecolor:"#e9e9e9",
      titlefont:{size:12},
      tickfont:{size:10},
      tickmode: "array",
      tickvals: [
        1e-9, 2e-9, 5e-9,
        1e-8, 2e-8, 5e-8,
        1e-7, 2e-7, 5e-7,
        1e-6, 2e-6, 5e-6,
        1e-5, 2e-5, 5e-5,
        1e-4, 2e-4, 5e-4,
        1e-3, 2e-3, 5e-3,
        1e-2, 2e-2, 5e-2,
        1e-1, 2e-1, 5e-1,
        1, 2, 5, 10, 20, 50, 100
      ],
      ticktext: [
        "1e−9","2e−9","5e−9",
        "1e−8","2e−8","5e−8",
        "1e−7","2e−7","5e−7",
        "1e−6","2e−6","5e−6",
        "1e−5","2e−5","5e−5",
        "1e−4","2e−4","5e−4",
        "1e−3","2e−3","5e−3",
        "0.01","0.02","0.05",
        "0.1","0.2","0.5",
        "1","2","5","10","20","50","100"
      ],
    },
    legend:{
      title:{text:(colorBy==='ion'?'Ion Type (color & shape)':'Structure Group (color)'), font:{size:11, color:"#111"}},
      font:{size:10, color:"#111"},
      orientation:"h",
      x:0.5, xanchor:"center", y:1.08,
      itemclick:"toggle",
      groupclick:"togglegroup",
      traceorder:"normal",
      bgcolor:"#fff",
      bordercolor:"#ddd",
      borderwidth:0.5
    },
    margin:{t:54, r:20, b:54, l:64}
  }, {
    responsive:true, displaylogo:false, modeBarButtonsToRemove:["select2d","lasso2d"]
  }).then(()=>{
    const gd = document.getElementById('chart');

    // Record where current legend stubs live (after the data traces)
    legendStubIndexMap = {};
    const nData = traceMeta.length;
    legendNames.forEach((name, k)=>{ legendStubIndexMap[name] = nData + k; });

    /* Fast hover fade for DATA traces */
    gd.on('plotly_hover', (ev)=>{
      const n = traceMeta.length;
      const op = Array(n).fill(0.15);
      ev.points.forEach(p=>{ if (p.curveNumber < n) op[p.curveNumber] = 0.95; });
      const idx = Array.from({length:n}, (_,i)=>i);
      Plotly.restyle('chart', { 'marker.opacity': op }, idx);
    });
    gd.on('plotly_unhover', ()=>{
      const n = traceMeta.length;
      const idx = Array.from({length:n}, (_,i)=>i);
      Plotly.restyle('chart', { 'marker.opacity': Array(n).fill(0.9) }, idx);
    });

    /* Legend click: toggle filter for the *current* category */
    gd.on('plotly_legendclick', (ev)=>{
      const tr = gd.data[ev.curveNumber];
      const isStub = Array.isArray(tr.x) && tr.x.length===1 && !Number.isFinite(tr.x[0]);
      if (isStub) {
        const clickedName = tr.name || null;
        if (colorBy === 'ion'){
          activeIon = (activeIon === clickedName) ? null : clickedName;
          activeStructGroup = null; // clear other filter
        } else {
          activeStructGroup = (activeStructGroup === clickedName) ? null : clickedName;
          activeIon = null;
        }

        // Clear sidebar highlight when legend is used
        if (colorBy === 'struct'){
          const el = document.getElementById("structureLegend");
          if (el) Array.from(el.children).forEach(ch=>ch.classList.toggle("active", ch.dataset.group === (activeStructGroup||"")));
        } else {
          const el = document.getElementById("structureLegend");
          if (el) Array.from(el.children).forEach(ch=>ch.classList.remove("active"));
        }

        applyFilters();
        return false; // prevent default legend hide
      }
      return true;
    });

    /* Legend double-click: reset everything */
    gd.on('plotly_legenddoubleclick', ()=>{
      activeIon = null;
      activeStructGroup = null;
      const el = document.getElementById("structureLegend");
      if (el) Array.from(el.children).forEach(ch=>ch.classList.remove("active"));
      applyFilters();
      return false;
    });

    // Initial sync
    applyFilters();
  });
}

/* ---------- CSV load ---------- */
function loadCsv(){
  fetch("data.csv", { cache:"no-store" })
    .then(resp => { if(!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`); return resp.text(); })
    .then(text=>{
      Papa.parse(text, {
        header:true, dynamicTyping:false, skipEmptyLines:true,
        complete:(res)=>{
          if(!res.data || !res.data.length){ say("Parsed CSV but found no rows."); return; }

          // validate required columns
          const cols=res.meta.fields||[];
          const must=[COLS.ion,COLS.structGrouped,COLS.ea,COLS.sigma,COLS.formula];
          const missing=must.filter(m=>!cols.includes(m));
          if(missing.length){ err("Missing required columns: "+missing.join(", ")); return; }

          rowsGlobal = res.data;
          activeStructGroup = null;
          activeIon = null;

          // Auto-assign a unique symbol per ion present in ALL rows
          const uniqueIons = Array.from(new Set(rowsGlobal.map(r => norm(r[COLS.ion] || "Other") || "Other")));
          ionSymbolMap = {};
          let shapeIdx = 0;
          uniqueIons.forEach(ion => {
            ionSymbolMap[ion] = SHAPE_PALETTE[shapeIdx % SHAPE_PALETTE.length];
            shapeIdx += 1;
          });

          draw();
        },
        error:(e)=>{ err("Parse error: " + e.message); }
      });
    })
    .catch(e=>{
      const onGitHubViewer = location.hostname === 'github.com';
      const hint = onGitHubViewer
        ? "You’re viewing this on github.com (scripts blocked). Publish via GitHub Pages or open via a local server."
        : "Ensure data.csv is in the same folder and the page is served via http(s).";
      err(`Could not load CSV: ${e.message}\n\n${hint}`);
    });
}

/* ---------- Controls ---------- */
const sizeScaleEl = document.getElementById("sizeScale");
sizeScaleEl.addEventListener("input", ()=>{
  markerSizePx = parseInt(sizeScaleEl.value, 10) || 16;
  document.getElementById("scaleVal").textContent = markerSizePx + " px";
  draw();
});

const colorByEl = document.getElementById("colorBy");
colorByEl.addEventListener("change", ()=>{
  colorBy = colorByEl.value === 'struct' ? 'struct' : 'ion';
  // Reset filters when switching mode (to avoid conflicting state)
  activeIon = null;
  activeStructGroup = null;
  const el = document.getElementById("structureLegend");
  if (el) Array.from(el.children).forEach(ch=>ch.classList.remove("active"));
  draw();
});

/* ---------- Kick off ---------- */
loadCsv();
</script>
</body>
</html>
