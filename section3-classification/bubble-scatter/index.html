<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Superionic Conductors — Ea≤0.8 · Ea vs σ (log Y)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { --bg:#ffffff; --panel:#171a20; --grid:#dcdcdc; --text:#111111; --muted:#93c5fd; --accent:#60a5fa; }
  * { box-sizing: border-box; }
  body { margin:0; font-family:system-ui,Segoe UI,Roboto,sans-serif; background:var(--bg); color:var(--text); }
  header { display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:8px 12px; background:var(--panel); border-bottom:1px solid var(--grid); position:sticky; top:0; z-index:10; }
  .wrap { display:grid; grid-template-columns: 1fr 220px 160px; gap:8px; padding:8px; }
  #chart { width:100%; height:90vh; border:1px solid var(--grid); border-radius:8px; background:#ffffff; }
  .badge { font-size:11px; color:var(--muted); }
  label { display:flex; align-items:center; gap:6px; font-size:12px; }
  input[type="checkbox"] { transform: translateY(1px); }
  .slider-container { display:flex; align-items:center; gap:6px; font-size:12px; }
  input[type="range"] { width:150px; }

  /* Side panels */
  aside { background:var(--panel); border:1px solid var(--grid); border-radius:8px; padding:8px; min-height:100px; font-size:11px; }
  aside h3 { margin:0 0 4px 0; font-size:12px; color:#cbd5e1; }

  /* --- NEW: compact legend rows for Structure --- */
  #structureAccordion .legend-row{
    display:flex; align-items:center; gap:8px;
    padding:4px 6px; margin:3px 0; border-radius:8px; cursor:pointer;
    background:#1c212b;
  }
  #structureAccordion .legend-row.active{
    outline:1px solid #dcdcdc;
  }
  #structureAccordion .swatch{ width:12px; height:12px; border-radius:3px; border:1px solid #0007; }
  #structureAccordion .name{ font-size:12px; color:#cbd5e1; }
  #structureAccordion .count{ margin-left:auto; font-size:11px; color:#94a3b8; }

  /* Size legend (Cycle) — unchanged from your file */
  .size-row { display:flex; align-items:center; gap:6px; margin:2px 0; cursor:pointer; }
  .size-row.active { outline:1px solid #dcdcdc; border-radius:8px; background:#1c212b; }
  .size-dot { border-radius:50%; background:#93c5fd22; border:1px solid #93c5fd88; }
  .size-dot.missing { background:#ef444422; border-color:#ef4444aa; }
  .size-label { font-size:11px; color:#cbd5e1; }

  /* Error banner */
  #error { display:none; margin:8px 12px; padding:8px 12px; background:#2b1111; color:#fecaca; border:1px solid #7f1d1d; border-radius:8px; white-space:pre-wrap; }
</style>
</head>
<body>
  <header>
    <label title="(Data are filtered to Ea ≤ 0.8)">
      <input type="checkbox" id="clampX" /> Clamp Ea axis to [0.05, 1.0]
    </label>
    <label><input type="checkbox" id="hiOut" /> Highlight Ea &gt; 0.7 eV</label>

    <div class="slider-container" title="Marker size scale">
      <label for="sizeScale">Size:</label>
      <input type="range" id="sizeScale" min="0.5" max="5" value="1.2" step="0.1">
      <span id="scaleVal">1.2×</span>
    </div>
    <div class="slider-container" title="Spread horizontally (Ea)">
      <label for="jx">X spread:</label>
      <input type="range" id="jx" min="0" max="0.05" value="0.02" step="0.001">
      <span id="jxVal">0.020 eV</span>
    </div>
    <div class="slider-container" title="Spread vertically (σ, % of value)">
      <label for="jy">Y spread:</label>
      <input type="range" id="jy" min="0" max="15" value="8" step="0.5">
      <span id="jyVal">8%</span>
    </div>

    <span class="badge" id="status">Loading data.csv…</span>
  </header>

  <div id="error"></div>

  <div class="wrap">
    <div id="chart"></div>

    <aside>
      <h3>Structure (color) — click to isolate</h3>
      <div id="structureAccordion"></div>
    </aside>

    <aside>
      <h3>Size (Cycle Life) — click to filter</h3>
      <div id="sizeLegend"></div>
      <div style="margin-top:4px; font-size:10.5px; color:#9aa4b2;">
        Area ~ log<sub>10</sub>(cycles+1) × scale · Missing cycles → fixed size
      </div>
    </aside>
  </div>

<script>
/* ---------- status & error ---------- */
const statusEl = document.getElementById("status");
const errorEl  = document.getElementById("error");
function say(msg){ statusEl.textContent = msg; }
function err(msg){ errorEl.style.display='block'; errorEl.textContent = msg; console.error(msg); }

/* ---------- palettes & encodings (unchanged) ---------- */
const structColors = {
  "Antiperovskite":"#e15759", "Perovskite":"#f28e2b", "Garnet":"#59a14f",
  "LISICON":"#4e79a7", "NASICON":"#76b7b2", "Argyrodite":"#af7aa1",
  "Halide":"#edc949", "Sulfide":"#ff9da7", "Closo-carbaborate":"#9c755f",
  "Nitride":"#b07aa1", "Phosphate":"#86bc86", "Silicide":"#a0cbe8",
  "Polymer composite":"#8cd17d", "Other / Novel":"#9e9e9e", "Other":"#9e9e9e"
};
const ionSymbols = {
  "Li+":"circle", "Na+":"square", "K+":"diamond", "Mg2+":"triangle-up",
  "Ca2+":"triangle-down", "H+":"x", "Ag+":"star", "Zn2+":"cross",
  "Other":"circle-open"
};

/* ---------- EXACT groups you want (NEW) ---------- */
const STRUCT_GROUPS = [
  "Amorphous","Anti-perovskite","Argyrodite","Halide","NASICON","Spinel","Polymeric","Other"
];

/* Map free-text structure names to those 7 buckets (NEW) */
function groupStructure(s) {
  const t = String(s || '')
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .trim();

  if (/amorph|glass-?ceramic|glass/.test(t))               return "Amorphous";
  if (/anti[\s-]?perovsk/.test(t))                         return "Anti-perovskite"; // will catch "Antiperovskite"
  if (/argyrodit/.test(t))                                 return "Argyrodite";
  if (/\bhalide\b|oxyhalide|chloride|fluoride|bromide|iodide/.test(t)) return "Halide";
  if (/\bnasicon\b|\bna[\s-]?sicon\b/.test(t))             return "NASICON";
  if (/\bspinel\b/.test(t))                                return "Spinel";
  if (/polymer|polymeric/.test(t))                         return "Polymeric";
  return "Other";
}

/* ---------- columns ---------- */
const C = {
  ion:["Ion Type (Normalized)","Ion Type","Ion"],
  structFam:["Structure Family (Canonical)","Structure Group (Canonical)","Structure"],
  structRaw:["Structure Type","Structure (raw)","Raw Structure","Structure Label","Structure"],
  ea:["Activation Energy Ea (eV)  [smart parsed]","Activation Energy Ea (eV)","Ea","Activation Energy Ea (eV) "],
  sigma:["Conductivity σ (S/cm) [numeric]","Conductivity σ (S·cm⁻¹) [numeric]","Conductivity","sigma","Conductivity (S·cm⁻¹)"],
  cycles:["Cycle Life (numeric)","Cycle Life (raw)","Cycles","Cycle Life"],
  formula:["superionic conductor Formula (Chemical)","Formula"]
};
function guessCol(cols, candidates){
  const map = Object.fromEntries(cols.map(c=>[c.toLowerCase(), c]));
  for(const name of candidates){ if(map[name.toLowerCase()]) return map[name.toLowerCase()]; }
  for(const c of cols){ const lc=c.toLowerCase(); if(candidates.some(n=>lc.includes(n.toLowerCase()))) return c; }
  return null;
}
function toNum(v){
  if(typeof v==="number") return v;
  if(!v) return NaN;
  const s=String(v).trim();
  if(s==="–"||s==="—"||s.toLowerCase()==="na"||s.toLowerCase()==="n/a") return NaN;
  const n=Number(s.replace(/,/g,""));
  if(Number.isFinite(n)) return n;
  const m=s.match(/([+-]?\d*\.?\d+(?:[eE][+-]?\d+)?)/);
  return m?Number(m[1]):NaN;
}

/* ---------- size mapping & cycle buckets (unchanged) ---------- */
let sizeScaleFactor=1.2;
const MISSING_CYCLE_BASE = 15;
function cycleSize(cycles){
  const cyc = toNum(cycles);
  if(!Number.isFinite(cyc) || cyc <= 0) return MISSING_CYCLE_BASE * sizeScaleFactor;
  return Math.max(15, Math.min(95, Math.log10(cyc + 1) * 13.5 * sizeScaleFactor));
}
function parseCycle(raw){
  if (raw == null) return null;
  const s = String(raw);
  const m = s.match(/(\d[\d,]*)/);
  if (!m) return null;
  return Number(m[1].replace(/,/g,''));
}
const cycleBreaks = [0,100,500,1000,1500,2000,2500,3000,4000,5000,7500,10000];
function bucketCodeFromCycles(raw){
  const n = parseCycle(raw);
  if (n == null || !Number.isFinite(n)) return "NA";
  for (let i=0;i<cycleBreaks.length-1;i++){
    const a = cycleBreaks[i], b = cycleBreaks[i+1];
    if ((i===0 && n>=a && n<=b) || (i>0 && n>a && n<=b)) return "B"+i;
  }
  return "GT";
}
function bucketLabelByCode(code){
  if (code === "ALL") return "All";
  if (code === "NA") return "N/A";
  if (code === "GT") return ">10000";
  const i = Number(code.slice(1));
  const a = cycleBreaks[i], b = cycleBreaks[i+1];
  return (i===0) ? "0–100" : `${a+1}–${b}`;
}

/* ---------- jitter & utils (unchanged) ---------- */
function hashToUnit(str){ let h=0; for(let i=0;i<str.length;i++){ h=((h<<5)-h)+str.charCodeAt(i); h|=0; } return (Math.abs(h)%100000)/100000; }
let JX = 0.02;      // eV
let JY_FRAC = 0.08; // fraction
function jitteredEa(ea, key){ const u=hashToUnit(key+"|x"); return ea + (u-0.5)*2*JX; }
function jitteredSigma(sig, key){ const u=hashToUnit(key+"|y"); return sig * (1 + (u-0.5)*2*JY_FRAC); }
function xRangeAuto(xs){ if(!xs.length) return [0.05,0.8]; const min=Math.min(...xs), max=Math.max(...xs); if(!isFinite(min)||!isFinite(max)||min===max) return [0.05,0.8]; const pad=(max-min)*0.10; return [Math.max(0,min-pad), max+pad]; }

/* ---------- filtering / legends ---------- */
let last = null;                // { rows, cols }
let traceMeta = [];             // [{ion, fam, bucket}, ...]
let activeFamily = null;        // (kept for compatibility)
let activeCycle  = null;        // cycle bucket filter
let activeFamilyGroup = null;   // NEW: grouped name we toggle via legend

function setFamilyLegendActive(familyGrouped){
  const container = document.getElementById("structureAccordion");
  Array.from(container.querySelectorAll(".legend-row")).forEach(child=>{
    child.classList.toggle("active", child.dataset.family === familyGrouped);
  });
}

/* Toggle isolation via legend click — keeps your flow */
function onFamilyClick(familyGrouped){
  activeFamilyGroup = (activeFamilyGroup === familyGrouped) ? null : familyGrouped;
  setFamilyLegendActive(activeFamilyGroup || "");
  applyCombinedFilter();
}

function onCycleLegendClick(bucket){
  activeCycle = (activeCycle === bucket) ? null : bucket;
  highlightCycleLegendActive();
  applyCombinedFilter();
}

function applyCombinedFilter(){
  if (!traceMeta.length) return;
  const vis = traceMeta.map(meta=>{
    const famGroupOfTrace = groupStructure(meta.fam); // <-- key change: compare by grouped label
    const okFamily = activeFamilyGroup ? (famGroupOfTrace === activeFamilyGroup) : true;
    const okCycle  = activeCycle  ? (meta.bucket === activeCycle) : true;
    return (okFamily && okCycle) ? true : "legendonly";
  });
  Plotly.restyle("chart", {visible: vis});
}

/* ---------- build traces + legend (unchanged except meta tagging) ---------- */
function buildTraces(rows, cols, hiOut){
  const traces=[]; const ionsSeen=new Set(); const allX=[]; const famSet=new Set();
  traceMeta = [];
  let stats={total:0,skippedEa:0,skippedSigma:0,plotted:0,missingCycles:0};
  rows.forEach(r=>{
    stats.total++;
    const ion=(r[cols.ion]||"Other").toString().trim()||"Other";
    const fam=(r[cols.structFam]||"Other / Novel").toString().trim()||"Other / Novel";
    const ea_raw=toNum(r[cols.ea]); const sigma_raw=toNum(r[cols.sigma]); const cycRaw=r[cols.cycles];
    const cyc=toNum(cycRaw);
    if(!Number.isFinite(ea_raw) || ea_raw > 0.8){ stats.skippedEa++; return; }
    if(!Number.isFinite(sigma_raw) || sigma_raw <= 0){ stats.skippedSigma++; return; }
    if(!Number.isFinite(cyc) || cyc <= 0){ stats.missingCycles++; }
    const key = `${ion}|${fam}|${r[cols.formula]||""}`;
    const ea = jitteredEa(ea_raw, key);
    const sigma = jitteredSigma(sigma_raw, key);

    const bucketCode = bucketCodeFromCycles(cycRaw);

    stats.plotted++; allX.push(ea); famSet.add(fam);
    traces.push({
      x:[ea], y:[sigma], customdata:[sigma_raw], mode:"markers",
      name: ion, legendgroup: ion, showlegend: !ionsSeen.has(ion),
      marker:{
        size:[cycleSize(cyc)],
        color: structColors[fam] || structColors["Other / Novel"],
        symbol: ionSymbols[ion] || ionSymbols["Other"],
        line:{ width:[(hiOut && ea_raw>0.7)? 2 : 0.7], color:[(hiOut && ea_raw>0.7)? "#ff4d4d" : "#222"] },
        opacity:0.88
      },
      text:[`${r[cols.formula]||"(formula)"}<br>Ion: ${ion}<br>Structure: ${fam}<br>Cycles: ${Number.isFinite(cyc)?cyc:"(missing)"} (${bucketLabelByCode(bucketCode)})`],
      hovertemplate:"<b>%{text}</b><br> Ea: %{x:.3f} eV (jittered)<br> σ: %{customdata:.3e} S/cm<extra></extra>",
      visible: true
    });
    traceMeta.push({ion, fam, bucket: bucketCode}); ionsSeen.add(ion);
  });
  return {data:traces,allX,stats,families:Array.from(famSet).sort()};
}

/* ---------- SIZE legend (unchanged UI) ---------- */
function buildSizeLegend(){
  const wrap=document.getElementById("sizeLegend"); wrap.innerHTML="";

  function addRow(label, px, code, isMissing=false){
    const row=document.createElement("div");
    row.className="size-row"; row.dataset.bucket = code;
    const dot=document.createElement("div");
    dot.className="size-dot"+(isMissing?" missing":"");
    dot.style.width=px+"px"; dot.style.height=px+"px";
    const lab=document.createElement("div"); lab.className="size-label"; lab.textContent=label;
    row.appendChild(dot); row.appendChild(lab);
    row.addEventListener("click", ()=> onCycleLegendClick(code));
    wrap.appendChild(row);
  }

  addRow("No cycle data (fixed size)", cycleSize(null), "NA", true);
  const samples = {B0:80,B1:300,B2:800,B3:1200,B4:1700,B5:2200,B6:2700,B7:3200,B8:4500,B9:6000,B10:9000,GT:15000};
  for (let i=0;i<cycleBreaks.length-1;i++){
    const code = "B"+i;
    addRow(bucketLabelByCode(code), cycleSize(samples[code]), code);
  }
  addRow(bucketLabelByCode("GT"), cycleSize(samples["GT"]), "GT");
  highlightCycleLegendActive();
}
function highlightCycleLegendActive(){
  const nodes = Array.from(document.querySelectorAll("#sizeLegend .size-row"));
  nodes.forEach(n => n.classList.toggle("active", n.dataset.bucket === activeCycle));
}

/* ---------- Structure legend renderer (REPLACED) ---------- */
function renderStructureAccordion(_families, rows, cols){
  // Count rows by grouped family
  const counts = Object.fromEntries(STRUCT_GROUPS.map(g => [g, 0]));
  rows.forEach(r=>{
    const famRaw = (r[cols.structFam] ?? r[cols.structRaw] ?? "");
    const g = groupStructure(famRaw);
    counts[g] = (counts[g] || 0) + 1;
  });

  const container = document.getElementById("structureAccordion");
  container.innerHTML = "";

  STRUCT_GROUPS.forEach(f=>{
    const row = document.createElement("div");
    row.className = "legend-row";
    row.dataset.family = f;

    const sw = document.createElement("div");
    sw.className = "swatch";
    // Use your existing structColors where possible, else a neutral gray
    const fallback = "#9e9e9e";
    sw.style.background = structColors[f] || structColors["Other"] || fallback;

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = f;

    const count = document.createElement("div");
    count.className = "count";
    count.textContent = counts[f] || 0;

    row.appendChild(sw); row.appendChild(name); row.appendChild(count);

    row.addEventListener("click", ()=>{
      onFamilyClick(f); // this sets activeFamilyGroup and triggers applyCombinedFilter()
    });

    container.appendChild(row);
  });

  setFamilyLegendActive(activeFamilyGroup || "");
}

/* ---------- draw (unchanged except new render + size legend call kept) ---------- */
function draw(parsed){
  const {rows,cols}=parsed;
  const {data,allX,stats,families}=buildTraces(rows,cols,document.getElementById("hiOut").checked);
  say(`(Ea≤0.8) Rows: ${stats.total} · Plotted: ${stats.plotted} · Missing cycles: ${stats.missingCycles} · Skipped Ea: ${stats.skippedEa} · Skipped σ: ${stats.skippedSigma}`);
  renderStructureAccordion(families, rows, cols);
  buildSizeLegend();

  const xr = document.getElementById("clampX").checked ? [0.05, 1.0] : xRangeAuto(allX);

  Plotly.newPlot("chart", data, {
    paper_bgcolor:"#ffffff", plot_bgcolor:"#ffffff",
    xaxis:{
      title:"Activation Energy Ea (eV)",
      range:xr,
      tickformat:".2f",
      tickmode:"linear",
      tick0:0.10,
      dtick:0.05,
      gridcolor:"#dcdcdc",
      zerolinecolor:"#dcdcdc",
      titlefont:{size:12},
      tickfont:{size:10}
    },
    yaxis:{
      title:"Conductivity σ (S·cm⁻¹)",
      type:"log",
      gridcolor:"#dcdcdc",
      zerolinecolor:"#dcdcdc",
      titlefont:{size:12},
      tickfont:{size:10},
      tickvals: [
        1e-8,2e-8,5e-8,
        1e-7,2e-7,5e-7,
        1e-6,2e-6,5e-6,
        1e-5,2e-5,5e-5,
        1e-4,2e-4,5e-4,
        1e-3,2e-3,5e-3,
        1e-2,2e-2,5e-2,
        1e-1,2e-1,5e-1,
        1,2,5,10,20,50,100
      ],
      ticktext: [
        "1e−8","2e−8","5e−8",
        "1e−7","2e−7","5e−7",
        "1e−6","2e−6","5e−6",
        "1e−5","2e−5","5e−5",
        "1e−4","2e−4","5e−4",
        "1e−3","2e−3","5e−3",
        "1e−2","2e−2","5e−2",
        "1e−1","2e−1","5e−1",
        "1","2","5","10","20","50","100"
      ]
    },
    legend:{
      title:{text:"Ion (shape)", font:{size:11, color:"#111111"}},
      font:{size:10, color:"#111111"},
      itemclick:"toggleothers",
      itemdoubleclick:"toggle"
    },
    margin:{t:40, r:16, b:54, l:64}
  }, {
    plot_bgcolor:"#ffffff",
    paper_bgcolor:"#ffffff",
    responsive:true, displaylogo:false, modeBarButtonsToRemove:["select2d","lasso2d"]
  }).then(()=>{
    applyCombinedFilter(); // apply current group & cycle filters

    const gd = document.getElementById('chart');
    gd.on('plotly_hover', (ev)=>{
      const ntr = ev.points.map(p=>p.curveNumber);
      const vis = traceMeta.map((_, i)=> ntr.includes(i) ? {opacity:0.95} : {opacity:0.15});
      Plotly.restyle('chart', { 'marker.opacity': vis.map(v=>v.opacity) });
    });
    gd.on('plotly_unhover', ()=>{ Plotly.restyle('chart', { 'marker.opacity': traceMeta.map(()=>0.88) }); });
  });
}

/* ---------- parse helpers (unchanged) ---------- */
function parseCsvTextAndDraw(csvText){
  Papa.parse(csvText, {
    header:true, dynamicTyping:false, skipEmptyLines:true,
    complete:(res)=>{
      if(!res.data || !res.data.length){ say("Parsed data.csv but found no rows."); return; }
      const headers=res.meta.fields||[];
      const cols={
        ion:guessCol(headers,C.ion),
        structFam:guessCol(headers,C.structFam),
        structRaw:guessCol(headers,C.structRaw),
        ea:guessCol(headers,C.ea),
        sigma:guessCol(headers,C.sigma),
        cycles:guessCol(headers,C.cycles),
        formula:guessCol(headers,C.formula)
      };
      if(!cols.ion||!cols.structFam||!cols.ea||!cols.sigma){
        say("Missing required columns: Ion, Structure Family (Canonical), Ea, σ."); console.warn("Detected:", cols, headers); return;
      }
      last={rows:res.data,cols}; activeFamily=null; activeCycle=null; activeFamilyGroup=null; draw(last);
    },
    error:(e)=>{ err("Parse error: " + e.message); }
  });
}

/* ---------- auto-load data.csv (unchanged) ---------- */
function loadDataCsv(){
  const dataUrl = new URL('data.csv', window.location.href).toString();
  fetch(dataUrl, { cache: "no-store" })
    .then(resp => {
      if(!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      return resp.text();
    })
    .then(csvText => { say("data.csv loaded ✓"); parseCsvTextAndDraw(csvText); })
    .catch(e => {
      const onGitHubViewer = location.hostname === 'github.com';
      const hint = onGitHubViewer
        ? "You're viewing this file on github.com, which blocks scripts.\nPublish via GitHub Pages (Settings → Pages) or open via a local server."
        : "Ensure data.csv is in the same folder and the page is served over HTTP/HTTPS.";
      err(`Could not load data.csv: ${e.message}\n\n${hint}`);
    });
}

/* ---------- controls (unchanged) ---------- */
["clampX","hiOut"].forEach(id=>document.getElementById(id).addEventListener("change",()=>{ if(last){ activeFamily=null; activeCycle=null; activeFamilyGroup=null; draw(last);} }));
document.getElementById("sizeScale").addEventListener("input",()=>{
  sizeScaleFactor=parseFloat(sizeScale.value); document.getElementById("scaleVal").textContent=sizeScaleFactor.toFixed(1)+"×"; if(last){ draw(last); }
});
document.getElementById("jx").addEventListener("input", ()=>{
  JX = parseFloat(jx.value)||0; document.getElementById("jxVal").textContent = JX.toFixed(3)+" eV"; if(last){ draw(last);}
});
document.getElementById("jy").addEventListener("input", ()=>{
  JY_FRAC = (parseFloat(jy.value)||0)/100; document.getElementById("jyVal").textContent = (JY_FRAC*100).toFixed(1)+"%"; if(last){ draw(last);}
});

/* ---------- kick things off ---------- */
loadDataCsv();
</script>
</body>
</html>
