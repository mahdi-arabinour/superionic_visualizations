<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Superionic Conductors — Ea ≤ 0.6 · Ea vs σ (log Y)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { --bg:#ffffff; --panel:#f8f9fa; --grid:#e3e3e3; --text:#111; --panel-border:#d0d0d0; --note:#555; --accent:#007aff; }
  * { box-sizing:border-box; }
  body { margin:0; font-family:system-ui, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--text); }

  header {
    display:flex; flex-wrap:wrap; gap:12px; align-items:center;
    padding:8px 12px; background:var(--panel); border-bottom:1px solid var(--panel-border);
    position:sticky; top:0; z-index:10;
  }
  label { display:flex; align-items:center; gap:6px; font-size:12px; }
  .slider-container { display:flex; align-items:center; gap:6px; font-size:12px; }
  input[type="range"] { width:160px; }
  .badge { font-size:11px; color:var(--note); margin-left:auto; }

  .wrap { display:grid; grid-template-columns: 1fr 320px; gap:10px; padding:10px; }
  #chart { width:100%; height:92vh; border:1px solid var(--grid); border-radius:10px; background:#fff; }

  aside {
    display:flex; flex-direction:column; gap:14px;
    background:var(--panel); border:1px solid var(--panel-border);
    border-radius:10px; padding:10px; font-size:12px; max-height:92vh; overflow:auto;
  }
  .panel { background:#fff; border:1px solid #ddd; border-radius:10px; padding:10px; }
  .panel h3 { margin:0 0 8px; font-size:13px; color:#000; display:flex; justify-content:space-between; align-items:center; }
  .panel .controls { display:flex; gap:6px; }
  .panel button {
    border:1px solid #ddd; background:#f7f7f7; border-radius:8px; padding:4px 8px; font-size:11px; cursor:pointer;
  }
  .panel button:hover { background:#efefef; }

  /* Ion legend rows (shape-only, gray) */
  #ionLegend .row, #structureLegend .row {
    display:flex; align-items:center; gap:8px; padding:6px 8px; margin:5px 0;
    border:1px solid #e3e3e3; border-radius:8px; cursor:pointer; user-select:none; background:#fff;
  }
  #ionLegend .row.active, #structureLegend .row.active { outline:2px solid var(--accent); }
  .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #0002; }
  .shapeBox { width:16px; height:16px; display:inline-block; }
  .name { color:#000; font-size:12px; }
  .count { margin-left:auto; color:#555; font-size:11px; }

  #error { display:none; margin:8px 12px; padding:8px 12px; background:#fff3f3; color:#7f1d1d; border:1px solid #f5c2c2; border-radius:8px; white-space:pre-wrap; }
</style>
</head>
<body>
  <header>
    <div class="slider-container">
      <label for="sizeScale">Marker size:</label>
      <input type="range" id="sizeScale" min="6" max="36" value="16" step="1">
      <span id="scaleVal">16 px</span>
    </div>
    <span class="badge" id="status">Loading data.csv…</span>
  </header>

  <div id="error"></div>

  <div class="wrap">
    <div id="chart"></div>

    <aside>
      <!-- Ion legend (top) -->
      <div class="panel" id="ionPanel">
        <h3>
          Ion (shape, gray)
          <span class="controls">
            <button id="ionSelectAll">Select all</button>
            <button id="ionClearAll">Clear all</button>
          </span>
        </h3>
        <div id="ionLegend"></div>
      </div>

      <!-- Structure legend (bottom) -->
      <div class="panel" id="structPanel">
        <h3>
          Structure Group (color)
          <span class="controls">
            <button id="structSelectAll">Select all</button>
            <button id="structClearAll">Clear all</button>
          </span>
        </h3>
        <div id="structureLegend"></div>
      </div>
    </aside>
  </div>

<script>
/* ---------- Status & error ---------- */
const statusEl = document.getElementById("status");
const errorEl  = document.getElementById("error");
function say(msg){ statusEl.textContent = msg; }
function err(msg){ errorEl.style.display='block'; errorEl.textContent = msg; console.error(msg); }

/* ---------- Ion shapes & (kept for reference) colors ---------- */
const ION_SHAPES = {
  "Li+":  "circle",
  "Na+":  "square",
  "K+":   "diamond",
  "Ag+":  "cross",
  "O2-":  "triangle-up",
  "Zn2+": "triangle-down",
  "H+":   "x",
  "Rb+":  "star",
  "F-":   "hexagon",
  "Cu+":  "triangle-left",
  "Mg2+": "triangle-right",
  "In3+": "bowtie",
  "I-":   "hourglass",
  "Sn4+": "pentagon"
};
const DARK_GRAY = "#4a4a4a";    // ion legend shapes are gray

/* ---------- Structure group colors (bubbles use these) ---------- */
const STRUCT_COLORS = {
  "Others":"#9e9e9e",
  "Polymeric":"#ff7043",
  "Argyrodite":"#ab47bc",
  "Halide":"#26a69a",
  "Amorphous":"#f6bf26",
  "NASICON":"#66bb6a",
  "Anti-perovskite":"#0d47a1",
  "Spinel":"#8d6e63"
};

const norm = s => (s ?? "").toString().trim();

/* CSV columns */
const COLS = {
  ion: "Ion Type",
  structGrouped: "Structure Group",
  ea: "Activation Energy Ea (eV)",
  sigma: "Conductivity σ (S/cm)",
  formula: "Superionic Conductor Formula (Chemical)"
};

/* State */
let rowsGlobal = [];
let traceMeta = []; // per data trace: {ion,fam}
let markerSizePx = 16;

// Multi-select filter state (null => all)
let selectedIons = null;     // Set<string> or null
let selectedStructs = null;  // Set<string> or null

/* Helpers */
function toNum(v){
  if (typeof v === "number") return v;
  if (v == null) return NaN;
  const s = String(v).trim();
  if (!s || s.toLowerCase()==="na" || s.toLowerCase()==="n/a" || s==="—" || s==="–") return NaN;
  const n = Number(s.replace(/,/g,""));
  return Number.isFinite(n) ? n : NaN;
}
function getShape(ion){
  const k = norm(ion);
  if (ION_SHAPES[k]) return ION_SHAPES[k];
  const fb = ["circle","square","diamond","triangle-up","x","star","hexagon","bowtie"];
  const h = Math.abs([...k].reduce((a,c)=>a*31+c.charCodeAt(0),7));
  return fb[h % fb.length];
}
function getStructColor(fam){
  return STRUCT_COLORS[norm(fam)] || "#999";
}

/* Build Plotly data traces (one per row) */
function buildDataTraces(filteredRows){
  const traces=[]; traceMeta=[];
  filteredRows.forEach(r=>{
    const ion = norm(r[COLS.ion] || "Other") || "Other";
    const fam = norm(r[COLS.structGrouped] || "Others") || "Others";
    const ea  = toNum(r[COLS.ea]);
    const sig = toNum(r[COLS.sigma]);

    traces.push({
      x:[ea], y:[sig], mode:"markers",
      showlegend:false,
      marker:{
        size:[markerSizePx],
        color: getStructColor(fam),   // <-- bubble color by structure
        symbol: getShape(ion),        // <-- bubble shape by ion
        line:{ width:1.0, color:"#000" },
        opacity:0.9
      },
      text:[`${r[COLS.formula]||"(formula)"}<br>Ion: ${ion}<br>Structure: ${fam}`],
      hovertemplate:"<b>%{text}</b><br> Ea: %{x:.3f} eV<br> σ: %{y:.3e} S/cm<extra></extra>",
      visible:true
    });
    traceMeta.push({ ion, fam });
  });
  return traces;
}

/* ------------ Custom Legends (right column) ------------ */
/* Ion legend: draw gray shapes with names, toggle multi-select */
function renderIonLegend(filteredRows){
  const el = document.getElementById("ionLegend");
  el.innerHTML = "";

  const counts = {};
  filteredRows.forEach(r=>{
    const ion = norm(r[COLS.ion] || "Other") || "Other";
    counts[ion] = (counts[ion] || 0) + 1;
  });
  const ions = Object.keys(counts).sort((a,b)=>a.localeCompare(b));

  ions.forEach(ion=>{
    const row = document.createElement("div");
    row.className = "row";
    row.dataset.ion = ion;

    const shapeBox = document.createElement("div");
    shapeBox.className = "shapeBox";
    // Tiny inline SVG using the ion shape, filled dark gray
    shapeBox.innerHTML = makeShapeSVG(getShape(ion), DARK_GRAY);

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = ion;

    const count = document.createElement("div");
    count.className = "count";
    count.textContent = counts[ion];

    row.append(shapeBox, name, count);
    row.onclick = ()=>{
      // toggle this ion in selection set
      if (!selectedIons) selectedIons = new Set(ions); // if null (all), initialize to all, then toggle
      if (selectedIons.has(ion)) selectedIons.delete(ion); else selectedIons.add(ion);
      // if set becomes full (all), convert back to null for "all"
      if (selectedIons.size === ions.length) selectedIons = null;
      refreshLegendStates();
      applyFilters();
    };
    el.appendChild(row);
  });

  // buttons
  document.getElementById("ionSelectAll").onclick = ()=>{
    selectedIons = null; // all
    refreshLegendStates(); applyFilters();
  };
  document.getElementById("ionClearAll").onclick = ()=>{
    selectedIons = new Set(); // none
    refreshLegendStates(); applyFilters();
  };
}

/* Structure legend: colored swatches, toggle multi-select */
function renderStructureLegend(filteredRows){
  const el = document.getElementById("structureLegend");
  el.innerHTML = "";

  const counts = {};
  filteredRows.forEach(r=>{
    const fam = norm(r[COLS.structGrouped] || "Others") || "Others";
    counts[fam] = (counts[fam] || 0) + 1;
  });
  const famsKnown = ["Amorphous","Anti-perovskite","Argyrodite","Halide","NASICON","Spinel","Polymeric","Others"];
  const famsPresent = Object.keys(counts);
  const fams = [...famsKnown.filter(x=>famsPresent.includes(x)), ...famsPresent.filter(x=>!famsKnown.includes(x)).sort()];

  fams.forEach(fam=>{
    const row = document.createElement("div");
    row.className = "row";
    row.dataset.fam = fam;

    const sw = document.createElement("div");
    sw.className = "swatch";
    sw.style.background = getStructColor(fam);

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = fam;

    const count = document.createElement("div");
    count.className = "count";
    count.textContent = counts[fam];

    row.append(sw, name, count);
    row.onclick = ()=>{
      if (!selectedStructs) selectedStructs = new Set(fams);
      if (selectedStructs.has(fam)) selectedStructs.delete(fam); else selectedStructs.add(fam);
      if (selectedStructs.size === fams.length) selectedStructs = null;
      refreshLegendStates(); applyFilters();
    };
    el.appendChild(row);
  });

  document.getElementById("structSelectAll").onclick = ()=>{
    selectedStructs = null; refreshLegendStates(); applyFilters();
  };
  document.getElementById("structClearAll").onclick = ()=>{
    selectedStructs = new Set(); refreshLegendStates(); applyFilters();
  };
}

/* Update highlighting on both legends according to selection sets */
function refreshLegendStates(){
  // Ion rows
  const ionRows = document.querySelectorAll("#ionLegend .row");
  ionRows.forEach(row=>{
    const ion = row.dataset.ion;
    const on = (selectedIons === null) ? true : selectedIons.has(ion);
    row.classList.toggle("active", on);
  });
  // Struct rows
  const structRows = document.querySelectorAll("#structureLegend .row");
  structRows.forEach(row=>{
    const fam = row.dataset.fam;
    const on = (selectedStructs === null) ? true : selectedStructs.has(fam);
    row.classList.toggle("active", on);
  });
}

/* Apply filters to Plotly traces (point-level) */
function applyFilters(){
  if(!traceMeta.length) return;

  const n = traceMeta.length; // number of data traces
  const showAllIons  = (selectedIons === null);
  const showAllFams  = (selectedStructs === null);

  const vis = traceMeta.map(({ion,fam})=>{
    const ionOK = showAllIons || selectedIons.has(ion);
    const famOK = showAllFams || selectedStructs.has(fam);
    return (ionOK && famOK) ? true : "legendonly";
  });

  const idx = Array.from({length:n}, (_,i)=>i);
  Plotly.restyle("chart", { visible: vis }, idx);
}

/* ------------ Draw chart ------------ */
function draw(){
  const filtered = rowsGlobal.filter(r=>{
    const ea = toNum(r[COLS.ea]);
    const s  = toNum(r[COLS.sigma]);
    return Number.isFinite(ea) && ea <= 0.6 && Number.isFinite(s) && s > 0;
  });

  say(`Rows: ${rowsGlobal.length} · Plotted: ${filtered.length} · Color=Structure · Shape=Ion`);

  const dataTraces = buildDataTraces(filtered);

  Plotly.newPlot("chart", dataTraces, {
    paper_bgcolor:"#fff", plot_bgcolor:"#fff",
    xaxis:{
      title:"Activation Energy Ea (eV)",
      range:[0.05, 0.6],
      tickformat:".2f",
      tickmode:"linear",
      tick0:0.10,
      dtick:0.05,
      gridcolor:"#e9e9e9",
      zerolinecolor:"#e9e9e9",
      titlefont:{size:12},
      tickfont:{size:10}
    },
    yaxis:{
      title:"Conductivity σ (S/cm)",
      type:"log",
      gridcolor:"#e9e9e9",
      zerolinecolor:"#e9e9e9",
      titlefont:{size:12},
      tickfont:{size:10}
    },
    margin:{t:30, r:20, b:54, l:64},
    showlegend:false
  }, {
    responsive:true, displaylogo:false, modeBarButtonsToRemove:["select2d","lasso2d"]
  }).then(()=>{
    // Render right-column legends from the same filtered rows
    renderIonLegend(filtered);
    renderStructureLegend(filtered);
    // Apply initial highlight (all active)
    refreshLegendStates();

    // Hover fade
    const gd = document.getElementById('chart');
    gd.on('plotly_hover', (ev)=>{
      const n = traceMeta.length;
      const op = Array(n).fill(0.15);
      ev.points.forEach(p=>{ if (p.curveNumber < n) op[p.curveNumber] = 0.95; });
      const idx = Array.from({length:n}, (_,i)=>i);
      Plotly.restyle('chart', { 'marker.opacity': op }, idx);
    });
    gd.on('plotly_unhover', ()=>{
      const n = traceMeta.length;
      const idx = Array.from({length:n}, (_,i)=>i);
      Plotly.restyle('chart', { 'marker.opacity': Array(n).fill(0.9) }, idx);
    });
  });
}

/* ------------ Load CSV and boot ------------ */
function loadCsv(){
  fetch("data.csv", { cache:"no-store" })
    .then(resp => {
      if(!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      return resp.text();
    })
    .then(text=>{
      Papa.parse(text, {
        header:true, dynamicTyping:false, skipEmptyLines:true,
        complete:(res)=>{
          if(!res.data || !res.data.length){ say("Parsed CSV but found no rows."); return; }
          // basic column presence check
          const fields = res.meta.fields || [];
          const must = [COLS.ion, COLS.structGrouped, COLS.ea, COLS.sigma, COLS.formula];
          const missing = must.filter(m=>!fields.includes(m));
          if (missing.length){ err("Missing required columns: " + missing.join(", ")); return; }

          rowsGlobal = res.data;
          selectedIons = null;      // all on
          selectedStructs = null;   // all on
          draw();
        },
        error:(e)=>{ err("Parse error: " + e.message); }
      });
    })
    .catch(e=>{
      const onGitHubViewer = location.hostname === 'github.com';
      const hint = onGitHubViewer
        ? "You’re viewing this on github.com (scripts blocked). Publish via GitHub Pages or open via a local server."
        : "Ensure data.csv is in the same folder and the page is served via http(s).";
      err(`Could not load CSV: ${e.message}\n\n${hint}`);
    });
}

/* Controls */
document.getElementById("sizeScale").addEventListener("input", ()=>{
  markerSizePx = parseInt(sizeScale.value, 10) || 16;
  document.getElementById("scaleVal").textContent = markerSizePx + " px";
  draw();
});

/* ------------ Tiny inline symbol renderer for Ion legend ------------ */
function makeShapeSVG(shape, fill){
  const size = 16, half = size/2, stroke = "#1f2937";
  // Simple set: draw approximate shapes as SVG; keep consistent with Plotly names
  const svgOpen = `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">`;
  const svgClose = `</svg>`;
  const poly = pts => pts.map(p=>p.join(",")).join(" ");
  let body = "";

  switch(shape){
    case "circle":
      body = `<circle cx="${half}" cy="${half}" r="${half-1}" fill="${fill}" stroke="${stroke}" />`; break;
    case "square":
      body = `<rect x="2" y="2" width="${size-4}" height="${size-4}" rx="2" fill="${fill}" stroke="${stroke}" />`; break;
    case "diamond":
      body = `<polygon points="${poly([[half,2],[size-2,half],[half,size-2],[2,half]])}" fill="${fill}" stroke="${stroke}" />`; break;
    case "triangle-up":
      body = `<polygon points="${poly([[half,2],[size-2,size-2],[2,size-2]])}" fill="${fill}" stroke="${stroke}" />`; break;
    case "triangle-down":
      body = `<polygon points="${poly([[2,2],[size-2,2],[half,size-2]])}" fill="${fill}" stroke="${stroke}" />`; break;
    case "triangle-left":
      body = `<polygon points="${poly([[size-2,2],[size-2,size-2],[2,half]])}" fill="${fill}" stroke="${stroke}" />`; break;
    case "triangle-right":
      body = `<polygon points="${poly([[size-2,half],[2,2],[2,size-2]])}" fill="${fill}" stroke="${stroke}" />`; break;
    case "hexagon": {
      const pts = [];
      for(let i=0;i<6;i++){
        const a = (Math.PI/3)*i + Math.PI/6;
        pts.push([half + (half-2)*Math.cos(a), half + (half-2)*Math.sin(a)]);
      }
      body = `<polygon points="${poly(pts)}" fill="${fill}" stroke="${stroke}" />`; break;
    }
    case "pentagon": {
      const pts = [];
      for(let i=0;i<5;i++){
        const a = (2*Math.PI/5)*i - Math.PI/2;
        pts.push([half + (half-2)*Math.cos(a), half + (half-2)*Math.sin(a)]);
      }
      body = `<polygon points="${poly(pts)}" fill="${fill}" stroke="${stroke}" />`; break;
    }
    case "star": {
      const pts = [];
      const rO = half-1, rI = rO*0.45;
      for(let i=0;i<10;i++){
        const r = (i%2===0)? rO : rI;
        const a = -Math.PI/2 + (Math.PI/5)*i;
        pts.push([half + r*Math.cos(a), half + r*Math.sin(a)]);
      }
      body = `<polygon points="${poly(pts)}" fill="${fill}" stroke="${stroke}" />`; break;
    }
    case "cross":
      body = `<path d="M ${half-1} 2 L ${half+1} 2 L ${half+1} ${half-1} L ${size-2} ${half-1} L ${size-2} ${half+1} L ${half+1} ${half+1} L ${half+1} ${size-2} L ${half-1} ${size-2} L ${half-1} ${half+1} L 2 ${half+1} L 2 ${half-1} L ${half-1} ${half-1} Z" fill="${fill}" stroke="${stroke}" />`; break;
    case "x":
      body = `
        <rect x="2" y="${half-1}" width="${size-4}" height="2" transform="rotate(45 ${half} ${half})" fill="${fill}" stroke="${stroke}" />
        <rect x="2" y="${half-1}" width="${size-4}" height="2" transform="rotate(-45 ${half} ${half})" fill="${fill}" stroke="${stroke}" />`; break;
    case "bowtie":
      body = `<polygon points="${poly([[half,half],[size-2,2],[size-2,size-2]])}" fill="${fill}" stroke="${stroke}" />
              <polygon points="${poly([[half,half],[2,2],[2,size-2]])}" fill="${fill}" stroke="${stroke}" />`; break;
    case "hourglass":
      body = `<polygon points="${poly([[2,2],[size-2,2],[half,half]])}" fill="${fill}" stroke="${stroke}" />
              <polygon points="${poly([[2,size-2],[size-2,size-2],[half,half]])}" fill="${fill}" stroke="${stroke}" />`; break;
    default:
      body = `<circle cx="${half}" cy="${half}" r="${half-1}" fill="${fill}" stroke="${stroke}" />`; break;
  }
  return svgOpen + body + svgClose;
}

/* Boot */
loadCsv();
</script>
</body>
</html>
