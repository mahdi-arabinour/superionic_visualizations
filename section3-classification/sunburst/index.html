<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Sunburst — Ion + Structure Labels Only</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root { color-scheme: dark; }
    html, body { height:100%; margin:0; }
    body {
      font-family:system-ui, Segoe UI, Roboto, sans-serif;
      background:#0f1115; color:#e8e8ea;
      display:flex; flex-direction:column;
    }
    header {
      padding:10px 14px; background:#171a20;
      display:flex; gap:16px; align-items:center; flex-wrap:wrap;
      border-bottom:1px solid #262a32;
    }
    #wrap { flex:1; display:flex; padding:10px 12px; gap:12px; min-height:0; }
    #chartCard {
      flex:1; display:grid;
      grid-template-columns:minmax(640px,1.6fr) 300px;
      gap:12px; align-items:start; min-height:0;
    }
    .chartBody {
      background:#101626; border:1px dashed #333a49; border-radius:12px;
      position:relative;
      height:min(88vh,900px);
      min-height:520px;
    }
    svg { width:100%; height:100%; display:block; }
    .legend {
      background:#0f141f; border:1px solid #2a3240; border-radius:12px;
      padding:10px; overflow:auto; max-height:calc(100vh - 150px);
    }
    .legend h4 { margin:0 0 8px 0; font-size:12px; color:#cbd5e1; letter-spacing:.4px; text-transform:uppercase; }
    .legendGroup { display:flex; flex-direction:column; gap:6px; }
    .ionRow {
      display:grid; grid-template-columns:18px 1fr 18px;
      gap:10px; align-items:center; padding:6px 8px;
      border-radius:8px; user-select:none; cursor:pointer;
    }
    .ionRow:hover { background:#0f1726; }
    .swatch { width:18px; height:18px; border-radius:4px; border:1px solid rgba(255,255,255,.35); }
    .chev { width:18px; text-align:center; color:#a9b3c8; }
    .sublist { margin-left:26px; display:none; }
    .sublist.open { display:block; }
    .structRow {
      display:grid; grid-template-columns:14px 1fr 18px;
      gap:8px; align-items:center; padding:4px 6px;
      border-radius:6px; cursor:pointer;
    }
    .structRow:hover { background:#0c1322; }
    .smSwatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(255,255,255,.28); }
    .tooltip {
      position:fixed; pointer-events:none; background:rgba(0,0,0,.9);
      color:#fff; padding:8px 10px; border-radius:8px; font-size:12px;
      display:none; z-index:10; box-shadow:0 6px 18px rgba(0,0,0,.45);
    }
    .label { fill:#eee; text-anchor:middle; pointer-events:none; }
    .hiddenLabel { opacity:0; transition:opacity .2s ease; }
    .visibleLabel { opacity:1; transition:opacity .2s ease; }
  </style>
</head>
<body>
  <header>
    <strong>Sunburst</strong>
    <label style="font-size:13px;">
      <input type="checkbox" id="labelToggle" checked>
      Show labels
    </label>
    <span id="rtStats" style="font-size:12px;color:#9fb3cc;"></span>
  </header>

  <div id="wrap">
    <div id="chartCard">
      <div id="chart" class="chartBody"></div>
      <div id="legend" class="legend">
        <h4>Legend</h4>
        <div class="legendGroup"></div>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const DEF_COND = 1e-6;
    const SCALE_MODE = 'log';
    let root, gArcs, colorIon, maxRGlobal = 0;
    let labelsVisible = true;

    document.addEventListener('DOMContentLoaded', async () => {
      const dataObj = await (await fetch('data.simplified.json', {cache:'no-store'})).json();
      draw(dataObj);
      window.addEventListener('resize', () => requestAnimationFrame(() => draw(dataObj)));
      document.getElementById('labelToggle').addEventListener('change', e => {
        labelsVisible = e.target.checked;
        toggleLabels();
      });
    });

    function obj2children(obj) {
      return Object.entries(obj).map(([ion, structures]) => ({
        name: ion,
        children: Object.entries(structures || {}).map(([structure, strategies]) => ({
          name: structure,
          children: Object.entries(strategies || {}).map(([strategy, formulas]) => ({
            name: strategy,
            children: Object.entries(formulas || {}).map(([formula, vals]) => {
              const nums = Array.isArray(vals) ? vals.map(Number).filter(x => Number.isFinite(x) && x > 0) : [];
              return { name: formula, values: nums };
            })
          }))
        }))
      }));
    }

    function computeLeafCond(h, def) {
      h.each(n => {
        if (n.data && Array.isArray(n.data.values)) {
          const vals = n.data.values.filter(Number.isFinite);
          n.data.cond = vals.length ? vals[0] : def;
          n.data.hasCond = vals.length > 0;
        }
      });
    }

    function draw(dataObj) {
      const chartEl = document.getElementById('chart');
      chartEl.innerHTML = '';

      const rect = chartEl.getBoundingClientRect();
      const cw = Math.max(500, rect.width);
      const ch = Math.max(500, rect.height);
      const side = Math.min(cw, ch);

      const data = { name: 'root', children: obj2children(dataObj) };
      root = d3.hierarchy(data, d => d.children).sum(d => Array.isArray(d?.values) ? 1 : 0);
      computeLeafCond(root, DEF_COND);

      const ringThickness = Math.max(40, side * 0.08);
      const leafBase = Math.max(12, side * 0.03);
      const extraLeafMax = Math.max(90, side * 0.22);

      d3.partition().size([2 * Math.PI, (root.height + 1) * ringThickness])(root);

      const leaves = root.leaves();
      const condVals = leaves.map(l => l.data.cond || DEF_COND);
      let [cmin, cmax] = d3.extent(condVals);
      if (!(cmax > cmin)) { cmin = Math.max(1e-12, cmin * 0.8); cmax = cmin * 10; }

      const baseScale = SCALE_MODE === 'linear'
        ? d3.scaleLinear().domain([cmin, cmax])
        : d3.scaleLog().domain([Math.max(cmin, 1e-12), Math.max(cmax, 1e-12)]);
      const condScale = baseScale.range([0, extraLeafMax]).clamp(true);

      const ions = (root.children || []).map(d => d.data.name);
      colorIon = d3.scaleOrdinal(ions, d3.quantize(t => d3.interpolateRainbow(t), Math.max(3, ions.length)));

      const outerR = d => d.children ? d.y1 : d.y1 + leafBase + condScale(d.data.cond || DEF_COND);
      const maxR = d3.max(root.descendants(), d => outerR(d)) + 6;
      maxRGlobal = maxR;

      const svg = d3.select(chartEl).append('svg')
        .attr('width', '100%').attr('height', '100%')
        .attr('viewBox', `${-maxR} ${-maxR} ${maxR * 2} ${maxR * 2}`);
      const g = svg.append('g');
      gArcs = g;

      const arc = d3.arc()
        .startAngle(d => d.x0)
        .endAngle(d => d.x1)
        .padAngle(d => Math.min(0.006, (d.x1 - d.x0) / 6))
        .padRadius(maxR * 0.9)
        .innerRadius(d => d.y0)
        .outerRadius(d => outerR(d));

      const nodes = root.descendants().filter(d => d.depth > 0);
      const paths = g.selectAll('path').data(nodes).join('path')
        .attr('d', arc)
        .attr('fill', d => {
          let ion = d; while (ion.depth > 1) ion = ion.parent;
          const base = colorIon(ion.data.name);
          if (!d.children && !d.data.hasCond) { const c = d3.color(base); c.opacity = 0.55; return c.formatRgb(); }
          return base;
        })
        .attr('stroke', '#fff').attr('stroke-opacity', 0.28);

      // Tooltip
      const tooltip = document.getElementById('tooltip');
      const tooltipVal = v => (!Number.isFinite(v)
        ? 'n/a'
        : (v < 0.01 ? `${(v * 1000).toFixed(3)} mS·cm⁻¹` : `${Number(v).toPrecision(3)} S·cm⁻¹`));
      paths.on('mousemove', (e, d) => {
        const trail = d.ancestors().reverse().slice(1).map(n => n.data.name).join(' → ');
        let html = `<strong>${trail}</strong>`;
        if (!d.children) {
          html += d.data.hasCond
            ? `<br/>σ: ${tooltipVal(d.data.cond)}<br/><small>RT preferred; else first</small>`
            : `<br/><em>No conductivity — default height</em>`;
        } else html += `<br/>Share (by formula count): ${d.value}`;
        tooltip.style.display = 'block'; tooltip.innerHTML = html;
        tooltip.style.left = (e.clientX + 10) + 'px'; tooltip.style.top = (e.clientY + 10) + 'px';
      }).on('mouseleave', () => tooltip.style.display = 'none');

      // Labels — Ion + Structure only
      const angleToPixels = (d, radius) => (d.x1 - d.x0) * radius;
      const labels = g.selectAll('text')
        .data(nodes.filter(d => d.children && (d.depth === 1 || d.depth === 2)))
        .join('text')
        .attr('class', 'label visibleLabel')
        .attr('dy', '0.32em')
        .attr('transform', d => {
          const a = (d.x0 + d.x1) / 2 * 180 / Math.PI;
          const r = (d.y0 + outerR(d)) / 2;
          return `rotate(${a - 90}) translate(${r},0) rotate(${a < 180 ? 0 : 180})`;
        })
        .text(d => d.data.name);

      // Label styling
      labels.each(function(d) {
        const rMid = (d.y0 + outerR(d)) / 2;
        const arcPixels = angleToPixels(d, rMid);
        let fs = d.depth === 1 ? 14 : 11;
        fs = fs * Math.min(1.2, Math.max(0.7, (rMid / maxRGlobal) * 1.5));
        this.style.fontSize = fs + 'px';
        this.style.fill = d.depth === 1 ? '#ffffff' : '#d5d9e0';
        this.style.fontWeight = d.depth === 1 ? '600' : '500';
        const minNeeded = Math.min(70, fs * 5);
        this.classList.toggle('hiddenLabel', arcPixels < minNeeded);
      });

      toggleLabels();
      document.getElementById('rtStats').textContent =
        `Formulas w/ conductivity: ${leaves.filter(d => d.data.hasCond).length}/${leaves.length}`;
    }

    function toggleLabels() {
      d3.selectAll('.label')
        .attr('class', labelsVisible ? 'label visibleLabel' : 'label hiddenLabel');
    }
  </script>
</body>
</html>
