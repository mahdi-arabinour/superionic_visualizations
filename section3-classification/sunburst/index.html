<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Sunburst — Per-Level Radial Labels (Always Show)</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
  :root { color-scheme: dark; }
  html, body { height:100%; margin:0; }
  body { font-family:system-ui, Segoe UI, Roboto, sans-serif; background:#0f1115; color:#e8e8ea; display:flex; flex-direction:column; }
  header { padding:10px 14px; background:#171a20; display:flex; gap:16px; align-items:center; flex-wrap:wrap; border-bottom:1px solid #262a32; }
  .controlGroup { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .control { display:flex; align-items:center; gap:6px; background:#0f141f; border:1px solid #2a3240; border-radius:10px; padding:6px 8px; }
  .control label { font-size:12px; color:#cbd5e1; }
  .control input[type="range"] { width:120px; }
  #wrap { flex:1; display:flex; padding:10px 12px; gap:12px; min-height:0; }
  #chartCard { flex:1; display:grid; grid-template-columns:minmax(640px,1.6fr) 300px; gap:12px; align-items:start; min-height:0; }
  .chartBody { background:#101626; border:1px dashed #333a49; border-radius:12px; position:relative; height:min(88vh,900px); min-height:520px; contain:content; }
  svg { width:100%; height:100%; display:block; }

  .legend { background:#0f141f; border:1px solid #2a3240; border-radius:12px; padding:10px; overflow:auto; max-height:calc(100vh - 150px); }
  .legend h4 { margin:0 0 8px 0; font-size:12px; color:#cbd5e1; letter-spacing:.4px; text-transform:uppercase; }
  .legendGroup { display:flex; flex-direction:column; gap:6px; }
  .ionRow { display:grid; grid-template-columns:18px 1fr 18px; gap:10px; align-items:center; padding:6px 8px; border-radius:8px; user-select:none; cursor:pointer; }
  .ionRow:hover { background:#0f1726; }
  .swatch { width:18px; height:18px; border-radius:4px; border:1px solid rgba(255,255,255,.35); }

  .tooltip { position:fixed; pointer-events:none; background:rgba(0,0,0,.9); color:#fff; padding:8px 10px; border-radius:8px; font-size:12px; line-height:1.3; display:none; z-index:10; box-shadow:0 6px 18px rgba(0,0,0,.45); }

  .label, .leafLabel { fill:#e7eaf2; pointer-events:none; }
  .hiddenLabel { opacity:0; transition:opacity .12s ease; }
  .visibleLabel { opacity:1; transition:opacity .12s ease; }

  .crumbs { font-size:12px; color:#9fb3cc; }
  .crumbs a { color:#c6d7ff; text-decoration:none; cursor:pointer; }
  .crumbs a:hover { text-decoration:underline; }

  /* Curved ring captions (track labels for each level) */
  .ringGuides text.ringCaption {
    font-size: 11px;
    fill: #9fb3cc;
    letter-spacing: .3px;
    paint-order: stroke;
    stroke: rgba(15,17,21,0.85);
    stroke-width: 3px;
  }
  .ringGuides path.ringArc { fill: none; stroke: none; }

  .muted { opacity:.45; }
</style>
</head>
<body>
  <header>
    <strong>Sunburst — Per-Level Radial Labels</strong>

    <div class="control"><label><input type="checkbox" id="labelToggle" checked> Show all labels</label></div>

    <div class="controlGroup">
      <div class="control">
        <label><input type="checkbox" id="showIon" checked> Ion</label>
        <input id="fsIon" type="range" min="7" max="16" step="1" value="12"><span id="fsIonVal">12px</span>
      </div>
      <div class="control">
        <label><input type="checkbox" id="showStruct" checked> Structure</label>
        <input id="fsStruct" type="range" min="7" max="16" step="1" value="11"><span id="fsStructVal">11px</span>
      </div>
      <div class="control">
        <label><input type="checkbox" id="showStrat" checked> Strategy</label>
        <input id="fsStrat" type="range" min="7" max="16" step="1" value="10"><span id="fsStratVal">10px</span>
      </div>
      <div class="control">
        <label><input type="checkbox" id="showFormula" checked> Formula</label>
        <input id="fsFormula" type="range" min="6" max="14" step="1" value="9"><span id="fsFormulaVal">9px</span>
      </div>
    </div>

    <span id="rtStats" style="font-size:12px;color:#9fb3cc;"></span>
    <span id="crumbs" class="crumbs"></span>
  </header>

  <div id="wrap">
    <div id="chartCard">
      <div id="chart" class="chartBody"></div>
      <div class="legend">
        <h4>Legend</h4>
        <div class="legendGroup"></div>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  // ================== Tunables ==================
  const DEF_COND = 1e-6;
  const SCALE_MODE = 'log';

  // Size multipliers by zoom (root, ion, structure+)
  const RING_SCALE = [1.0, 1.32, 1.52];
  const LEAF_SCALE = [1.0, 1.45, 1.6];

  // Label always-show behavior
  const LEAF_MIN_DEG = 0.03;               // allow very narrow leaves to try
  const ANG_PAD_PX   = 2;                  // tighter angular padding
  const FONT_TRY_STEPS = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5];
  const MIN_FONT_PX  = 6;                  // absolute min font size
  const FORCE_SHOW_IF_FAILS = true;        // place even if it must overlap

  // Curved ring caption arc length (for ring-level track labels)
  const CAP_ARC_DEG = 120;

  // ================== State ==================
  let fullHierarchy=null, idMap=new Map(), focusNode=null;
  let gArcs, colorIon, maxRGlobal=0, labelsVisible=true;

  // Per-level show flags + fonts (controlled by UI)
  let SHOW_ION=true, SHOW_STRUCT=true, SHOW_STRAT=true, SHOW_FORMULA=true;
  let FS_ION=12, FS_STRUCT=11, FS_STRAT=10, FS_FORM=9;

  // Refs
  let _nodesCache=null, _outerR=null, _defs=null, _g=null, _focusDepth=0, _ringThickness=0, _leafBase=0;

  const ui = {};
  document.addEventListener('DOMContentLoaded', async ()=>{
    // --- wire controls
    ui.labelToggle = document.getElementById('labelToggle');

    ui.showIon     = document.getElementById('showIon');
    ui.showStruct  = document.getElementById('showStruct');
    ui.showStrat   = document.getElementById('showStrat');
    ui.showFormula = document.getElementById('showFormula');

    ui.fsIon = document.getElementById('fsIon');       ui.fsIonVal = document.getElementById('fsIonVal');
    ui.fsStruct = document.getElementById('fsStruct'); ui.fsStructVal = document.getElementById('fsStructVal');
    ui.fsStrat = document.getElementById('fsStrat');   ui.fsStratVal = document.getElementById('fsStratVal');
    ui.fsFormula = document.getElementById('fsFormula'); ui.fsFormulaVal = document.getElementById('fsFormulaVal');

    ui.labelToggle.onchange = ()=>{ labelsVisible = ui.labelToggle.checked; applyLabelVisibility(); };
    ui.showIon.onchange = ()=>{ SHOW_ION = ui.showIon.checked; layoutAllLabels(); };
    ui.showStruct.onchange = ()=>{ SHOW_STRUCT = ui.showStruct.checked; layoutAllLabels(); };
    ui.showStrat.onchange = ()=>{ SHOW_STRAT = ui.showStrat.checked; layoutAllLabels(); };
    ui.showFormula.onchange = ()=>{ SHOW_FORMULA = ui.showFormula.checked; layoutAllLabels(); };

    ui.fsIon.oninput = ()=>{ FS_ION = +ui.fsIon.value; ui.fsIonVal.textContent = FS_ION+'px'; layoutAllLabels(true); };
    ui.fsStruct.oninput = ()=>{ FS_STRUCT = +ui.fsStruct.value; ui.fsStructVal.textContent = FS_STRUCT+'px'; layoutAllLabels(true); };
    ui.fsStrat.oninput = ()=>{ FS_STRAT = +ui.fsStrat.value; ui.fsStratVal.textContent = FS_STRAT+'px'; layoutAllLabels(true); };
    ui.fsFormula.oninput = ()=>{ FS_FORM = +ui.fsFormula.value; ui.fsFormulaVal.textContent = FS_FORM+'px'; layoutAllLabels(true); };

    // --- data + draw
    const dataObj=await (await fetch('data.simplified.json',{cache:'no-store'})).json();
    fullHierarchy = buildHierarchy(dataObj);
    draw();

    window.addEventListener('resize', ()=>{ clearTimeout(window._rz); window._rz=setTimeout(draw,120); });
  });

  // ================== Hierarchy build ==================
  function obj2children(obj){
    return Object.entries(obj).map(([ion, structures])=>({
      name:ion,
      children:Object.entries(structures||{}).map(([structure, strategies])=>({
        name:structure,
        children:Object.entries(strategies||{}).map(([strategy, formulas])=>({
          name:strategy,
          children:Object.entries(formulas||{}).map(([formula, vals])=>{
            const nums=Array.isArray(vals)?vals.map(Number).filter(x=>Number.isFinite(x)&&x>0):[];
            return {name:formula, values:nums};
          })
        }))
      }))
    }));
  }
  let _uid=1;
  function assignUids(root){ root.each(n=>{ n.data._uid=_uid++; idMap.set(n.data._uid, n); }); }
  function buildHierarchy(dataObj){
    const data={name:'root', children:obj2children(dataObj)};
    const root=d3.hierarchy(data,d=>d.children)
      .sum(d=>Array.isArray(d?.values)?1:0)
      .sort((a,b)=>(b.value||0)-(a.value||0));
    computeLeafCond(root, DEF_COND); assignUids(root); return root;
  }
  function computeLeafCond(h, def){
    h.each(n=>{
      if (n.data && Array.isArray(n.data.values)) {
        const vals=n.data.values.filter(Number.isFinite);
        n.data.cond = vals.length ? vals[0] : def;
        n.data.hasCond = vals.length>0;
      }
    });
  }

  // Clone focus subtree, preserving UIDs
  function makeFocusRoot(){
    if (!focusNode || focusNode.depth===0) return fullHierarchy.copy();
    const clone = d3.hierarchy({
      name:focusNode.data.name, _uid:focusNode.data._uid,
      children: focusNode.children?.map(child=>cloneData(child))
    }, d=>d.children);
    clone.sum(d=>Array.isArray(d?.values)?1:0)
         .sort((a,b)=>(b.value||0)-(a.value||0));
    clone.each(n=>{
      if (n.data && Array.isArray(n.data.values)) {
        const vals=n.data.values.filter(Number.isFinite);
        n.data.cond = vals.length ? vals[0] : DEF_COND;
        n.data.hasCond = vals.length>0;
      }
    });
    return clone;
  }
  function cloneData(node){
    return { name:node.data.name, values:node.data.values, _uid:node.data._uid,
             children: node.children?.map(c=>cloneData(c)) };
  }

  // ================== Draw ==================
  function draw(){
    const chartEl=document.getElementById('chart');
    const legendEl=document.querySelector('.legendGroup');
    const tooltip=document.getElementById('tooltip');
    chartEl.innerHTML=''; legendEl.innerHTML='';

    const rect=chartEl.getBoundingClientRect();
    const side=Math.min(Math.max(500,rect.width), Math.max(500,rect.height));

    const root=makeFocusRoot();
    _focusDepth=(focusNode?.depth ?? 0);

    const ringScale=RING_SCALE[Math.min(_focusDepth, RING_SCALE.length-1)];
    const leafScale=LEAF_SCALE[Math.min(_focusDepth, LEAF_SCALE.length-1)];
    _ringThickness=Math.max(44, side*0.085)*ringScale;
    _leafBase=Math.max(12, side*0.03);
    const extraLeafMax=Math.max(90, side*0.22)*leafScale;

    d3.partition().size([2*Math.PI, (root.height+1)*_ringThickness])(root);

    // cond scale
    const condVals=root.leaves().map(l=>l.data.cond||DEF_COND);
    let [cmin,cmax]=d3.extent(condVals); if(!(cmax>cmin)){ cmin=Math.max(1e-12,cmin*0.8); cmax=cmin*10; }
    const baseScale=(SCALE_MODE==='linear'? d3.scaleLinear().domain([cmin,cmax])
                                          : d3.scaleLog().domain([Math.max(cmin,1e-12), Math.max(cmax,1e-12)]));
    const condScale=baseScale.range([0,extraLeafMax]).clamp(true);

    const ions=(fullHierarchy.children||[]).map(d=>d.data.name);
    colorIon=d3.scaleOrdinal(ions, d3.quantize(t=>d3.interpolateRainbow(t), Math.max(3, ions.length)));

    _outerR=d=>d.children ? d.y1 : d.y1 + _leafBase + condScale(d.data.cond || DEF_COND);
    const maxR=d3.max(root.descendants(), d=>_outerR(d)) + 6; maxRGlobal=maxR;

    const svg=d3.select(chartEl).append('svg').attr('width','100%').attr('height','100%')
      .attr('viewBox', `${-maxR} ${-maxR} ${maxR*2} ${maxR*2}`);
    _g=svg.append('g'); _defs=svg.append('defs');

    const arc=d3.arc().startAngle(d=>d.x0).endAngle(d=>d.x1)
      .padAngle(d=>Math.min(0.006,(d.x1-d.x0)/6)).padRadius(maxR*0.9)
      .innerRadius(d=>d.y0).outerRadius(d=>_outerR(d));

    const nodes=root.descendants().filter(d=>d.depth>0);
    _nodesCache = nodes;

    // arcs
    const paths=_g.selectAll('path').data(nodes, d=>d.data._uid).join('path')
      .attr('d', arc)
      .attr('fill', d=>{
        let full = idMap.get(d.data._uid); while(full && full.depth>1) full = full.parent;
        const base=colorIon(full?.data?.name || 'default');
        if (!d.children && !d.data.hasCond){ const c=d3.color(base); c.opacity=0.55; return c.formatRgb(); }
        return base;
      })
      .attr('stroke','#fff').attr('stroke-opacity',0.28)
      .attr('stroke-width', d => (d.x1-d.x0) < 0.002 ? 0 : Math.max(0.6, side*0.0012));

    // tooltip
    const tipVal=v=>(!Number.isFinite(v)?'n/a':(v<0.01?`${(v*1000).toFixed(3)} mS·cm⁻¹`:`${Number(v).toPrecision(3)} S·cm⁻¹`));
    const tt=document.getElementById('tooltip');
    paths.on('mousemove',(evt,d)=>{
      const trail=d.ancestors().reverse().slice(1).map(n=>n.data.name).join(' → ');
      let html=`<strong>${trail}</strong>`;
      html += d.children ? `<br/>Share (by formula count): ${d.value}`
                         : (d.data.hasCond ? `<br/>σ: ${tipVal(d.data.cond)}<br/><small>RT preferred; else first</small>`
                                           : `<br/><em>No conductivity — default height</em>`);
      tt.style.display='block'; tt.innerHTML=html;
      tt.style.left=(evt.clientX+10)+'px'; tt.style.top=(evt.clientY+10)+'px';
    }).on('mouseleave',()=>{ tt.style.display='none'; });

    // click to zoom / step back
    paths.on('click',(evt,d)=>{
      const full = idMap.get(d.data._uid);
      if (focusNode && full === focusNode) { focusNode = focusNode.parent || null; }
      else { focusNode = full; }
      draw();
    });

    // center “back” target + name
    const backR = Math.max(16, (root.y1 - root.y0) * 0.38);
    _g.append('circle')
      .attr('r', backR)
      .attr('fill', 'rgba(255,255,255,0.02)')
      .style('cursor', focusNode ? 'pointer' : 'default')
      .on('click', ()=>{ if (focusNode){ focusNode = focusNode.parent || null; draw(); }});
    _g.append('text')
      .attr('text-anchor','middle').attr('dy','0.35em')
      .style('font-size','12px').style('fill','#dfe6f3')
      .text(focusNode ? focusNode.data.name : 'All ions');

    // labels (RADIAL upright, per-level toggles + per-level fonts)
    layoutAllLabels();

    // ring track captions (curved, for ring meaning)
    renderRingCaptions(root);

    // stats + crumbs + legend
    document.getElementById('rtStats').textContent =
      `Formulas w/ conductivity: ${fullHierarchy.leaves().filter(d=>d.data.hasCond).length}/${fullHierarchy.leaves().length}`;
    renderCrumbs(root);
    buildLegend(legendEl, root);
    applyLabelVisibility();
  }

  // ================== Label layout helpers ==================
  function layoutAllLabels(isLive){
    // clear existing label nodes (we recompute everything)
    _g.selectAll('.labels').remove();
    const layer = _g.append('g').attr('class','labels');

    // Internal (Ion / Structure / Strategy)
    const internals = _nodesCache.filter(d => d.children);
    const toShow = internals.filter(d=>{
      if (d.depth===1) return SHOW_ION;
      if (d.depth===2) return SHOW_STRUCT;
      if (d.depth===3) return SHOW_STRAT;
      return false;
    });

    const selInt = layer.selectAll('text.internal')
      .data(toShow, d=>d.data._uid)
      .join('text')
      .attr('class','label visibleLabel internal')
      .text(d=>d.data.name)
      .style('font-weight', d=> (d.depth===1?'700': d.depth===2?'600':'500'))
      .style('fill', d=> (d.depth===1 ? '#fff' : '#e7eaf2'))
      .style('font-size', d=> (d.depth===1?FS_ION: d.depth===2?FS_STRUCT:FS_STRAT) + 'px');

    // Leaves (Formula)
    const leaves = _nodesCache.filter(d => !d.children);
    const selLeaf = SHOW_FORMULA
      ? layer.selectAll('text.leaf').data(leaves, d=>d.data._uid).join('text')
          .attr('class','leafLabel visibleLabel leaf')
          .text(d=>d.data.name)
          .style('font-size', FS_FORM + 'px')
      : layer.selectAll('text.leaf').data([], d=>d.data?d.data._uid:null).join('text'); // nothing

    // Place both with upright radial algorithm
    placeRadial(selInt);
    if (SHOW_FORMULA) placeRadial(selLeaf);

    applyLabelVisibility();
  }

  // Upright, tangential rotation with greedy fit + last-resort placement
  function placeRadial(selection){
    const occByRing = new Map(); // per-radius occupancy intervals (radians)

    selection.each(function(d){
      const el = d3.select(this);

      // choose base font per node depth
      const basePx = (!d.children) ? FS_FORM
                     : d.depth===1 ? FS_ION
                     : d.depth===2 ? FS_STRUCT
                     : FS_STRAT;

      const rMid = (d.y0 + (d.children ? d.y1 : _outerR(d)))/2;
      const key  = Math.round(rMid);
      const a0   = d.x0, a1 = d.x1, amid = (a0+a1)/2;
      const upright = !(amid > Math.PI/2 && amid < 3*Math.PI/2);

      if (!occByRing.has(key)) occByRing.set(key, []);

      let placed = false;
      for (const s of FONT_TRY_STEPS){
        const fs = Math.max(MIN_FONT_PX, basePx * s);
        el.style('font-size', fs + 'px').style('display', null);

        const w = this.getComputedTextLength ? this.getComputedTextLength()
                                             : fs * (this.textContent.length * 0.56);
        const need = (w + ANG_PAD_PX) / Math.max(1, rMid); // radians needed
        if ((a1 - a0) < need * 0.92) { el.style('display','none'); continue; }

        const occ = occByRing.get(key);
        const t0 = amid - need/2, t1 = amid + need/2;
        const ok = occ.every(([o0,o1]) => t1 <= o0 || t0 >= o1);
        if (!ok) { el.style('display','none'); continue; }

        // Reserve & place
        occ.push([t0,t1]); occ.sort((x,y)=>x[0]-y[0]);
        const deg = amid * 180/Math.PI;
        el.attr('dy','0.32em')
          .attr('text-anchor','middle')
          .attr('transform', `rotate(${deg-90}) translate(${rMid},0) rotate(${upright?0:180})`)
          .style('display', null);
        placed = true;
        break;
      }

      // Last resort: force-show even if overlapping/too long
      if (!placed && FORCE_SHOW_IF_FAILS){
        const fs = MIN_FONT_PX;
        el.style('font-size', fs + 'px').style('display', null).style('opacity', 0.98);
        const deg = amid * 180/Math.PI;
        el.attr('dy','0.32em')
          .attr('text-anchor','middle')
          .attr('transform', `rotate(${deg-90}) translate(${rMid},0) rotate(${upright?0:180})`);
      }
    });
  }

  // ================== Curved ring captions (track labels) ==================
  function renderRingCaptions(partitionRoot){
    _g.selectAll('.ringGuides').remove();
    const guides = _g.append('g').attr('class','ringGuides');

    const caps = ['Ion','Structure','Doping strategy','Formula'];

    const a0 = (-90 - CAP_ARC_DEG/2) * Math.PI/180;
    const a1 = (-90 + CAP_ARC_DEG/2) * Math.PI/180;

    function arcPath(r, a0, a1){
      const x0 = r * Math.cos(a0), y0 = r * Math.sin(a0);
      const x1 = r * Math.cos(a1), y1 = r * Math.sin(a1);
      const largeArc = (a1 - a0) % (2*Math.PI) > Math.PI ? 1 : 0;
      return `M ${x0.toFixed(3)} ${y0.toFixed(3)} A ${r.toFixed(3)} ${r.toFixed(3)} 0 ${largeArc} 1 ${x1.toFixed(3)} ${y1.toFixed(3)}`;
    }

    const bandCount = partitionRoot.height;
    const bandMids = Array.from({length: bandCount}, (_,i)=> (i+0.5) * _ringThickness);
    const rFormula = (bandCount * _ringThickness) + (_leafBase * 0.65);

    const items=[];
    if (bandMids[0]!=null) items.push({text:caps[0], r:bandMids[0]});
    if (bandMids[1]!=null) items.push({text:caps[1], r:bandMids[1]});
    if (bandMids[2]!=null) items.push({text:caps[2], r:bandMids[2]});
    items.push({text:caps[3], r:rFormula});

    items.forEach((it,i)=>{
      const id = `ringcap-${i}-${Math.floor(it.r)}`;
      const d = arcPath(it.r, a0, a1);
      _defs.append('path').attr('class','ringArc').attr('id',id).attr('d',d);
      guides.append('text').attr('class','ringCaption')
        .append('textPath')
        .attr('href','#'+id)
        .attr('startOffset','50%')
        .attr('text-anchor','middle')
        .text(it.text);
    });
  }

  // ================== Legend & Breadcrumb ==================
  function buildLegend(container, subtreeRoot){
    container.innerHTML='';
    (subtreeRoot.children||[]).forEach(node=>{
      const row=document.createElement('div'); row.className='ionRow';
      const sw=document.createElement('div'); sw.className='swatch';
      let full = idMap.get(node.data._uid); while(full && full.depth>1) full=full.parent;
      sw.style.background = d3.color(colorIon(full?.data?.name || node.data.name)).formatRgb();
      const nm=document.createElement('div'); nm.textContent=node.data.name;
      row.append(sw, nm, document.createElement('div'));
      row.onclick=()=>{ const full=idMap.get(node.data._uid); focusNode=full; draw(); };
      container.appendChild(row);
    });
  }

  function renderCrumbs(){
    const el=document.getElementById('crumbs');
    if (!focusNode || focusNode.depth===0){
      el.innerHTML='<a data-ix="root">All ions</a>';
      el.querySelector('a').onclick=()=>{ focusNode=null; draw(); };
      return;
    }
    const chain=focusNode.ancestors().reverse().slice(1);
    el.innerHTML=['<a data-ix="root">All ions</a>',
      ...chain.map((n,i)=>` / <a data-ix="${i}">${n.data.name}</a>`)].join('');
    el.querySelectorAll('a').forEach(a=>{
      a.onclick=()=>{
        const ix=a.getAttribute('data-ix');
        focusNode = (ix==='root') ? null : chain[Number(ix)];
        draw();
      };
    });
  }

  // ================== Label visibility ==================
  function applyLabelVisibility(){
    const show = labelsVisible;
    d3.selectAll('.label, .leafLabel').classed('hiddenLabel', !show).classed('visibleLabel', show);
    // ring captions always visible
  }
  </script>
</body>
</html>
