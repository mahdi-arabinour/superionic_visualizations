<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
  const chartEl   = document.getElementById('chart');
  const legendEl  = document.getElementById('legend');
  const tooltip   = document.getElementById('tooltip');

  const cbDepth1 = document.getElementById('cbDepth1');
  const cbDepth2 = document.getElementById('cbDepth2');
  const cbDepth3 = document.getElementById('cbDepth3');
  const cbLeaf   = document.getElementById('cbLeaf');

  const DEF_COND = 1e-6;
  const SCALE_MODE = 'log';

  let dataObj = null;
  let root = null, svgGlobal = null, gArcs = null, gLabels = null, nodesGlobal = null, sideGlobal = null, outerRadiusForGlobal = null;
  const highlightedIons = new Set();
  const highlightedFams = new Set();

  // --- helper to dump first two levels of keys to the console for quick sanity check
  function logShape(obj) {
    const lvl1 = Object.keys(obj || {});
    console.log('[sunburst] top-level keys:', lvl1);
    const first = lvl1.slice(0, 5);
    const lvl2 = {};
    first.forEach(k => {
      const v = obj[k];
      if (v && typeof v === 'object' && !Array.isArray(v)) lvl2[k] = Object.keys(v).slice(0, 10);
      else lvl2[k] = Array.isArray(v) ? `[array length ${v.length}]` : typeof v;
    });
    console.log('[sunburst] second-level sample:', lvl2);
  }

  // robust loader: try simplified first, then data.json
  async function loadData() {
    const candidates = ['data.simplified.json', 'data.json'];
    let lastErr = null;
    for (const path of candidates) {
      try {
        const r = await fetch(path, { cache: 'no-store' });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const json = await r.json();
        if (!json || typeof json !== 'object' || Array.isArray(json)) {
          throw new Error(`${path} is not an object hierarchy`);
        }
        console.log(`[sunburst] loaded ${path}`);
        logShape(json);
        return json;
      } catch (e) {
        console.warn(`[sunburst] failed ${path}:`, e);
        lastErr = e;
      }
    }
    throw lastErr || new Error('No data file found');
  }

  function obj2children(obj){
    return Object.entries(obj).map(([k,v])=>{
      if (Array.isArray(v)) {
        // leaf: ensure numbers only
        const nums = v.map(Number).filter(x => Number.isFinite(x));
        return { name:k, values: nums };
      }
      if (v && typeof v === 'object') return { name:k, children: obj2children(v) };
      // if someone left a primitive at a non-leaf, coerce to empty leaf to avoid crashing
      return { name:k, values: [] };
    });
  }

  function computeLeafCond(h, def){
    h.each(n=>{
      if (n.data && Array.isArray(n.data.values)) {
        const vals = n.data.values.filter(v => Number.isFinite(v));
        n.data.cond = vals.length ? d3.max(vals) : def;
      }
    });
  }

  function draw(){
    if(!dataObj) return;
    chartEl.innerHTML = '';

    const rect = chartEl.getBoundingClientRect();
    let w = rect.width  || chartEl.clientWidth  || 800;
    let h = rect.height || chartEl.clientHeight || 640;
    if (!w || !h) { w = 800; h = 640; }
    const side = Math.floor(Math.min(w, h));
    sideGlobal = Math.max(side, 400);

    const data = { name:'root', children: obj2children(dataObj) };

    // Angle weights from MAX per leaf (change to d3.sum(vals) or d3.mean(vals) if you prefer)
    root = d3.hierarchy(data, d => d.children)
      .sum(d => {
        if (d && Array.isArray(d.values)) {
          const vals = d.values.filter(v => Number.isFinite(v));
          return vals.length ? d3.max(vals) : 0;
        }
        return 0;
      });

    if (!root.children || !root.children.length) {
      const msg = 'No depth-1 categories found. Check your JSON: it must be an object whose values are objects (…ending with arrays of numbers).';
      console.error('[sunburst] ' + msg, dataObj);
      alert(msg + '\n\nOpen DevTools → Console to see the keys that were found.');
      return;
    }

    // If everything sums to ~0, fall back so you still see slices
    const total = root.value || 0;
    if (!(total > 0)) {
      console.warn('[sunburst] total weight is zero — falling back to equal-area slices for visibility.');
      root.sum(d => (d && Array.isArray(d.values)) ? 1 : 0);
    }

    computeLeafCond(root, DEF_COND);

    const svg = d3.select(chartEl).append('svg')
      .attr('width','100%').attr('height','100%')
      .attr('viewBox', `${-sideGlobal/2} ${-sideGlobal/2} ${sideGlobal} ${sideGlobal}`);
    svgGlobal = svg;

    const ringThickness = Math.max(36, sideGlobal * 0.06);
    const leafBase      = Math.max(10, sideGlobal * 0.02);
    const extraLeafMax  = Math.max(110, sideGlobal * 0.20);

    d3.partition().size([2*Math.PI, (root.height + 1) * ringThickness])(root);

    const leaves = root.leaves();
    let condVals = leaves.map(l => l.data.cond || DEF_COND).filter(Number.isFinite);
    if (!condVals.length) condVals = [DEF_COND];
    let [cmin, cmax] = d3.extent(condVals);
    if (!(cmax > cmin)) { cmin = cmin*0.8; cmax = cmax*1.2; }

    const baseScale = (SCALE_MODE==='linear'
      ? d3.scaleLinear().domain([cmin, cmax])
      : d3.scaleLog().domain([Math.max(cmin, 1e-12), Math.max(cmax, 1e-12)]));
    const condScale = baseScale.range([0, extraLeafMax]).clamp(true);

    const ions = (root.children || []).map(d=>d.data.name);
    const colorIon = d3.scaleOrdinal(ions, d3.quantize(t => d3.interpolateRainbow(t), Math.max(3, ions.length)));

    const outerRadiusFor = d => d.children
      ? d.y1
      : d.y1 + leafBase + condScale(d.data.cond || DEF_COND);
    outerRadiusForGlobal = outerRadiusFor;

    const arc = d3.arc()
      .startAngle(d=>d.x0)
      .endAngle(d=>d.x1)
      .padAngle(d=>Math.min(0.006, (d.x1-d.x0)/6))
      .padRadius(sideGlobal * 0.45)
      .innerRadius(d=>d.y0)
      .outerRadius(d=> outerRadiusFor(d));

    const g = svg.append('g');
    gArcs = g;

    const nodes = root.descendants().filter(d=>d.depth>0);
    nodesGlobal = nodes;

    const paths = g.selectAll('path')
      .data(nodes)
      .join('path')
      .attr('d', arc)
      .attr('fill', d => { let a=d; while(a.depth>1) a=a.parent; return colorIon(a.data.name); })
      .attr('stroke','#fff').attr('stroke-opacity',0.35).attr('stroke-width', Math.max(0.6, sideGlobal*0.0012));

    // data attributes for filters
    paths.each(function(d){
      let ion=d; while(ion && ion.depth>1) ion=ion.parent;
      let fam=d; while(fam && fam.depth>2) fam=fam.parent;
      this.dataset.ion = ion?.data?.name || '';
      this.dataset.family = fam?.data?.name || '';
    });

    const showVal = (v) => (!Number.isFinite(v) ? 'n/a' : (v < 0.01 ? `${(v*1000).toFixed(3)} mS·cm⁻¹` : `${Number(v).toPrecision(3)} S·cm⁻¹`));
    paths.on('mousemove', (evt, d) => {
      const trail = d.ancestors().reverse().slice(1).map(n=>n.data.name).join(' → ');
      let html = `<strong>${trail}</strong>`;
      if (!d.children) {
        html += `<br/>σ (max): ${showVal(d.data.cond)}`;
        const all = (d.data.values || []).filter(Number.isFinite);
        if (all.length > 1) {
          const min = d3.min(all), max = d3.max(all);
          html += `<br/>range: ${showVal(min)} – ${showVal(max)} (${all.length} values)`;
        }
      } else {
        html += `<br/>Σσ (children, angle weight): ${showVal(d.value)}`;
      }
      tooltip.style.display = 'block';
      tooltip.innerHTML = html;
      tooltip.style.left = (evt.clientX + 10) + 'px';
      tooltip.style.top  = (evt.clientY + 10) + 'px';
    }).on('mouseleave', () => { tooltip.style.display = 'none'; });

    buildLegend(root, colorIon);
    applyHighlight();
    addLabelsLayer();
  }

  function buildLegend(root, colorIon){
    const group = legendEl.querySelector('.legendGroup');
    group.innerHTML = '';
    (root.children || []).forEach(ionNode => {
      const ion = ionNode.data.name;
      const row = document.createElement('div'); row.className='ionRow';
      const sw  = document.createElement('div'); sw.className='swatch'; sw.style.background = colorIon(ion);
      const nm  = document.createElement('div'); nm.className='ionName'; nm.textContent = ion;
      const cv  = document.createElement('div'); cv.className='chev'; cv.textContent = '▸';
      row.appendChild(sw); row.appendChild(nm); row.appendChild(cv);
      group.appendChild(row);

      const sub = document.createElement('div'); sub.className='sublist';
      const fams = (ionNode.children||[]).map(n=>n.data.name);
      fams.forEach((fam, i) => {
        const li = document.createElement('div'); li.className='famRow';
        const sm = document.createElement('div'); sm.className='smSwatch';
        sm.style.background = d3.color(colorIon(ion)).brighter(0.5 + (i/(Math.max(2,fams.length)-1||1))*0.9).formatRgb();
        const sn = document.createElement('div'); sn.textContent = fam;
        li.appendChild(sm); li.appendChild(sn);
        sub.appendChild(li);
        li.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (highlightedFams.has(fam)) highlightedFams.delete(fam); else highlightedFams.add(fam);
          applyHighlight();
        });
      });
      group.appendChild(sub);

      cv.addEventListener('click', (e) => {
        e.stopPropagation();
        const open = sub.classList.toggle('open');
        cv.textContent = open ? '▾' : '▸';
      });

      const toggleIon = () => {
        if (highlightedIons.has(ion)) highlightedIons.delete(ion); else highlightedIons.add(ion);
        applyHighlight();
      };
      nm.addEventListener('click', toggleIon);
      sw.addEventListener('click', toggleIon);
    });
  }

  function applyHighlight(){
    if (!gArcs) return;
    const paths = gArcs.selectAll('path');
    const hasIon = highlightedIons.size > 0;
    const hasFam = highlightedFams.size > 0;
    if (!hasIon && !hasFam){
      paths.classed('dimmed', false).classed('highlight', false);
      return;
    }
    paths.each(function(){
      const ion = this.dataset.ion;
      const fam = this.dataset.family;
      const on = (!hasIon || highlightedIons.has(ion)) && (!hasFam || highlightedFams.has(fam));
      this.classList.toggle('highlight', on);
      this.classList.toggle('dimmed', !on);
    });
  }

  function polarToCartesian(cx, cy, r, a){ return [cx + r*Math.cos(a), cy + r*Math.sin(a)]; }
  function arcLabelPathD(a0, a1, r){
    const inset = 0.003; a0 += inset; a1 -= inset;
    const mid = (a0 + a1) / 2;
    let start = a0, end = a1, flip = false;
    if (mid >= Math.PI) { start = a1; end = a0; flip = true; }
    const largeArc = (Math.abs(end - start) % (2*Math.PI)) > Math.PI ? 1 : 0;
    const [sx, sy] = polarToCartesian(0, 0, r, start);
    const [ex, ey] = polarToCartesian(0, 0, r, end);
    const sweep = flip ? 0 : 1;
    return { d: `M ${sx} ${sy} A ${r} ${r} 0 ${largeArc} ${sweep} ${ex} ${ey}` };
  }

  function addLabelsLayer(){
    if (!svgGlobal || !nodesGlobal) return;
    if (gLabels) gLabels.remove();
    gLabels = svgGlobal.append('g');

    const showDepth1 = cbDepth1.checked;
    const showDepth2 = cbDepth2.checked;
    const showDepth3 = cbDepth3.checked;
    const showLeaf   = cbLeaf.checked;

    const minAngle = 0.004;
    const minRadius = sideGlobal * 0.06;

    const defs = svgGlobal.append('defs');

    const labelCandidates = nodesGlobal.filter(d => {
      const isLeaf = !d.children;
      const depthOK =
        (d.depth === 1 && showDepth1) ||
        (d.depth === 2 && showDepth2) ||
        (d.depth === 3 && showDepth3) ||
        (isLeaf      && showLeaf);
      if (!depthOK) return false;
      if ((d.x1 - d.x0) < minAngle) return false;
      d._labelR = isLeaf ? Math.max(outerRadiusForGlobal(d) - 5, d.y1 - 2) : (d.y0 + d.y1) / 2;
      if (d._labelR < minRadius) return false;
      return true;
    });

    labelCandidates.forEach((d,i) => {
      const id = `lbl-${i}`;
      const { d: pathD } = arcLabelPathD(d.x0, d.x1, d._labelR);
      defs.append('path').attr('id', id).attr('class', 'labelPath').attr('d', pathD);
      gLabels.append('text').attr('class','labelText')
        .append('textPath').attr('startOffset','50%').attr('text-anchor','middle')
        .attr('href', `#${id}`).text(d.data.name);
    });
  }

  (async () => {
    try {
      dataObj = await loadData();
      draw();
      [cbDepth1, cbDepth2, cbDepth3, cbLeaf].forEach(cb => cb.addEventListener('change', addLabelsLayer));
      window.addEventListener('resize', () => requestAnimationFrame(draw));
    } catch (err) {
      console.error('Data load failed:', err);
      alert('Could not load any data file (data.simplified.json, data.json).\n' + (err && err.message ? err.message : err));
    }
  })();
</script>
