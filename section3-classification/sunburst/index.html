<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Sunburst — Ion → Structure → Strategy → Formula (Interactive Legend)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family:system-ui,Segoe UI,Roboto,sans-serif; background:#0f1115; color:#e8e8ea; height:100vh; display:flex; flex-direction:column; }
    header { padding:10px 14px; background:#171a20; display:flex; gap:16px; flex-wrap:wrap; align-items:center; border-bottom:1px solid #262a32; }
    #wrap { flex:1; min-height:0; display:flex; padding:12px 14px; gap:12px; }
    #chartCard { flex:1; display:grid; grid-template-columns: 1fr 360px; gap:14px; min-height:420px; }
    .chartBody { background:#101626; border:1px dashed #333a49; border-radius:12px; position:relative; }
    svg { width:100%; height:100%; display:block; }

    .legend { background:#0f141f; border:1px solid #2a3240; border-radius:12px; padding:10px; overflow:auto; }
    .legend h4 { margin:0 0 8px 0; font-size:12px; color:#cbd5e1; letter-spacing:.4px; text-transform:uppercase; }
    .legendGroup { display:flex; flex-direction:column; gap:6px; }

    .ionRow { display:grid; grid-template-columns: 18px 1fr 18px; gap:10px; align-items:center; padding:6px 8px; border-radius:8px; user-select:none; cursor:pointer; }
    .ionRow:hover { background:#0f1726; }
    .swatch { width:18px; height:18px; border-radius:4px; border:1px solid rgba(255,255,255,.35); }
    .ionName { }
    .chev { width:18px; text-align:center; color:#a9b3c8; }

    .sublist { margin-left: 26px; display:none; }
    .sublist.open { display:block; }

    .structRow, .stratRow { display:grid; grid-template-columns: 14px 1fr 18px; gap:8px; align-items:center;
      padding:4px 6px; border-radius:6px; cursor:pointer; }
    .structRow:hover, .stratRow:hover { background:#0c1322; }
    .smSwatch { width:14px; height:14px; border-radius:3px; border:1px solid rgba(255,255,255,.28); }
    .chevSm { width:18px; text-align:center; color:#8fa0b8; }

    .tooltip { position:fixed; pointer-events:none; background:rgba(0,0,0,.9); color:#fff; padding:8px 10px; border-radius:8px; font-size:12px; line-height:1.3; display:none; z-index:10; box-shadow:0 6px 18px rgba(0,0,0,.45); }
    .dimmed { opacity: .18; transition: opacity .15s ease; }
    .highlight { opacity: 1; transition: opacity .15s ease; }

    .labelText { fill:#e8e8ea; stroke:#0a0c12; stroke-width:2; paint-order:stroke fill; font-size:12px; }
    .labelPath { fill:none; stroke:none; }
  </style>
</head>
<body>
  <header>
    <strong>Sunburst (Interactive Legend)</strong>
    <span id="rtStats" style="font-size:12px;color:#9fb3cc;"></span>
  </header>

  <div id="wrap">
    <div id="chartCard">
      <div id="chart" class="chartBody"></div>
      <div id="legend" class="legend">
        <h4>Legend</h4>
        <div class="legendGroup"></div>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const DEF_COND = 1e-6;
    const SCALE_MODE = 'log';
    const ANGLE_BY_COUNT = true;

    let root, svgGlobal, gArcs, gLabels, nodesGlobal, sideGlobal, outerRadiusForGlobal;
    let colorIon;

    // Persistent selections (click)
    const selIons = new Set();
    const selStructs = new Set();   // keys: ion|struct
    const selStrats = new Set();    // keys: ion|struct|strat

    // Hover (transient) selection
    let hoverKey = null;            // string key identifying the branch

    document.addEventListener('DOMContentLoaded', async () => {
      const dataObj = await (await fetch('data.simplified.json', {cache: 'no-store'})).json();
      draw(dataObj);
      window.addEventListener('resize', () => requestAnimationFrame(() => draw(dataObj)));
    });

    function obj2children(obj){
      return Object.entries(obj).map(([ion, structures]) => ({
        name: ion,
        children: Object.entries(structures || {}).map(([structure, strategies]) => ({
          name: structure,
          children: Object.entries(strategies || {}).map(([strategy, formulas]) => ({
            name: strategy,
            children: Object.entries(formulas || {}).map(([formula, vals]) => {
              const nums = Array.isArray(vals) ? vals.map(Number).filter(x => Number.isFinite(x) && x>0) : [];
              return { name: formula, values: nums };
            })
          }))
        }))
      }));
    }

    function computeLeafCond(h, def){
      h.each(n=>{
        if (n.data && Array.isArray(n.data.values)) {
          const vals = n.data.values.filter(Number.isFinite);
          if (vals.length) { n.data.cond = vals[0]; n.data.hasCond = true; }
          else { n.data.cond = def; n.data.hasCond = false; }
        }
      });
    }

    function draw(dataObj){
      const chartEl = document.getElementById('chart');
      const legendEl = document.getElementById('legend').querySelector('.legendGroup');
      const tooltip = document.getElementById('tooltip');
      chartEl.innerHTML = '';
      legendEl.innerHTML = '';

      const rect = chartEl.getBoundingClientRect();
      let w = rect.width  || chartEl.clientWidth  || 800;
      let h = rect.height || chartEl.clientHeight || 640;
      if (!w || !h) { w = 800; h = 640; }
      const side = Math.floor(Math.min(w, h));
      sideGlobal = Math.max(side, 400);

      const data = { name:'root', children: obj2children(dataObj) };

      root = d3.hierarchy(data, d => d.children)
        .sum(d => (Array.isArray(d?.values) ? 1 : 0))
        .sort((a,b) => (b.value||0) - (a.value||0));

      const ringThickness = Math.max(36, sideGlobal * 0.06);
      const leafBase      = Math.max(10, sideGlobal * 0.02);
      const extraLeafMax  = Math.max(110, sideGlobal * 0.20);

      computeLeafCond(root, DEF_COND);
      d3.partition().size([2*Math.PI, (root.height + 1) * ringThickness])(root);

      const leaves = root.leaves();
      const totalLeaves = leaves.length;
      const withCond = leaves.filter(d => d.data.hasCond).length;
      document.getElementById('rtStats').textContent =
        `Formulas with conductivity (selected): ${withCond}/${totalLeaves} (${(withCond/Math.max(1,totalLeaves)*100).toFixed(1)}%)`;

      let condVals = leaves.map(l => l.data.cond || DEF_COND).filter(Number.isFinite);
      if (!condVals.length) condVals = [DEF_COND];
      let [cmin, cmax] = d3.extent(condVals);
      if (!(cmax > cmin)) { cmin = cmin*0.8; cmax = cmax*1.2; }

      const baseScale = (SCALE_MODE==='linear'
        ? d3.scaleLinear().domain([cmin, cmax])
        : d3.scaleLog().domain([Math.max(cmin, 1e-12), Math.max(cmax, 1e-12)]));
      const condScale = baseScale.range([0, extraLeafMax]).clamp(true);

      const ions = (root.children || []).map(d=>d.data.name);
      colorIon = d3.scaleOrdinal(ions, d3.quantize(t => d3.interpolateRainbow(t), Math.max(3, ions.length)));

      const outerRadiusFor = d => d.children
        ? d.y1
        : d.y1 + leafBase + condScale(d.data.cond || DEF_COND);
      outerRadiusForGlobal = outerRadiusFor;

      const svg = d3.select(chartEl).append('svg')
        .attr('width','100%').attr('height','100%')
        .attr('viewBox', `${-sideGlobal/2} ${-sideGlobal/2} ${sideGlobal} ${sideGlobal}`);
      svgGlobal = svg;

      const arc = d3.arc()
        .startAngle(d=>d.x0)
        .endAngle(d=>d.x1)
        .padAngle(d=>Math.min(0.006, (d.x1-d.x0)/6))
        .padRadius(sideGlobal * 0.45)
        .innerRadius(d=>d.y0)
        .outerRadius(d=> outerRadiusFor(d));

      const g = svg.append('g');
      gArcs = g;

      const nodes = root.descendants().filter(d=>d.depth>0);
      nodesGlobal = nodes;

      const paths = g.selectAll('path')
        .data(nodes)
        .join('path')
        .attr('d', arc)
        .attr('fill', d => {
          let ion=d; while(ion.depth>1) ion=ion.parent;
          const base = colorIon(ion.data.name);
          if (!d.children && d.data && d.data.hasCond === false) {
            const c = d3.color(base); c.opacity = 0.55; return c.formatRgb();
          }
          return base;
        })
        .attr('stroke', '#fff').attr('stroke-opacity', 0.28)
        .attr('stroke-width', d => (d.x1-d.x0) < 0.002 ? 0 : Math.max(0.6, sideGlobal * 0.0012));

      // tag dataset keys for legend matching
      paths.each(function(d){
        let ion=d; while(ion && ion.depth>1) ion=ion.parent;
        let struct=d; while(struct && struct.depth>2) struct=struct.parent;
        let strat=d; while(strat && strat.depth>3) strat=strat.parent;
        this.dataset.ion = ion?.data?.name || '';
        this.dataset.struct = struct?.data?.name || '';
        this.dataset.strat = strat?.data?.name || '';
      });

      const showVal = (v) => (!Number.isFinite(v) ? 'n/a' : (v < 0.01 ? `${(v*1000).toFixed(3)} mS·cm⁻¹` : `${Number(v).toPrecision(3)} S·cm⁻¹`));
      paths.on('mousemove', (evt, d) => {
        const trail = d.ancestors().reverse().slice(1).map(n=>n.data.name).join(' → ');
        let html = `<strong>${trail}</strong>`;
        if (!d.children) {
          if (d.data.hasCond) {
            html += `<br/>σ (selected): ${showVal(d.data.cond)}<br/><small>RT preferred; else first available</small>`;
          } else {
            html += `<br/><em>No conductivity found — default height</em>`;
          }
        } else {
          html += `<br/>Share (by formula count): ${d.value}`;
        }
        tooltip.style.display = 'block';
        tooltip.innerHTML = html;
        tooltip.style.left = (evt.clientX + 10) + 'px';
        tooltip.style.top  = (evt.clientY + 10) + 'px';
      }).on('mouseleave', () => { document.getElementById('tooltip').style.display = 'none'; });

      // Build hierarchical legend
      buildLegendTree(legendEl);
      applyHighlight(); // initial (no selection)
    }

    function buildLegendTree(container){
      container.innerHTML = '';
      (root.children || []).forEach((ionNode) => {
        const ion = ionNode.data.name;
        const ionRow = document.createElement('div'); ionRow.className='ionRow';
        const sw  = document.createElement('div'); sw.className='swatch'; sw.style.background = colorIon(ion);
        const nm  = document.createElement('div'); nm.className='ionName'; nm.textContent = ion;
        const cv  = document.createElement('div'); cv.className='chev'; cv.textContent = '▸';
        ionRow.appendChild(sw); ionRow.appendChild(nm); ionRow.appendChild(cv);
        container.appendChild(ionRow);

        const subStruct = document.createElement('div'); subStruct.className='sublist';
        container.appendChild(subStruct);

        // Structures
        (ionNode.children || []).forEach((structNode) => {
          const struct = structNode.data.name;
          const srow = document.createElement('div'); srow.className='structRow';
          const sm = document.createElement('div'); sm.className='smSwatch';
          sm.style.background = d3.color(colorIon(ion)).brighter(0.8).formatRgb();
          const sn = document.createElement('div'); sn.textContent = struct;
          const cv2 = document.createElement('div'); cv2.className='chevSm'; cv2.textContent = '▸';
          srow.appendChild(sm); srow.appendChild(sn); srow.appendChild(cv2);
          subStruct.appendChild(srow);

          const subStrat = document.createElement('div'); subStrat.className='sublist';
          subStruct.appendChild(subStrat);

          // Strategies
          (structNode.children || []).forEach((stratNode) => {
            const strat = stratNode.data.name;
            const trow = document.createElement('div'); trow.className='stratRow';
            const tm = document.createElement('div'); tm.className='smSwatch';
            tm.style.background = d3.color(colorIon(ion)).brighter(1.4).formatRgb();
            const tn = document.createElement('div'); tn.textContent = strat;
            const cv3 = document.createElement('div'); cv3.className='chevSm'; cv3.textContent = ''; // leaf
            trow.appendChild(tm); trow.appendChild(tn); trow.appendChild(cv3);
            subStrat.appendChild(trow);

            trow.addEventListener('mouseenter', () => { hoverKey = `ION:${ion}|STRUCT:${struct}|STRAT:${strat}`; applyHighlight(); });
            trow.addEventListener('mouseleave', () => { hoverKey = null; applyHighlight(); });
            trow.addEventListener('click', (ev) => {
              ev.stopPropagation();
              const key = `ION:${ion}|STRUCT:${struct}|STRAT:${strat}`;
              if (selStrats.has(key)) selStrats.delete(key); else selStrats.add(key);
              applyHighlight();
            });
          });

          srow.addEventListener('mouseenter', () => { hoverKey = `ION:${ion}|STRUCT:${struct}`; applyHighlight(); });
          srow.addEventListener('mouseleave', () => { hoverKey = null; applyHighlight(); });
          srow.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const key = `ION:${ion}|STRUCT:${struct}`;
            if (selStructs.has(key)) selStructs.delete(key); else selStructs.add(key);
            subStrat.classList.toggle('open');
            cv2.textContent = subStrat.classList.contains('open') ? '▾' : '▸';
            applyHighlight();
          });
        });

        ionRow.addEventListener('mouseenter', () => { hoverKey = `ION:${ion}`; applyHighlight(); });
        ionRow.addEventListener('mouseleave', () => { hoverKey = null; applyHighlight(); });
        ionRow.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (selIons.has(ion)) selIons.delete(ion); else selIons.add(ion);
          subStruct.classList.toggle('open');
          cv.textContent = subStruct.classList.contains('open') ? '▾' : '▸';
          applyHighlight();
        });
      });
    }

    function matchBranch(el){
      const ion = el.dataset.ion || '';
      const struct = el.dataset.struct || '';
      const strat = el.dataset.strat || '';

      if (hoverKey){
        if (hoverKey === `ION:${ion}`) return true;
        if (hoverKey === `ION:${ion}|STRUCT:${struct}`) return true;
        if (hoverKey === `ION:${ion}|STRUCT:${struct}|STRAT:${strat}`) return true;
        return false;
      }

      if (selIons.size || selStructs.size || selStrats.size){
        if (selIons.has(ion)) return true;
        if (selStructs.has(`ION:${ion}|STRUCT:${struct}`)) return true;
        if (selStrats.has(`ION:${ion}|STRUCT:${struct}|STRAT:${strat}`)) return true;
        return false;
      }
      return true;
    }

    function applyHighlight(){
      if (!gArcs) return;
      gArcs.selectAll('path').each(function(){
        const on = matchBranch(this);
        this.classList.toggle('dimmed', !on);
        this.classList.toggle('highlight', on);
      });
    }
  </script>
</body>
</html>
