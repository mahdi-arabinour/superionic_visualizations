<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Radial Tree — Ion-colored subtrees (explicit 4 layers)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<style>
  :root{ --bg:#ffffff; --panel:#f8fafc; --grid:#e5e7eb; --ink:#0f172a; --muted:#64748b;
         --chip:#f1f5f9; --chip-border:#cbd5e1; --pill:#e2e8f0; --tip:#ffffff; --tipb:#cbd5e1; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{display:flex;flex-wrap:wrap;gap:10px;align-items:center;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--grid);position:sticky;top:0;z-index:5}
  label{font-size:13px;display:flex;align-items:center;gap:6px}
  input[type="number"],input[type="range"],select{background:#fff;border:1px solid #cbd5e1;border-radius:8px;padding:6px 8px}
  input[type="range"]{accent-color:#60a5fa}
  #status{margin-left:auto;color:var(--muted);font-size:12px}
  #chart{width:100%;height:90vh}
  aside{position:absolute;top:60px;right:0;width:340px;height:calc(100% - 60px);overflow:auto;background:var(--panel);border-left:1px solid var(--grid);padding:12px}
  aside h3{margin:10px 0 6px;color:#334155;font-size:13px}
  .legend{display:flex;flex-wrap:wrap;gap:6px}
  .chip{display:inline-flex;align-items:center;gap:6px;background:var(--chip);border:1px solid var(--chip-border);border-radius:999px;padding:4px 10px;cursor:pointer}
  .chip .sw{width:12px;height:12px;border-radius:3px;border:1px solid #fff3}
  .chip.inactive{opacity:.35}
  .pill{background:var(--pill);border:1px solid #cbd5e1;border-radius:999px;padding:6px 10px;cursor:pointer}
  .tip{position:fixed;pointer-events:none;background:var(--tip);border:1px solid var(--tipb);border-radius:6px;padding:6px 8px;font-size:12px;box-shadow:0 10px 28px rgba(15,23,42,.1);opacity:0;transition:opacity .12s}
  .note{color:var(--muted);font-size:12px;margin-top:6px}
  .lbl{paint-order:stroke;stroke:#fff;stroke-width:3px;fill:#0f172a}
</style>
</head>
<body>
<header>
  <label>Default σ: <input type="number" id="sigmaDefault" step="any" value="1e-6" style="width:90px"></label>
  <label><input type="checkbox" id="useLog" checked> log₁₀(σ) for leaf length</label>
  <label>Base edge: <input type="range" id="baseEdge" min="30" max="120" step="2" value="60"><span id="baseEdgeLbl">60</span> px</label>
  <label>Leaf extra: <input type="range" id="leafMin" min="6" max="80" step="1" value="10"><span id="leafMinLbl">10</span> px
                     <input type="range" id="leafMax" min="20" max="240" step="2" value="120"><span id="leafMaxLbl">120</span> px</label>
  <button id="resetView" class="pill">↺ Reset Zoom</button>
  <div id="status">Loading data.csv…</div>
</header>

<svg id="chart"></svg>

<aside>
  <h3>Filter ions</h3>
  <div id="ionLegend" class="legend"></div>
  <div style="display:flex;gap:8px;margin:6px 0 10px">
    <button id="ion-btn-all" class="pill">Select all</button>
    <button id="ion-btn-clear" class="pill">Clear all</button>
  </div>

  <!-- CSV fallback (auto-shows if fetch fails) -->
  <div id="csv-fallback" style="display:none;margin:10px 0 14px">
    <button id="pick-csv" class="pill">Choose data.csv…</button>
    <input id="csv-input" type="file" accept=".csv" style="display:none">
    <div class="note">If you opened this file locally or on github.com, use this to load the CSV.</div>
  </div>

  <h3>Labels</h3>
  <label><input type="checkbox" id="showIonLbl" checked> Ion</label>
  <label><input type="checkbox" id="showStructLbl" checked> Structure</label>
  <label><input type="checkbox" id="showDopingLbl" checked> Doping</label>
  <label><input type="checkbox" id="showFormulaLbl"> Formula</label>

  <h3>Label sizes</h3>
  <label>Structure <input type="range" id="fsStruct" min="8" max="14" step="1" value="10"><span id="fsStructLbl">10</span> px</label>
  <label>Doping <input type="range" id="fsDoping" min="7" max="13" step="1" value="9"><span id="fsDopingLbl">9</span> px</label>
  <label>Formula <input type="range" id="fsFormula" min="6" max="12" step="1" value="8"><span id="fsFormulaLbl">8</span> px</label>

  <h3>Declutter (min angle gap, °)</h3>
  <label>Structure <input type="number" id="gapStruct" value="3" step="1" style="width:64px"></label>
  <label>Doping <input type="number" id="gapDoping" value="2" step="1" style="width:64px"></label>
  <label>Formula <input type="number" id="gapFormula" value="1" step="1" style="width:64px"></label>

  <h3>Leaf spacing</h3>
  <label>Formula leaf spread (px along arc)
    <input type="range" id="leafSpread" min="0" max="40" step="1" value="12"><span id="leafSpreadLbl">12</span>
  </label>

  <div class="note">Dashed leaf node = default σ used • Click Ion chip to filter/multi-select • Click an Ion label to zoom • Reset Zoom to go back</div>
</aside>

<div id="tooltip" class="tip"></div>

<script>
/* ---------- Palettes (YOUR colors) ---------- */
const ION_COLORS = {
  "Li+":  "#ff5252","Na+":  "#81d4fa","K+":   "#004d40","Ag+":  "#f48fb1",
  "O2-":  "#6d4c41","Zn2+": "#c2185b","H+":   "#ffd54f","Rb+":  "#43a047",
  "F-":   "#ff8a65","Cu+":  "#5c6bc0","Mg2+": "#26c6da","In3+": "#c0ca33",
  "I-":   "#ec407a","Sn4+": "#7e57c2"
};
const STRUCT_COLORS = {
  "Others":"#9e9e9e","Polymeric":"#ff7043","Argyrodite":"#ab47bc","Halide":"#26a69a",
  "Amorphous":"#f6bf26","NASICON":"#66bb6a","Anti-perovskite":"#0d47a1","Spinel":"#8d6e63"
};
const getIonColor    = n => ION_COLORS[n]    || "#9aa5b1";

/* ---------- Elements & State ---------- */
const svg = d3.select('#chart');
const tip = d3.select('#tooltip');
const say = t => (document.getElementById('status').textContent = t);
let DATA=null, COLS=null, WIDTH=0, HEIGHT=0, R=0;
let selectedIons = null;          // null=ALL, Set>0 whitelist, Set size 0 = none
let ionLegEl = null;
function applyChipVisuals(){
  if(!ionLegEl) return;
  const chips = ionLegEl.querySelectorAll('.chip');
  if(selectedIons===null) chips.forEach(ch=>ch.classList.remove('inactive'));
  else if(selectedIons.size===0) chips.forEach(ch=>ch.classList.add('inactive'));
  else chips.forEach(ch=>ch.classList.toggle('inactive', !selectedIons.has(ch.dataset.ion)));
}
let focusIon = null;

/* ---------- Robust CSV loader ---------- */
const CSV_URL = new URL('data.csv', document.baseURI).href;
async function loadCSVWithFallback(){
  try { return await d3.csv(CSV_URL); }
  catch(e){
    console.warn('CSV fetch failed; enabling picker', e);
    const fb=document.getElementById('csv-fallback'), btn=document.getElementById('pick-csv'), inp=document.getElementById('csv-input');
    if(!fb||!btn||!inp) throw e;
    fb.style.display='block';
    return await new Promise((resolve,reject)=>{
      btn.addEventListener('click', ()=>inp.click(), {once:true});
      inp.addEventListener('change', ()=>{
        const f = inp.files && inp.files[0]; if(!f) return reject(new Error('No file selected'));
        const r = new FileReader();
        r.onload = ()=>{ try{ resolve(d3.csvParse(r.result)); }catch(err){ reject(err); } };
        r.onerror = reject; r.readAsText(f);
      }, {once:true});
    });
  }
}

/* ---------- Helpers ---------- */
function parseSigma(v){
  const s = String(v??'').trim(); if(!s) return NaN;
  const fixed = s.replace(/[,\s]/g,'').replace(/[−–—-]/g,'-')
                 .replace(/([0-9.]+)\s*(?:×|x|\*)\s*10\^?([+\-]?\d+)/i,'$1e$2');
  const n = Number(fixed); return Number.isFinite(n) ? n : NaN;
}
function buildLeaves(rows){
  const {ion,struct,doping,formula,sigma} = COLS;
  const def = parseFloat(document.getElementById('sigmaDefault').value) || 1e-6;
  const sel = focusIon ? new Set([focusIon]) : selectedIons;
  const leaves=[];
  for(const r of rows){
    const ionV=(r[ion]||'Other').toString().trim();
    if(sel!==null && !sel.has(ionV)) continue;
    const structV=(r[struct]||'Others').toString().trim();
    const dopV=(r[doping]||'(none)').toString().trim();
    const formV=(r[formula]||'(formula)').toString().trim();
    let s=parseSigma(r[sigma]); const isDef=!(Number.isFinite(s)&&s>0); if(isDef) s=def;
    leaves.push({ion:ionV,structure:structV,dop:dopV,form:formV,sigma:s,isDefault:isDef});
  }
  return leaves;
}

/* ---------- Draw ---------- */
function drawTree(rows){
  // robust sizing
  let bb = document.getElementById('chart').getBoundingClientRect();
  if(!bb.width||!bb.height){
    const p = document.body.getBoundingClientRect();
    d3.select('#chart').attr('width', p.width).attr('height', Math.max(600, p.height*0.9));
    bb = document.getElementById('chart').getBoundingClientRect();
  }
  WIDTH=bb.width; HEIGHT=bb.height; R=Math.min(WIDTH,HEIGHT)/2 - 40;

  svg.attr('viewBox', `${-WIDTH/2} ${-HEIGHT/2} ${WIDTH} ${HEIGHT}`).selectAll('*').remove();
  const g = svg.append('g').attr('class','tree');

  // controls
  const useLog  = document.getElementById('useLog').checked;
  const baseEdge= +document.getElementById('baseEdge').value;
  const leafMin = +document.getElementById('leafMin').value;
  const leafMax = +document.getElementById('leafMax').value;
  const fsStruct= +document.getElementById('fsStruct').value;
  const fsDoping= +document.getElementById('fsDoping').value;
  const fsFormula=+document.getElementById('fsFormula').value;
  const spread  = +document.getElementById('leafSpread').value;
  document.getElementById('baseEdgeLbl').textContent=baseEdge;
  document.getElementById('leafMinLbl').textContent=leafMin;
  document.getElementById('leafMaxLbl').textContent=leafMax;
  document.getElementById('fsStructLbl').textContent=fsStruct;
  document.getElementById('fsDopingLbl').textContent=fsDoping;
  document.getElementById('fsFormulaLbl').textContent=fsFormula;
  document.getElementById('leafSpreadLbl').textContent=spread;

  // hierarchy
  const leaves = buildLeaves(rows);
  const root = {name:'root',children:[]};
  const grouped = d3.group(leaves, d=>d.ion, d=>d.structure, d=>d.dop);
  for(const [ion,g1] of grouped){
    const nIon={name:ion,children:[]};
    for(const [st,g2] of g1){
      const nSt={name:st,children:[]};
      for(const [dop,g3] of g2){
        const nD={name:dop,children:[]};
        for(const d of g3) nD.children.push({name:d.form,sigma:d.sigma,isDefault:d.isDefault});
        nSt.children.push(nD);
      }
      nIon.children.push(nSt);
    }
    root.children.push(nIon);
  }
  const H = d3.hierarchy(root);
  d3.cluster().size([2*Math.PI,1])(H);

  /* ===== Explicit band radii so 4 layers are visually clear ===== */
  const rIon     = 1 * baseEdge;                  // Ion ring
  const rStruct  = 2 * baseEdge;                  // Structure ring
  const rDoping  = 3 * baseEdge + 0.85 * baseEdge; // Doping ring (extra gap after structure)
  const rFormula = rDoping   + 0.90 * baseEdge;   // Start radius for Formula leaves

  H.each(n=>{
    if(!n.children) return;
    if(n.depth===1) n.y = Math.min(R, rIon);
    else if(n.depth===2) n.y = Math.min(R, rStruct);
    else if(n.depth===3) n.y = Math.min(R, rDoping);
  });

  // σ → extra length from rFormula outward
  const def = parseFloat(document.getElementById('sigmaDefault').value) || 1e-6;
  const vals = H.leaves().map(l=>+l.data.sigma).filter(v=>Number.isFinite(v)&&v>0);
  let sMin = vals.length? d3.min(vals) : def;
  let sMax = vals.length? d3.max(vals) : def*10;
  if(sMin===sMax){ sMin*=0.9; sMax*=1.1; }
  const scaleLin=d3.scaleLinear().domain([sMin,sMax]).range([leafMin,leafMax]).nice();
  const scaleLog=d3.scaleLog().domain([Math.max(sMin,Number.MIN_VALUE),sMax]).range([leafMin,leafMax]);
  const extra = v => (useLog? scaleLog:scaleLin)(Number.isFinite(+v)&&+v>0? +v : def);

  const margin=12, maxExtra=Math.max(8,(R-margin)-rFormula);
  const rescale = d3.scaleLinear().domain([leafMin,leafMax]).range([leafMin,maxExtra]);
  H.each(n=>{ if(!n.children) n.y = rFormula + rescale(extra(n.data.sigma)); });

  // spread along arc for formulas
  if(spread>0){
    H.descendants().filter(d=>d.depth===3).forEach(p=>{
      const kids=(p.children||[]).filter(c=>!c.children);
      const n=kids.length; if(n<=1) return;
      kids.sort((a,b)=>a.x-b.x);
      kids.forEach((c,i)=>{ const r=Math.max(c.y,1); c.x += ((i-(n-1)/2) * (spread/r)); });
    });
  }

  // helper: ion color for any node/link by ancestor
  function ionColorFromNode(node){
    const ionNode = node.ancestors().find(x => x.depth === 1) || node;
    const ionName = ionNode?.data?.name || 'Other';
    return getIonColor(ionName);
  }

  // links — Doping thicker & dashed, Formula thinner — all colored by Ion
  const link = d3.linkRadial().angle(d=>d.x).radius(d=>d.y);
  g.append('g').attr('fill','none').selectAll('path').data(H.links()).join('path')
    .attr('stroke-width', d => {
      const dep = d.target.depth;
      if (dep === 3) return 1.8;   // Doping
      if (dep >= 4) return 0.8;    // Formula
      return 1.0;                  // Ion/Structure
    })
    .attr('stroke-dasharray', d => d.target.depth === 3 ? '2,2' : null)
    .attr('stroke', d => ionColorFromNode(d.target))
    .attr('d', d => link({source:d.source, target:d.target}));

  // nodes — larger for Doping, small for Formula — all colored by Ion
  const nodes = g.append('g').selectAll('g.n').data(H.descendants()).join('g')
    .attr('class','n')
    .attr('transform',d=>`rotate(${d.x*180/Math.PI-90}) translate(${d.y},0)`);
  nodes.append('circle')
    .attr('r', d => (d.depth===3 ? 3.0 : (d.children ? 2.2 : 1.6)))
    .attr('fill', d => ionColorFromNode(d))
    .attr('stroke','#fff')
    .attr('stroke-width', d => d.depth===3 ? 1.1 : 0.8)
    .attr('stroke-dasharray', d => (!d.children && d.data?.isDefault) ? '3,2' : null)
    .on('mousemove',(e,d)=>showTip(e,d)).on('mouseleave',hideTip)
    .on('click',(e,d)=>{ if(d.depth===1){ setFocusIon(d.data.name); zoomToIon(d); } });

  // labels toggles
  const wantIon=document.getElementById('showIonLbl').checked;
  const wantStruct=document.getElementById('showStructLbl').checked;
  const wantDoping=document.getElementById('showDopingLbl').checked;
  const wantFormula=document.getElementById('showFormulaLbl').checked;
  const layers=[
    {depth:1,show:wantIon,fs:13,off:8},
    {depth:2,show:wantStruct,fs:fsStruct,off:6,gap:+document.getElementById('gapStruct').value},
    {depth:3,show:wantDoping,fs:fsDoping,off:5,gap:+document.getElementById('gapDoping').value},
    {depth:4,show:wantFormula,fs:fsFormula,off:0,gap:+document.getElementById('gapFormula').value}
  ];
  for(const L of layers){
    if(!L.show) continue;
    let arr=H.descendants().filter(d=>d.depth===L.depth);
    if(L.gap){
      const min=L.gap*Math.PI/180; const kept=[]; arr=arr.sort((a,b)=>a.x-b.x);
      for(const d of arr){ if(!kept.length || Math.abs(d.x-kept[kept.length-1].x)>=min) kept.push(d); }
      arr=kept;
    }
    g.append('g').attr('font-size',L.fs).attr('font-weight',L.depth===1?'700':'400')
      .selectAll('text').data(arr).join('text').attr('class','lbl')
      .attr('transform',d=>{
        const a=d.x, r=(L.depth===4? d.y : d.y+L.off);
        const x=Math.cos(a-Math.PI/2)*r, y=Math.sin(a-Math.PI/2)*r;
        const rot=a*180/Math.PI-90, flip=a>=Math.PI?180:0;
        return `translate(${x},${y}) rotate(${rot+flip})`;
      })
      .attr('text-anchor',d=>d.x>=Math.PI?'end':'start')
      .text(d=>d.data?.structureLabel || d.data?.name || '')
      .style('cursor', L.depth===1? 'pointer' : null)
      .on('click',(e,d)=>{ if(L.depth===1){ setFocusIon(d.data.name); zoomToIon(d); } });
  }

  // caption & status
  g.append('text').attr('x',0).attr('y',HEIGHT/2-10).attr('text-anchor','middle').attr('fill','#64748b').attr('font-size',12)
    .text('Ion → Structure → Doping → Formula • leaf length ∝ σ • color = Ion');
  say(`Nodes: ${H.descendants().length} • Leaves: ${H.leaves().length}`);
}

/* ---------- Tooltip ---------- */
function showTip(e,d){
  const a=d.ancestors().reverse();
  const ion=a[1]?.data?.name||'(ion)';
  const st=a[2]?.data?.name||'(structure)';
  const dop=a[3]?.data?.name||'(doping)';
  let html=`<b>${ion}</b> → ${st} → ${dop}`;
  if(!d.children){
    const v=Number(d.data?.sigma), def=parseFloat(document.getElementById('sigmaDefault').value)||1e-6;
    html+=`<br><b>${d.data?.name}</b>`;
    html+=`<br>σ: ${Number.isFinite(v)&&v>0? v.toExponential(3): ('default '+def.toExponential(3))} S·cm⁻¹`;
  }
  tip.html(html).style('left',(e.clientX+12)+'px').style('top',(e.clientY+12)+'px').style('opacity',1);
}
function hideTip(){ tip.style('opacity',0); }

/* ---------- Zoom ---------- */
const zoom = d3.zoom().scaleExtent([0.5,6]).on('zoom', ev => svg.select('g.tree').attr('transform', ev.transform));
svg.call(zoom);
function zoomToIon(node){
  const a=node.x-Math.PI/2, x=Math.cos(a)*node.y, y=Math.sin(a)*node.y;
  svg.transition().duration(800).call(zoom.transform,
    d3.zoomIdentity.translate(WIDTH/2,HEIGHT/2).scale(2.2).translate(-x,-y));
}
document.getElementById('resetView').addEventListener('click', ()=>{
  svg.transition().duration(800).call(zoom.transform, d3.zoomIdentity.translate(WIDTH/2,HEIGHT/2).scale(1));
  focusIon=null; drawTree(DATA);
});

/* ---------- Focus & legend ---------- */
function setFocusIon(n){ focusIon=n; drawTree(DATA); }
function buildIonLegend(rows){
  const ions=[...new Set(rows.map(r=>(r[COLS.ion]||'Other').toString().trim()))].sort((a,b)=>a.localeCompare(b));
  ionLegEl=document.getElementById('ionLegend'); ionLegEl.innerHTML='';
  ions.forEach(i=>{
    const chip=document.createElement('div'); chip.className='chip'; chip.dataset.ion=i;
    const sw=document.createElement('div'); sw.className='sw'; sw.style.background=getIonColor(i);
    chip.appendChild(sw); chip.appendChild(document.createTextNode(i)); ionLegEl.appendChild(chip);
  });
  ionLegEl.addEventListener('click', ev=>{
    const chip=ev.target.closest('.chip'); if(!chip) return;
    const n=chip.dataset.ion;
    if(selectedIons===null) selectedIons=new Set([n]);
    else{ if(selectedIons.has(n)) selectedIons.delete(n); else selectedIons.add(n); }
    applyChipVisuals(); if(DATA) drawTree(DATA);
  });
  document.getElementById('ion-btn-all').onclick=()=>{ selectedIons=null; applyChipVisuals(); if(DATA) drawTree(DATA); };
  document.getElementById('ion-btn-clear').onclick=()=>{ selectedIons=new Set(); applyChipVisuals(); if(DATA) drawTree(DATA); };
  applyChipVisuals();
}

/* ---------- Controls ---------- */
[
 "showIonLbl","showStructLbl","showDopingLbl","showFormulaLbl",
 "fsStruct","fsDoping","fsFormula","gapStruct","gapDoping","gapFormula",
 "leafSpread","sigmaDefault","useLog","baseEdge","leafMin","leafMax"
].forEach(id => { const el=document.getElementById(id); if(el) el.addEventListener('input', ()=>DATA&&drawTree(DATA)); });
window.addEventListener('resize', ()=>DATA&&drawTree(DATA));

/* ---------- Init ---------- */
async function init(){
  say('Loading data.csv…');
  const rows = await loadCSVWithFallback();
  if(!rows?.length){ say('No rows found in data.csv'); return; }

  COLS = {
    ion:"Ion Type",
    struct:"Structure Group",
    doping:"Doping / and or GB Strategy",
    formula:"Superionic Conductor Formula (Chemical)",
    sigma:"Conductivity σ (S/cm)"
  };

  const miss = Object.values(COLS).filter(h => !rows.columns.includes(h));
  if(miss.length){ say("Missing columns: "+miss.join(", ")); return; }

  DATA = rows;
  buildIonLegend(rows);

  // Show ALL by default, then draw after layout settles
  selectedIons=null; applyChipVisuals();
  await new Promise(r => requestAnimationFrame(()=>requestAnimationFrame(r)));
  drawTree(DATA);
  say(`Rows: ${rows.length}`);
}
init();
</script>
</body>
</html>
