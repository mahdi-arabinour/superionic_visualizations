<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Radial Tidy Tree — Canonical Grouping (Zoom + Reset)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<style>
  :root{
    /* Light theme palette */
    --bg:#ffffff;              /* page background */
    --panel:#f8fafc;           /* header & side panel background */
    --grid:#d1d5db;            /* borders & subtle lines */
    --text:#1e293b;            /* primary text */
    --muted:#64748b;           /* secondary text */
    --chip:#f1f5f9;            /* legend chip background */
    --chip-border:#cbd5e1;     /* legend chip border */
    --node-stroke:#ffffff;     /* svg node outline (same as bg) */
    --link:#94a3b8;            /* radial link color */
    --tip-bg:#f8fafc;          /* tooltip background */
    --tip-border:#cbd5e1;      /* tooltip border */
    --input-bg:#ffffff;        /* inputs bg */
    --input-border:#cbd5e1;    /* inputs border */
    --pill-bg:#e2e8f0;         /* reset button background */
    --pill-text:#1e293b;       /* reset button text */
  }

  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,Segoe UI,Roboto,sans-serif;
    background:var(--bg);
    color:var(--text);
  }

  header{
    display:flex;flex-wrap:wrap;gap:10px;align-items:center;
    padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--grid);
    position:sticky;top:0;z-index:10;
  }
  label{font-size:13px;display:flex;align-items:center;gap:6px;color:var(--text);}
  input[type="number"],input[type="range"],select{
    background:var(--input-bg);color:var(--text);
    border:1px solid var(--input-border);border-radius:8px;padding:6px 8px;
  }
  input[type="range"]{ accent-color:#60a5fa; }
  #status{margin-left:auto;font-size:12px;color:var(--muted);}
  #chart{width:100%;height:90vh;background:transparent;}

  aside{
    position:absolute;top:60px;right:0;width:330px;height:calc(100% - 60px);overflow:auto;
    background:var(--panel);border-left:1px solid var(--grid);padding:10px;
  }
  aside h3{margin:8px 0;font-size:13px;color:#cbd5e1;}
  select[multiple]{width:100%;min-height:120px;background:var(--input-bg);color:var(--text);border:1px solid var(--input-border);}

  .legend{display:flex;flex-wrap:wrap;gap:6px;}
  .chip{
    display:flex;align-items:center;gap:6px;font-size:12px;background:var(--chip);border:1px solid var(--chip-border);
    padding:4px 6px;border-radius:999px;color:var(--text);
  }
  .sw{width:10px;height:10px;border-radius:3px;border:1px solid #fff3;}

  .tip{
    position:fixed;pointer-events:none;background:var(--tip-bg);color:var(--text);
    border:1px solid var(--tip-border);padding:6px 8px;border-radius:6px;font-size:12px;
    box-shadow:0 10px 28px rgba(0,0,0,.35);opacity:0;transition:opacity .15s;
  }

  /* Label colors tuned for dark */
  .lbl-ion{fill:#e5e7eb;font-weight:700;}
  .lbl-struct{fill:#cbd5e1;font-weight:500;}
  .lbl-doping{fill:#aeb8c7;font-weight:400;}
  .lbl-formula{fill:#94a3b8;font-weight:400;}

  .viz-caption{font-size:12px;fill:#aeb8c7;text-anchor:middle;}

  /* Reset button style */
  .pill{
    background:var(--pill-bg);color:var(--pill-text);border:none;border-radius:999px;
    padding:8px 12px;font-size:13px;cursor:pointer;
  }
  .pill:hover{opacity:0.9}
</style>
</head>
<body>
<header>
  <!-- Reads ./data.csv -->
  <label>Default σ: <input type="number" id="sigmaDefault" step="any" value="1e-6" style="width:90px;"></label>
  <label><input type="checkbox" id="useLog" checked> log₁₀(σ) for leaf length</label>
  <label>Base edge:
    <input type="range" id="baseEdge" min="30" max="120" step="2" value="60"><span id="baseEdgeLbl">60</span> px
  </label>
  <label>Leaf extra:
    <input type="range" id="leafMin" min="6" max="80" step="1" value="10"><span id="leafMinLbl">10</span> px
    <input type="range" id="leafMax" min="20" max="240" step="2" value="120"><span id="leafMaxLbl">120</span> px
  </label>
  <button id="resetView" class="pill">↺ Reset Zoom</button>
  <div id="status">Loading data.csv…</div>
</header>

<svg id="chart"></svg>

<aside>
  <h3>Filter ions</h3>
  <div style="display:flex;gap:8px;margin-bottom:6px;">
    <button id="selectAllBtn" class="pill" style="padding:6px 10px;">Select All</button>
    <button id="clearAllBtn" class="pill" style="padding:6px 10px;">Clear</button>
  </div>
  <select id="ionSelect" multiple></select>

  <h3>Labels</h3>
  <label><input type="checkbox" id="showIonLbl" checked> Ion</label>
  <label><input type="checkbox" id="showStructLbl" checked> Structure</label>
  <label><input type="checkbox" id="showDopingLbl" checked> Doping</label>
  <label><input type="checkbox" id="showFormulaLbl"> Formula</label>

  <h3>Label sizes</h3>
  <label>Structure <input type="range" id="fsStruct" min="8" max="14" step="1" value="10"><span id="fsStructLbl">10</span> px</label>
  <label>Doping <input type="range" id="fsDoping" min="7" max="13" step="1" value="9"><span id="fsDopingLbl">9</span> px</label>
  <label>Formula <input type="range" id="fsFormula" min="6" max="12" step="1" value="8"><span id="fsFormulaLbl">8</span> px</label>

  <h3>Declutter (min angle gap, °)</h3>
  <label>Structure <input type="number" id="gapStruct" value="3" step="1" style="width:64px;"></label>
  <label>Doping <input type="number" id="gapDoping" value="2" step="1" style="width:64px;"></label>
  <label>Formula <input type="number" id="gapFormula" value="1" step="1" style="width:64px;"></label>

  <h3>Leaf spacing</h3>
  <label>Formula leaf spread (px along arc)
    <input type="range" id="leafSpread" min="0" max="40" step="1" value="12"><span id="leafSpreadLbl">12</span>
  </label>

  <h3>Ion colors</h3>
  <div id="ionLegend" class="legend"></div>
</aside>

<div class="tip" id="tooltip"></div>

<script>
const statusEl = document.getElementById('status');
const resetBtn = document.getElementById('resetView');
const svg = d3.select('#chart');
const tip = d3.select('#tooltip');
const basePalette = d3.schemeTableau10.concat(d3.schemeSet3);
const ionColorScale = d3.scaleOrdinal().range(basePalette);

let DATA=null, COLS=null, WIDTH=0, HEIGHT=0, R=0;
let focusIon = null; // null = all ions
function say(t){ statusEl.textContent = t; }

// conductivity parser → numeric S/cm
function parseSigma(v){
  if (v == null) return NaN;
  let s = String(v).trim();
  if (!s) return NaN;
  s = s.replace(/[,\s]/g, '').replace(/[−–—-]/g, '-');
  const sup = { '⁰':'0','¹':'1','²':'2','³':'3','⁴':'4','⁵':'5','⁶':'6','⁷':'7','⁸':'8','⁹':'9','⁺':'+','⁻':'-' };
  s = [...s].map(ch => sup[ch] ?? ch).join('');
  s = s.replace(/([0-9.]+)\s*(?:×|x|\*)\s*10\^?([+\-]?\d+)/i, '$1e$2');
  let n = Number(s); if (Number.isFinite(n)) return n;
  const m = s.match(/^[+\-]?\d*\.?\d+(?:e[+\-]?\d+)?/i);
  return m ? Number(m[0]) : NaN;
}

/* Build per-row leaf objects (group by canonical; display raw)
   Default σ if missing/invalid, and flag isDefault. */
function buildLeaves(rows){
  const {ion,struct,doping,formula,sigma} = COLS; // struct = canonical
  const leaves = [];
  const defSigma = parseFloat(document.getElementById('sigmaDefault').value) || 1e-6;

  const uiSel = Array.from(document.getElementById('ionSelect').selectedOptions || []).map(o=>o.value);
  const selectedSet = focusIon ? new Set([focusIon]) : (uiSel.length ? new Set(uiSel) : null);

  for (const r of rows){
    const ionV = (r[ion]||'Other').toString().trim();
    if (selectedSet && !selectedSet.has(ionV)) continue;

    const structCanon = (r[struct] || 'Other / Novel').toString().trim();
    const structRaw   = (r["Structure Type (raw)"] || structCanon).toString().trim();
    const dopV = (r[doping]||'(none)').toString().trim();
    const formV = (r[formula]||'(formula)').toString().trim();

    let pv = parseSigma(r[sigma]);
    const isDefault = !(Number.isFinite(pv) && pv > 0);
    if (isDefault) {
      pv = defSigma;
      r[sigma] = defSigma.toExponential(3);
    }

    leaves.push({
      ion: ionV,
      structure: structCanon,     // grouping
      structureLabel: structRaw,  // RAW type shown
      doping: dopV,
      formula: formV,
      sigma: pv,                  // numeric σ
      isDefault
    });
  }
  return leaves;
}

function drawTree(rows){
  const bb = document.getElementById('chart').getBoundingClientRect();
  WIDTH = bb.width; HEIGHT = bb.height; R = Math.min(WIDTH, HEIGHT)/2 - 40;

  // Reset and create the zoomable container group
  svg.attr('viewBox', `${-WIDTH/2} ${-HEIGHT/2} ${WIDTH} ${HEIGHT}`).selectAll('*').remove();
  const g = svg.append('g').attr('class','tree-group');

  const useLog  = document.getElementById('useLog').checked;
  const baseEdge = +document.getElementById('baseEdge').value;
  const leafMin  = +document.getElementById('leafMin').value;
  const leafMax  = +document.getElementById('leafMax').value;
  const fsStruct = +document.getElementById('fsStruct').value;
  const fsDoping = +document.getElementById('fsDoping').value;
  const fsFormula= +document.getElementById('fsFormula').value;
  const leafSpreadPx = +document.getElementById('leafSpread').value;

  document.getElementById('baseEdgeLbl').textContent = baseEdge;
  document.getElementById('leafMinLbl').textContent = leafMin;
  document.getElementById('leafMaxLbl').textContent = leafMax;
  document.getElementById('fsStructLbl').textContent = fsStruct;
  document.getElementById('fsDopingLbl').textContent = fsDoping;
  document.getElementById('fsFormulaLbl').textContent = fsFormula;
  document.getElementById('leafSpreadLbl').textContent = leafSpreadPx;

  const leaves = buildLeaves(rows);

  // Build nested: Ion → Structure (Canonical) → Doping → Formula
  const root = { name:'root', children:[] };
  const grouped = d3.group(leaves, d=>d.ion, d=>d.structure, d=>d.doping);

  for(const [ion, g1] of grouped){
    const nIon = { name:ion, color:ionColorScale(ion), children:[] };
    for(const [structCanon, g2] of g1){
      const structRawExample = g2[0]?.structureLabel || structCanon;
      const nStruct = { name:structCanon, structureLabel:structRawExample, children:[] };
      for(const [dop, g3] of g2){
        const nDop = { name:dop, children:[] };
        for(const d of g3){
          nDop.children.push({ name:d.formula, sigma:d.sigma, ion:d.ion, isDefault:d.isDefault });
        }
        nStruct.children.push(nDop);
      }
      nIon.children.push(nStruct);
    }
    root.children.push(nIon);
  }

  // Hierarchy & initial angles
  const H = d3.hierarchy(root).sort((a,b)=> d3.ascending(a.data.name, b.data.name));
  d3.cluster().size([2*Math.PI, 1])(H);

  // Base rings for internal levels
  H.each(n=>{ if (n.children) n.y = Math.min(R, n.depth * baseEdge); });

  // σ domain (positive numeric only; per current view)
  const def = parseFloat(document.getElementById('sigmaDefault').value) || 1e-6;
  const posSig = H.leaves().map(l => +l.data.sigma).filter(v => Number.isFinite(v) && v > 0);
  let sMin = posSig.length ? d3.min(posSig) : def;
  let sMax = posSig.length ? d3.max(posSig) : def * 10;
  if (sMin === sMax) { sMin *= 0.9; sMax *= 1.1; }

  const scaleLin = d3.scaleLinear().domain([sMin, sMax]).range([leafMin, leafMax]).nice();
  const scaleLog = d3.scaleLog().domain([Math.max(sMin, Number.MIN_VALUE), sMax]).range([leafMin, leafMax]);

  function extraForSigma(val){
    let v = +val;
    if(!Number.isFinite(v) || v <= 0) v = def;
    return useLog ? scaleLog(v) : scaleLin(v);
  }

  // Prevent flattening at outer radius: fit σ-extra inside remaining radius
  const leafBase = 4 * baseEdge;
  const margin = 12;
  const maxExtra = Math.max(8, (R - margin) - leafBase);
  const rescaleExtra = d3.scaleLinear().domain([leafMin, leafMax]).range([leafMin, maxExtra]);

  // Apply σ-based length to leaves (no clamping)
  H.each(n=>{ 
    if(!n.children){
      const extra = rescaleExtra(extraForSigma(n.data.sigma));
      n.y = leafBase + extra;
    }
  });

  // Spread leaf angles so labels have room
  const spread = leafSpreadPx;
  if (spread > 0) {
    H.descendants().filter(d => d.depth === 3).forEach(parent => {
      const kids = (parent.children || []).filter(c => !c.children);
      const n = kids.length;
      if (n <= 1) return;
      kids.sort((a,b)=> a.x - b.x);
      kids.forEach((c, idx) => {
        const r = Math.max(c.y, 1);
        const delta = (idx - (n - 1)/2) * (spread / r); // px/r -> radians
        c.x += delta;
      });
    });
  }

  // Links & nodes (colors use CSS vars set for dark theme)
  const link = d3.linkRadial().angle(d=>d.x).radius(d=>d.y);
  g.append('g').attr('fill','none').attr('stroke','var(--link)').attr('stroke-width',1)
    .selectAll('path').data(H.links()).join('path').attr('d',d=> link({source:d.source, target:d.target}));

  const nodeG = g.append('g').selectAll('g.node').data(H.descendants()).join('g')
    .attr('class','node')
    .attr('transform',d=>`rotate(${d.x*180/Math.PI-90}) translate(${d.y},0)`);

  nodeG.append('circle')
    .attr('r',d=>d.children?2.2:1.8)
    .attr('fill',d=> d.ancestors().find(a=>a.depth===1)?.data?.color || '#9aa5b1')
    .attr('stroke','var(--node-stroke)')
    .attr('stroke-width',0.8)
    .attr('stroke-dasharray', d => (!d.children && d.data?.isDefault) ? '3,2' : null)
    .on('mousemove',(e,d)=>showTip(e,d)).on('mouseleave',hideTip)
    .on('click', (e,d)=> { if (d.depth === 1) { setFocusIon(d.data.name); zoomToIon(d); } }); // zoom on Ion

  // Labels (structure shows RAW type at depth 2)
  const wantIon     = document.getElementById('showIonLbl').checked;
  const wantStruct  = document.getElementById('showStructLbl').checked;
  const wantDoping  = document.getElementById('showDopingLbl').checked;
  const wantFormula = document.getElementById('showFormulaLbl').checked;

  const layers = [
    {depth:1, show:wantIon,     cls:'lbl-ion',     fs:13, weight:'700', gapDeg:0, off:8, text:(d)=>d.data?.name??'', clickZoom:true},
    {depth:2, show:wantStruct,  cls:'lbl-struct',  fs:fsStruct, weight:'500', gapDeg:+document.getElementById('gapStruct').value,  off:6, text:(d)=>d.data?.structureLabel ?? d.data?.name ?? ''},
    {depth:3, show:wantDoping,  cls:'lbl-doping',  fs:fsDoping, weight:'400', gapDeg:+document.getElementById('gapDoping').value,  off:5, text:(d)=>d.data?.name??''},
    {depth:4, show:wantFormula, cls:'lbl-formula', fs:fsFormula,weight:'400', gapDeg:+document.getElementById('gapFormula').value, off:0, text:(d)=>d.data?.name??''}
  ];

  for(const L of layers){
    if(!L.show) continue;
    const nodes = H.descendants().filter(d=>d.depth===L.depth);

    let renderNodes = nodes;
    if (L.gapDeg && L.gapDeg > 0 && L.depth !== 1) {
      const minGap = L.gapDeg*Math.PI/180;
      const kept=[],sorted=nodes.slice().sort((a,b)=>a.x-b.x);
      for(const d of sorted){ if(!kept.length||Math.abs(d.x-kept[kept.length-1].x)>=minGap) kept.push(d); }
      renderNodes = kept;
    }

    g.append('g').attr('font-size',L.fs).attr('font-weight',L.weight).attr('class',L.cls)
      .selectAll('text').data(renderNodes).join('text')
      .attr('transform',d=>{
        const a=d.x,r=(L.depth===4? d.y : d.y+L.off);
        const x=Math.cos(a-Math.PI/2)*r, y=Math.sin(a-Math.PI/2)*r;
        const rot=a*180/Math.PI-90, flip=a>=Math.PI?180:0;
        return `translate(${x},${y}) rotate(${rot+flip})`;
      })
      .attr('text-anchor',d=>d.x>=Math.PI?'end':'start')
      .text(L.text)
      .style('cursor', (L.clickZoom ? 'pointer' : null))
      .on('click', (e,d)=> { if (L.clickZoom && d.depth===1) { setFocusIon(d.data.name); zoomToIon(d); } });
  }

  // Bottom caption (you can move further down if needed by increasing the margin)
  const caption = "Ion → Structure Group (Canonical) → Doping → Formula • leaf length ∝ σ • RAW structure label • dashed = default σ • click Ion to zoom";
  const bottomMargin = 12;
  g.append("text")
    .attr("class","viz-caption")
    .attr("x", 0)
    .attr("y", HEIGHT/2 - bottomMargin)
    .text(caption);

  // Diag (verify fit/variability)
  const maxY = d3.max(H.leaves().map(d => d.y));
  const atWall = H.leaves().filter(d => (R - d.y) < 1).length;
  say(`Nodes: ${H.descendants().length} • Leaves: ${H.leaves().length} • σ domain: ${sMin.toExponential(2)}→${sMax.toExponential(2)} • maxY=${Math.round(maxY)} • capped=${atWall}`);
}

// Tooltip
function showTip(e,d){
  const anc=d.ancestors().reverse();
  const ion=anc[1]?.data?.name||'(ion)';
  const structure=anc[2]?.data?.structureLabel || anc[2]?.data?.name || '(structure)';
  const doping=anc[3]?.data?.name||'(doping)';
  let html=`<b>${ion}</b> → ${structure} → ${doping}`;

  if(!d.children){
    const v = Number(d.data?.sigma);
    html += `<br><b>${d.data?.name}</b>`;
    if(Number.isFinite(v) && v>0) {
      const tag = d.data?.isDefault ? " (default σ)" : "";
      html += `<br>σ: ${v.toExponential(3)} S·cm⁻¹${tag}`;
    } else {
      const def = parseFloat(document.getElementById('sigmaDefault').value) || 1e-6;
      html += `<br>σ: default ${def.toExponential(3)} S·cm⁻¹ (fallback)`;
    }
  }
  tip.html(html).style('left',(e.clientX+12)+'px').style('top',(e.clientY+12)+'px').style('opacity',1);
}
function hideTip(){ tip.style('opacity',0); }

// Zoom helpers
const zoom = d3.zoom()
  .scaleExtent([0.5, 6])
  .on("zoom", (event) => {
    svg.select("g.tree-group").attr("transform", event.transform);
  });
svg.call(zoom);

function zoomToIon(node) {
  // find node screen coords relative to the centered coordinate system
  const angle = node.x - Math.PI / 2;
  const x = Math.cos(angle) * node.y;
  const y = Math.sin(angle) * node.y;

  svg.transition().duration(800).call(
    zoom.transform,
    d3.zoomIdentity
      .translate(WIDTH / 2, HEIGHT / 2)
      .scale(2.2)
      .translate(-x, -y)
  );
}
function resetZoom() {
  svg.transition().duration(800).call(
    zoom.transform,
    d3.zoomIdentity
      .translate(WIDTH / 2, HEIGHT / 2)
      .scale(1)
  );
  clearFocusIon();
}
resetBtn.addEventListener("click", resetZoom);

// Focus helpers
function setFocusIon(name){
  focusIon = name;
  drawTree(DATA);
}
function clearFocusIon(){
  focusIon = null;
  drawTree(DATA);
}

// ---- Auto-load from data.csv (no upload UI) ----
const CSV_PATH = "data.csv";
async function initFromCSV(){
  say("Loading data.csv...");
  try {
    const rows = await d3.csv(CSV_PATH);
    if(!rows || !rows.length){ say("No rows found in data.csv"); return; }

    COLS = {
      ion:    "Ion Type",
      struct: "Structure Group",  // grouping
      doping: "Doping / and or GB Strategy",
      formula: "Superionic Conductor Formula (Chemical)",
      sigma:  "Conductivity σ (S/cm)"
    };

    const required = [
      "Ion Type","Structure Group",
      "Doping / and or GB Strategy","Superionic Conductor Formula (Chemical)","Conductivity σ (S/cm)"
    ];
    const missing = required.filter(h => !rows.columns.includes(h));
    if (missing.length) { say("Missing columns in data.csv: " + missing.join(", ")); return; }

    DATA = rows;

    // Ion selector & legend
    const ions = [...new Set(rows.map(r => (r[COLS.ion]||'Other').toString().trim()))].sort((a,b)=>a.localeCompare(b));
    const sel = document.getElementById('ionSelect');
    if(sel && sel.options.length===0){
      ions.forEach(i=>{ const o=document.createElement('option'); o.value=i; o.textContent=i; sel.appendChild(o); });
      const leg = document.getElementById('ionLegend');
      ions.forEach(i=>{
        const chip=document.createElement('div'); chip.className='chip';
        const sw=document.createElement('div'); sw.className='sw'; sw.style.background=ionColorScale(i);
        chip.appendChild(sw); chip.appendChild(document.createTextNode(i)); leg.appendChild(chip);
      });
      const note = document.createElement('div');
      note.style.marginTop = '6px'; note.style.fontSize = '12px'; note.style.color = 'var(--muted)';
      note.textContent = 'Dashed outline = default σ used • Click an Ion to zoom • ↺ Reset Zoom to go back';
      leg.appendChild(note);
    }

    // Default: select all ions initially
    if (sel && sel.options.length) for (const o of sel.options) o.selected = true;

    drawTree(DATA);
    say(`Loaded data.csv • rows: ${rows.length}`);
  } catch (err){
    console.error(err);
    say("Failed to load data.csv (serve this folder via http).");
  }
}

// Controls
[
 "ionSelect","showIonLbl","showStructLbl","showDopingLbl","showFormulaLbl",
 "fsStruct","fsDoping","fsFormula",
 "gapStruct","gapDoping","gapFormula",
 "leafSpread","sigmaDefault","useLog","baseEdge","leafMin","leafMax"
].forEach(id=> {
  const el = document.getElementById(id);
  if (el) el.addEventListener('input', ()=> { if(DATA) drawTree(DATA); });
});

document.getElementById('selectAllBtn')?.addEventListener('click', ()=>{
  const sel=document.getElementById('ionSelect'); if(!sel) return;
  for(const o of sel.options){ o.selected=true; } if(DATA) drawTree(DATA);
});
document.getElementById('clearAllBtn')?.addEventListener('click', ()=>{
  const sel=document.getElementById('ionSelect'); if(!sel) return;
  for(const o of sel.options){ o.selected=false; } if(DATA) drawTree(DATA);
});

// Redraw on resize
window.addEventListener('resize', () => { if (DATA) drawTree(DATA); });

// Kick off
initFromCSV();
</script>
</body>
</html>
