<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Zoomable Circle Packing — Structure Group / Ion Type</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f17; color: #e6edf3;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; }
    #chart { height: 100vh; width: 100vw; }
    .label { fill: #e6edf3; pointer-events: none; text-anchor: middle; dominant-baseline: middle; text-shadow:
      0 1px 0 rgba(0,0,0,.5), 0 -1px 0 rgba(0,0,0,.5),
      1px 0 0 rgba(0,0,0,.5), -1px 0 0 rgba(0,0,0,.5); }
    .breadcrumb { position: fixed; top: 10px; left: 12px; background: rgba(255,255,255,0.06);
      backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.08); padding: 8px 10px;
      border-radius: 10px; font-size: 13px; z-index: 10; user-select: none; }
    .breadcrumb a { color: #8ab4ff; text-decoration: none; cursor: pointer; }
    .breadcrumb .sep { opacity: .5; margin: 0 6px; }
  </style>
</head>
<body>
  <div class="breadcrumb" id="trail">Loading…</div>
  <div id="chart"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  d3.csv("data.csv").then(raw => {
    raw = raw.filter(d => d["Structure Group"] && d["Ion Type"])
             .map(d => ({ group: String(d["Structure Group"]).trim(),
                          ion: String(d["Ion Type"]).trim() }));

    const grouped = d3.group(raw, d => d.group);
    const rootData = {
      name: "All Structure Groups",
      children: Array.from(grouped, ([group, rows]) => ({
        name: group,
        children: Array.from(
          d3.rollup(rows, v => v.length, d => d.ion),
          ([ion, count]) => ({ name: ion, value: count })
        )
      }))
    };

    // Get all ions for consistent colors
    const allIons = Array.from(new Set(raw.map(d => d.ion)));
    const ionColor = d3.scaleOrdinal(allIons, d3.schemeTableau10.concat(d3.schemeSet3).flat());

    draw(rootData, ionColor);
  }).catch(() => {
    document.getElementById('trail').textContent =
      "⚠️ Failed to load data.csv — please open this file via a local web server.";
  });

  function draw(data, ionColor) {
    const size = Math.min(window.innerWidth, window.innerHeight);
    const pack = data => d3.pack()
      .size([size, size])
      .padding(3)
      (d3.hierarchy(data)
        .sum(d => d.value || 0)
        .sort((a, b) => (b.value || 0) - (a.value || 0)));

    const root = pack(data);
    let focus = root, view;

    const svg = d3.select("#chart").append("svg")
      .attr("viewBox", `${-size/2} ${-size/2} ${size} ${size}`)
      .attr("width", "100%")
      .attr("height", "100%")
      .style("cursor", "pointer");

    const g = svg.append("g");

    const node = g.selectAll("circle")
      .data(root.descendants())
      .join("circle")
        .attr("fill", d => d.children ? "#202530" : ionColor(d.data.name))
        .attr("stroke", "rgba(255,255,255,0.15)")
        .attr("stroke-width", 1)
        .on("click", (event, d) => focus !== d ? (zoom(event, d), event.stopPropagation()) : null);

    // Labels: always show name + count on leaves, group name on parents
    const label = g.selectAll("text")
      .data(root.descendants())
      .join("text")
        .attr("class", "label")
        .text(d => d.children ? d.data.name : `${d.data.name} (${d.value})`)
        .style("font-size", d => `${Math.max(8, d.r / 4)}px`)
        .style("fill-opacity", d => d.parent === root ? 1 : 0)
        .style("display", d => d.parent === root ? "inline" : "none");

    svg.on("click", (event) => zoom(event, root));

    zoomTo([root.x, root.y, root.r * 2]);
    updateTrail(root);

    function zoomTo(v) {
      const k = size / v[2];
      view = v;
      label.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`)
           .style("font-size", d => `${Math.max(6, d.r * k / 4)}px`);
      node.attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`)
          .attr("r", d => d.r * k);
    }

    function zoom(event, d) {
      focus = d;
      const transition = svg.transition()
        .duration(650)
        .tween("zoom", () => {
          const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);
          return t => zoomTo(i(t));
        });

      label
        .filter(function(dd) { return dd.parent === focus || this.style.display === "inline"; })
        .transition(transition)
          .style("fill-opacity", dd => dd.parent === focus ? 1 : 0)
          .on("start", function(dd) { if (dd.parent === focus) this.style.display = "inline"; })
          .on("end",   function(dd) { if (dd.parent !== focus) this.style.display = "none"; });

      updateTrail(d);
    }

    function updateTrail(d) {
      const trail = document.getElementById('trail');
      const ancestors = d.ancestors().reverse();
      trail.innerHTML = ancestors.map((a, i) =>
        i === ancestors.length - 1
          ? `<strong>${a.data.name}</strong>`
          : `<a data-depth="${i}">${a.data.name}</a>`
      ).join('<span class="sep">›</span>');
      [...trail.querySelectorAll('a')].forEach(a => {
        a.addEventListener('click', () => {
          const depth = +a.getAttribute('data-depth');
          const target = ancestors[depth];
          if (target) zoom(null, target);
        });
      });
    }

    window.addEventListener('resize', () => {
      const s = Math.min(window.innerWidth, window.innerHeight);
      svg.attr("viewBox", `${-s/2} ${-s/2} ${s} ${s}`);
      zoomTo([focus.x, focus.y, focus.r * 2]);
    });
  }
  </script>
</body>
</html>
