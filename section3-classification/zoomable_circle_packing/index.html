<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Zoomable Circle Packing — Structure Group & Ion Colors</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#fafafa; color:#222;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,"Noto Sans",Arial; }
    #chart { height:100vh; width:100vw; }
    text.label { fill:#222; pointer-events:none; text-anchor:middle; dominant-baseline:middle; }
    .breadcrumb {
      position:fixed; top:10px; left:12px; background:rgba(0,0,0,0.05); backdrop-filter:blur(8px);
      border:1px solid rgba(0,0,0,0.1); padding:8px 10px; border-radius:10px; font-size:13px;
      z-index:10; user-select:none; color:#222;
    }
    .breadcrumb a { color:#3366cc; text-decoration:none; cursor:pointer; }
    .breadcrumb .sep { opacity:.6; margin:0 6px; }
  </style>
</head>
<body>
  <div class="breadcrumb" id="trail"></div>
  <div id="chart"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  d3.csv("data.csv").then(raw => {
    raw = raw.filter(d => d["Structure Group"] && d["Ion Type"])
             .map(d => ({ group: String(d["Structure Group"]).trim(),
                          ion:   String(d["Ion Type"]).trim() }));

    // Build hierarchy root → structure group → ion counts
    const grouped = d3.group(raw, d => d.group);
    const rootData = {
      name: "All",
      children: Array.from(grouped, ([group, rows]) => ({
        name: group,
        children: Array.from(
          d3.rollup(rows, v => v.length, d => d.ion),
          ([ion, count]) => ({ name: ion, value: count })
        )
      }))
    };

    // ---------- Your color palettes ----------
    const ION_COLORS = {
      "Li+":  "#ff5252","Na+":  "#81d4fa","K+":   "#004d40","Ag+":  "#f48fb1",
      "O2-":  "#6d4c41","Zn2+": "#c2185b","H+":   "#ffd54f","Rb+":  "#43a047",
      "F-":   "#ff8a65","Cu+":  "#5c6bc0","Mg2+": "#26c6da","In3+": "#c0ca33",
      "I-":   "#ec407a","Sn4+": "#7e57c2"
    };
    const STRUCT_COLORS = {
      "Others":"#9e9e9e","Polymeric":"#ff7043","Argyrodite":"#ab47bc","Halide":"#26a69a",
      "Amorphous":"#f6bf26","NASICON":"#66bb6a","Anti-perovskite":"#0d47a1","Spinel":"#8d6e63"
    };

    const getIonColor = ion => ION_COLORS[ion] || "#ccc";
    const getStructColor = group => STRUCT_COLORS[group] || "#ccc";

    draw(rootData);

    function draw(data) {
      const size = Math.min(window.innerWidth, window.innerHeight);
      const padding = 3;

      const pack = data => d3.pack().size([size, size]).padding(padding)(
        d3.hierarchy(data)
          .sum(d => d.value || 0)
          .sort((a, b) => (b.value || 0) - (a.value || 0))
      );

      const root = pack(data);
      let focus = root, view;

      const svg = d3.select("#chart").append("svg")
        .attr("viewBox", `${-size/2} ${-size/2} ${size} ${size}`)
        .attr("width", "100%")
        .attr("height", "100%")
        .style("cursor", "pointer");

      const g = svg.append("g");
      const nodes = root.descendants();

      const circles = g.selectAll("circle")
        .data(nodes)
        .join("circle")
          .attr("fill", d =>
            d.depth === 0 ? "none" :
            (d.children ? getStructColor(d.data.name) : getIonColor(d.data.name)))
          .attr("stroke", d => d.depth === 0 ? "rgba(0,0,0,0.25)" : "rgba(0,0,0,0.2)")
          .attr("stroke-width", d => d.depth === 0 ? 1.5 : (d.children ? 1 : 0.75))
          .style("pointer-events", d => d.depth === 0 ? "none" : null)
          .on("click", (event, d) => focus !== d ? (zoom(event, d), event.stopPropagation()) : null);

      const groupLabels = g.selectAll("text.group-label")
        .data(nodes.filter(d => d.children && d.depth > 0))
        .join("text")
          .attr("class", "label group-label")
          .text(d => d.data.name);

      const ionLabels = g.selectAll("text.ion-label")
        .data(nodes.filter(d => !d.children))
        .join("text")
          .attr("class", "label ion-label")
          .text(d => `${d.data.name} (${d.value})`);

      svg.on("click", e => zoom(e, root));

      zoomTo([root.x, root.y, root.r * 2]);
      updateTrail(root);

      function zoomTo(v) {
        const k = size / v[2];
        view = v;
        circles
          .attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`)
          .attr("r", d => d.r * k);

        groupLabels
          .attr("transform", d => {
            const x = (d.x - v[0]) * k;
            const yTop = (d.y - v[1]) * k - (d.r * k * 0.45);
            return `translate(${x},${yTop})`;
          })
          .style("font-size", d => `${Math.max(10, (d.r * k)/4)}px`)
          .style("display", d => (d === focus || d.parent === focus) ? "inline" : "none");

        ionLabels
          .attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`)
          .style("font-size", d => `${Math.max(8, (d.r * k)/4)}px`)
          .style("display", d => (d.r * k >= 14) ? "inline" : "none");
      }

      function zoom(event, d) {
        focus = d;
        const t = svg.transition()
          .duration(650)
          .tween("zoom", () => {
            const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);
            return t => zoomTo(i(t));
          });
        updateTrail(d);
      }

      function updateTrail(d) {
        const trail = document.getElementById('trail');
        const ancestors = d.ancestors().reverse().slice(1);
        trail.innerHTML = ancestors.length
          ? ancestors.map((a, i) =>
              i === ancestors.length - 1
                ? `<strong>${a.data.name}</strong>`
                : `<a data-depth="${i}">${a.data.name}</a>`
            ).join('<span class="sep">›</span>')
          : "";
        [...trail.querySelectorAll('a')].forEach(a => {
          a.addEventListener('click', () => {
            const depth = +a.getAttribute('data-depth');
            const target = ancestors[depth];
            if (target) zoom(null, target);
          });
        });
      }

      window.addEventListener('resize', () => {
        const s = Math.min(window.innerWidth, window.innerHeight);
        svg.attr("viewBox", `${-s/2} ${-s/2} ${s} ${s}`);
        zoomTo([focus.x, focus.y, focus.r * 2]);
      });
    }
  }).catch(() => {
    document.getElementById('trail').textContent =
      "⚠️ Failed to load data.csv — please open this file via a local web server.";
  });
  </script>
</body>
</html>
