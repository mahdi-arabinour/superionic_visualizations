section3-classification/zoomable_circle_packing<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Zoomable Circle Packing — Structure Group / Ion Type (Light)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #fafafa;
      color: #222;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
    }
    #chart { height: 100vh; width: 100vw; }
    text.label {
      fill: #222;
      pointer-events: none;
      text-anchor: middle;
      dominant-baseline: middle;
      text-shadow: none;
    }
    .breadcrumb {
      position: fixed;
      top: 10px;
      left: 12px;
      background: rgba(0,0,0,0.05);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(0,0,0,0.1);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px;
      z-index: 10;
      user-select: none;
      color: #222;
    }
    .breadcrumb a { color: #3366cc; text-decoration: none; cursor: pointer; }
    .breadcrumb .sep { opacity: .6; margin: 0 6px; }
  </style>
</head>
<body>
  <div class="breadcrumb" id="trail"></div>
  <div id="chart"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  // Load CSV from same folder (expects columns: "Structure Group", "Ion Type")
  d3.csv("data.csv").then(raw => {
    raw = raw.filter(d => d["Structure Group"] && d["Ion Type"])
             .map(d => ({ group: String(d["Structure Group"]).trim(),
                          ion:   String(d["Ion Type"]).trim() }));

    // Build hierarchy: root -> structure group -> ion counts
    const grouped = d3.group(raw, d => d.group);
    const rootData = {
      name: "", // keep empty, but we'll not render the root circle
      children: Array.from(grouped, ([group, rows]) => ({
        name: group,
        children: Array.from(
          d3.rollup(rows, v => v.length, d => d.ion),
          ([ion, count]) => ({ name: ion, value: count })
        )
      }))
    };

    // Global ion list for consistent colors
    const allIons = Array.from(new Set(raw.map(d => d.ion)));
    const palette = d3.schemeTableau10.concat(d3.schemeSet3, d3.schemePaired, d3.schemeDark2, d3.schemePastel2).flat();
    const ionColor = d3.scaleOrdinal(allIons, palette);

    draw(rootData, ionColor);
  }).catch(() => {
    document.getElementById('trail').textContent =
      "⚠️ Failed to load data.csv — please open this file via a local web server.";
  });

  function draw(data, ionColor) {
    const size = Math.min(window.innerWidth, window.innerHeight);
    const padding = 3;

    const pack = data => d3.pack().size([size, size]).padding(padding)(
      d3.hierarchy(data)
        .sum(d => d.value || 0)
        .sort((a, b) => (b.value || 0) - (a.value || 0))
    );

    const root = pack(data);
    let focus = root, view;

    const svg = d3.select("#chart").append("svg")
      .attr("viewBox", `${-size/2} ${-size/2} ${size} ${size}`)
      .attr("width", "100%")
      .attr("height", "100%")
      .style("cursor", "pointer");

    const g = svg.append("g");
    const nodes = root.descendants();

    // Circles (skip the root to avoid empty central space)
    const circles = g.selectAll("circle")
      .data(nodes.filter(d => d.depth > 0))
      .join("circle")
        .attr("fill", d => d.children ? "#f3f3f3" : ionColor(d.data.name))
        .attr("stroke", "rgba(0,0,0,0.2)")
        .attr("stroke-width", d => d.children ? 1 : 0.75)
        .on("click", (event, d) => focus !== d ? (zoom(event, d), event.stopPropagation()) : null);

    // GROUP LABELS (parents, depth > 0), positioned near top of circle
    const groupLabels = g.selectAll("text.group-label")
      .data(nodes.filter(d => d.children && d.depth > 0))
      .join("text")
        .attr("class", "label group-label")
        .text(d => d.data.name);

    // ION LABELS (leaves)
    const ionLabels = g.selectAll("text.ion-label")
      .data(nodes.filter(d => !d.children))
      .join("text")
        .attr("class", "label ion-label")
        .text(d => `${d.data.name} (${d.value})`);

    svg.on("click", (event) => zoom(event, root));

    // Initial layout
    zoomTo([root.x, root.y, root.r * 2]);
    updateTrail(root);

    function zoomTo(v) {
      const k = size / v[2];
      view = v;

      // Circles
      circles
        .attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`)
        .attr("r", d => d.r * k);

      // Group labels near the top of their circle
      groupLabels
        .attr("transform", d => {
          const x = (d.x - v[0]) * k;
          const yTop = (d.y - v[1]) * k - (d.r * k * 0.45);
          return `translate(${x},${yTop})`;
        })
        .style("font-size", d => `${Math.max(10, (d.r * k) / 4)}px`)
        .style("display", d => (d === focus || d.parent === focus) ? "inline" : "none")
        .style("fill-opacity", d => (d === focus || d.parent === focus) ? 1 : 0);

      // Ion labels centered; hidden if circle too small
      ionLabels
        .attr("transform", d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`)
        .style("font-size", d => `${Math.max(8, (d.r * k) / 4)}px`)
        .style("display", d => (d.r * k >= 14) ? "inline" : "none")
        .style("fill-opacity", d => (d.r * k >= 14) ? 1 : 0);
    }

    function zoom(event, d) {
      focus = d;
      const t = svg.transition()
        .duration(650)
        .tween("zoom", () => {
          const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);
          return t => zoomTo(i(t));
        });
      updateTrail(d);
    }

    function updateTrail(d) {
      const trail = document.getElementById('trail');
      const ancestors = d.ancestors().reverse().slice(1); // drop root from breadcrumb
      trail.innerHTML = ancestors.length
        ? ancestors.map((a, i) =>
            i === ancestors.length - 1
              ? `<strong>${a.data.name}</strong>`
              : `<a data-depth="${i}">${a.data.name}</a>`
          ).join('<span class="sep">›</span>')
        : "";
      [...trail.querySelectorAll('a')].forEach(a => {
        a.addEventListener('click', () => {
          const depth = +a.getAttribute('data-depth');
          const target = ancestors[depth];
          if (target) zoom(null, target);
        });
      });
    }

    // Keep centered on resize
    window.addEventListener('resize', () => {
      const s = Math.min(window.innerWidth, window.innerHeight);
      svg.attr("viewBox", `${-s/2} ${-s/2} ${s} ${s}`);
      zoomTo([focus.x, focus.y, focus.r * 2]);
    });
  }
  </script>
</body>
</html>
